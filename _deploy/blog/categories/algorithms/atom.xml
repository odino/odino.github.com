<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: algorithms | Alessandro Nadalin]]></title>
  <link href="http://odino.org/blog/categories/algorithms/atom.xml" rel="self"/>
  <link href="http://odino.org/"/>
  <updated>2012-05-14T15:18:42+04:00</updated>
  <id>http://odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Quality isn't always better than quantity]]></title>
    <link href="http://odino.org/quality-isnt-always-better-than-quality/"/>
    <updated>2012-01-25T13:43:00+04:00</updated>
    <id>http://odino.org/quality-isnt-always-better-than-quality</id>
    <content type="html"><![CDATA[<p>Reading about <a href="http://www.amazon.com/Data-Intensive-Processing-MapReduce-Synthesis-Technologies/dp/1608453421">data processing with MapReduce</a>
I was astonished when I first encountered the <em><a href="http://books.google.it/books?id=GxFYuVZHG60C&amp;pg=PA134&amp;lpg=PA134&amp;dq=stupid+backoff+algorithm&amp;source=bl&amp;ots=fMzZNlaNaN&amp;sig=mcEdim6-_wZL4aWKebh3s79KMS4&amp;hl=it&amp;sa=X&amp;ei=z_kfT56BG-vP4QSY2N2ODw&amp;ved=0CD0Q6AEwAzgK#v=onepage&amp;q=stupid%20backoff%20algorithm&amp;f=false">Stupid backoff</a></em>
algorithm's tale.</p>

<!-- more -->


<p>The story is pretty simple: the <a href="diom.ucsd.edu/~rlevy/lign256/winter2008/kneser_ney_mini_example.pdf">Kneser-Ney</a>
smoothing strategy was a <em>state-of-the-art</em> way for processing data, but it
had an heavy computational cost.</p>

<p><blockquote><p>We introduce a new smoothing method, dubbed Stupid Backoff, that is inexpensive to train on large data sets and approaches the quality of Kneser-Ney Smoothing as the amount of training data increases.</p><footer><strong>Thorsten Brants</strong> <cite><a href='http://acl.ldc.upenn.edu/D/D07/D07-1090.pdf'>Large Language Models in Machine Translation</a></cite></footer></blockquote></p>

<p>In 2007 <a href="http://www.coli.uni-saarland.de/~thorsten/">Thorsten Brants</a> developed
a new smoothing algorithm, simpler than the Kneser-Ney one, which was very lean
and appliable to large amounts of data.</p>

<h2>The result?</h2>

<p>These algorithms were heavily used in machine translations, and you can already
figure out what happened: with small datasets the <em>backoff</em> was generating
less-accurate translations but, as the amount of data analized growed, it was
able to extract more valid translations, eventually beating Kneser-Ney's score<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>.</p>

<p>I'd like you to read a few notes about the <em>stupid backoff</em>'s introductory paper:</p>

<iframe src="http://docs.google.com/viewer?url=http%3A%2F%2Facl.ldc.upenn.edu%2FD%2FD07%2FD07-1090.pdf&embedded=true" width="100%" height="780" style="border: none;"></iframe>


<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>This was possible, in the machine-translation scenario, thanks to the fact that the algorithm could be "trained" to perform better translations as the dataset grew <a href='#fnref:1' rev='footnote'>â†©</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The shortest path problem in PHP: demystifying Dijkstra's algorithm]]></title>
    <link href="http://odino.org/the-shortest-path-problem-in-php-demystifying-dijkstra-s-algorithm/"/>
    <updated>2011-09-06T02:14:00+04:00</updated>
    <id>http://odino.org/the-shortest-path-problem-in-php-demystifying-dijkstra-s-algorithm</id>
    <content type="html"><![CDATA[<p>After a very long, but intensive, night, I'm happy to announce that <a href="https://github.com/congow/Orient">Orient</a>, the PHP library used to work with <a href="http://www.orientechnologies.com/orient-db.htm">OrientDB</a>, has integrated an interesting feature, an implementation of <a href="http://en.wikipedia.org/wiki/Dijkstra's_algorithm">Dijkstra's algorithm</a>.</p>

<!-- more -->


<p>First of all, let me tell you that, as a pretty new implementation, I'm pretty sure a couple bugs will be spotted in the next days; second, the design of the algorithm and the entities connected to it could probably be better, so I recommend you to just take a look at the final result, 'cause the internals will probably change a bit.</p>

<h2>The problem</h2>

<p>Given the following graph:</p>

<p><img class="center" src="/images/graph-sp.png"></p>

<p>how do you calculate the <strong>best way to reach Tokio from Rome</strong>?</p>

<p>Ok, that's easy, you can count with your mind when you have such a small dataset:</p>

<p><img class="center" src="/images/graph-sp.png"></p>

<p>and as you probably already know, the simplest solution is to fly from Rome to Amsterdam To LA to Tokio: the distance is 13 (hours? 13k miles? No matter now).</p>

<p>(You can also reach Amsterdam via Paris, but we don't care for the aim of this post)</p>

<h2>The dataset grows... enter Orient</h2>

<p>But as your dataset grows, you need to automate the process of <strong>finding shortest paths</strong>.</p>

<p>Just install Orient:</p>

<p><code>bash
git clone git@github.com:congow/Orient.git
</code></p>

<p>and create your <code>path.php</code> script, which should use the <a href="https://gist.github.com/221634">PSR-0</a> autoloader:</p>

<p>``` php
&lt;?php</p>

<p>$classLoader = new SplClassLoader('Congow\Orient', <strong>DIR</strong> . "/Orient/src");
$classLoader->register();</p>

<p>use Congow\Orient\Graph;
use Congow\Orient\Graph\Vertex;
use Congow\Orient\Algorithm;
```</p>

<p>At this point you might think that the algorithm's implementation is pretty coupled with the rest of the library we're developing, and you would be terribly wrong.</p>

<p>Take a look on how to create the graph</p>

<p>``` php
&lt;?php</p>

<p>$graph = new Graph();
```</p>

<p>how to create vertices</p>

<p>``` php
&lt;?php</p>

<p>$rome      = new Vertex('Rome');
$paris     = new Vertex('Paris');
$london    = new Vertex('London');
$amsterdam = new Vertex('Amsterdam');
$ny        = new Vertex('New York');
$la        = new Vertex('Los Angeles');
$tokio     = new Vertex('Tokio');
```</p>

<p>and how to connect vertices between themselves:</p>

<p>``` php
&lt;?php</p>

<p>$rome->connect($paris, 2);
$rome->connect($london, 3);
$rome->connect($amsterdam, 3);
$paris->connect($london, 1);
$paris->connect($amsterdam, 1);
$london->connect($ny, 10);
$amsterdam->connect($la, 8);
$la->connect($tokio, 2);
$ny->connect($tokio, 3);
```</p>

<p>final step, add the vertices to the graph:</p>

<p>``` php
&lt;?php</p>

<p>$graph->add($rome);
$graph->add($paris);
$graph->add($london);
$graph->add($amsterdam);
$graph->add($ny);
$graph->add($la);
$graph->add($tokio);
```</p>

<p>So, you have basically created some fixtures ( a fake graph, the one of the pictures above ), and we can finally calculate the shortest path from Rome to Tokio:</p>

<p>``` php
&lt;?php</p>

<p>$algorithm = new Algorithm\Dijkstra($graph);
$algorithm->setStartingVertex($rome);
$algorithm->setEndingVertex($tokio);</p>

<p>echo $algorithm->getLiteralShortestPath() . ": distance " . $algorithm->getDistance();
// the real method to get the SP is $algorithm->solve(), the ones used above are for printing a nice result
```</p>

<p>which will output:</p>

<p><code>bash
Rome - Amsterdam - Los Angeles - Tokio : distance 13
</code></p>

<p>If you have suggestions and questions, feel free to ask everything here; also, if you spot a bug, pull requests are welcome.</p>
]]></content>
  </entry>
  
</feed>
