<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cache | Alessandro Nadalin]]></title>
  <link href="http://odino.github.io/blog/categories/cache/atom.xml" rel="self"/>
  <link href="http://odino.github.io/"/>
  <updated>2013-06-18T13:59:12+04:00</updated>
  <id>http://odino.github.io/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Scaling asynchronously through HInclude]]></title>
    <link href="http://odino.github.io/scaling-through-hinclude/"/>
    <updated>2012-02-24T10:50:00+04:00</updated>
    <id>http://odino.github.io/scaling-through-hinclude</id>
    <content type="html"><![CDATA[<p>Since it&rsquo;s been a while that I spread the idea of
having <a href="/edge-side-includes-how-to-spare-terabytes-every-day/">ESI on the client side</a>,
someone pointed out that a good solution, technically
different from the one I personally proposed, would
be to use JavaScript to and asynchronous sub-requests.</p>

<!-- more -->


<p>There is a small JS library, written by the good
<a href="http://www.mnot.net/">Mark Nottingham</a><sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>,
called <a href="http://mnot.github.com/hinclude/">HInclude</a>,
which does this kind of job.</p>

<h2>The problem</h2>

<p>Consider that you have an high-traffic websites which has
some parts of its webpages that rarely change, like the header,
the footer and some sidebars: why should you regenerate all
those parts at every request?</p>

<p><a href="http://www.w3.org/TR/esi-lang">ESI</a> solves this kind
of problem, but requires you to make a request through the
network, as you need, at least, to hit the reverse proxy,
which then handles the composition on a resource with
sub-resources.</p>

<p>As I <a href="/edge-side-includes-how-to-spare-terabytes-every-day/">stated earlier</a>,
this is not an optimal approach for every <em>use-case</em>, so you
definitely should try to use local caches (your users) to
scale better.</p>

<h2>The solution</h2>

<p>HInclude fits perfectly in this context, as you only need to
include the JS and add a namespace declaration to your documents:</p>

<p>``` html
  <html xmlns:hx="http://purl.org/NET/hinclude"></p>

<pre><code>&lt;head&gt;
  &lt;script src="http://odino.github.io/lib/hinclude.js"
   type="text/javascript"&gt;&lt;/script&gt;
</code></pre>

<p>```</p>

<p>whenever you need to aggregate data from a sub-resource you
only need to <strong>add an hinclude tag</strong>:</p>

<p><code>html
&lt;hx:include src="http://odino.github.io/header.html"&gt;&lt;/hx:include&gt;
</code></p>

<p>You can specify a default content &ndash; if the user has not javascript
or whatever &ndash; and it provides a nice behaviour when the sub-request
generates an error (status codes different from <code>200</code> and <code>304</code>), as
it adds an <code>hinclude_$statusCode</code> class to the tag.</p>

<h2>A dummy benchmark</h2>

<p>I provide here a benchmark, a simple and silly one, as you should be
already able to understand the power of HInclude.</p>

<p>First of all let&rsquo;s create a simple response, which aggregates header
and footer directly from PHP, as we are used to do:</p>

<p>``` php index_no_hinclude.php
<html></p>

<pre><code>&lt;head&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;
    &lt;?php include 'header.php'; ?&gt;
  &lt;/p&gt;
  &lt;div class="main"&gt;
    &lt;!-- start slipsum code --&gt;

    Look, just because I don't be givin' no man a foot massage don't make it right for Marsellus to throw Antwone into a glass motherfuckin' house, fuckin' up the way the nigger talks. Motherfucker do that shit to me, he better paralyze my ass, 'cause I'll kill the motherfucker, know what I'm sayin'?

    &lt;!-- please do not remove this line --&gt;

    &lt;div style="display:none;"&gt;
    &lt;a href="http://slipsum.com"&gt;lorem ipsum&lt;/a&gt;&lt;/div&gt;

    &lt;!-- end slipsum code --&gt;
  &lt;/div&gt;
  &lt;p&gt;
    &lt;?php include 'footer.php'; ?&gt;
  &lt;/p&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<p>and then the header and footer files:</p>

<p>``` php header.php
&lt;?php usleep(200000); ?></p>

<!-- start slipsum code -->


<p>You think water moves fast? You should see ice. It moves like it has a mind. Like it knows it killed the world once and got a taste for murder. After the avalanche, it took us a week to climb out. Now, I don&rsquo;t know exactly when we turned on each other, but I know that seven of us survived the slide&hellip; and only five made it out. Now we took an oath, that I&rsquo;m breaking now. We said we&rsquo;d say it was the snow that killed the other two, but it wasn&rsquo;t. Nature is lethal but it doesn&rsquo;t hold a candle to man.</p>

<!-- please do not remove this line -->




<div style="display:none;">
<a href="http://slipsum.com">lorem ipsum</a></div>




<!-- end slipsum code -->


<p>```</p>

<p>``` php footer.php
&lt;?php usleep(200000); ?></p>

<!-- start slipsum code -->


<p>Normally, both your asses would be dead as fucking fried chicken, but you happen to pull this shit while I&rsquo;m in a transitional period so I don&rsquo;t wanna kill you, I wanna help you. But I can&rsquo;t give you this case, it don&rsquo;t belong to me. Besides, I&rsquo;ve already been through too much shit this morning over this case to hand it over to your dumb ass.</p>

<!-- please do not remove this line -->




<div style="display:none;">
<a href="http://slipsum.com">lorem ipsum</a></div>




<!-- end slipsum code -->


<p>```</p>

<p>Bear in mind that I use</p>

<p><code>php
&lt;?php usleep(200000); ?&gt;
</code></p>

<p>to simulate some php code execution (<code>200ms</code> seems a
reasonable amount of time &ndash; inspired by one of our
live projects).</p>

<p>I took a look at Chrome&rsquo;s timeline bar to get an idea of
the average time spent for rendering this resource, and it
was <code>~450ms</code>.</p>

<p>If you try to use HInclude, just create a new page:</p>

<p>``` html index_hinclude.php
<html xmlns:hx="http://purl.org/NET/hinclude"></p>

<pre><code>&lt;head&gt;
  &lt;script src="src/hinclude.js"
   type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;
    &lt;hx:include src="header.php"&gt;&lt;/hx:include&gt;
  &lt;/p&gt;
  &lt;div class="main"&gt;
    &lt;!-- start slipsum code --&gt;

    Look, just because I don't be givin' no man a foot massage don't make it right for Marsellus to throw Antwone into a glass motherfuckin' house, fuckin' up the way the nigger talks. Motherfucker do that shit to me, he better paralyze my ass, 'cause I'll kill the motherfucker, know what I'm sayin'?

    &lt;!-- please do not remove this line --&gt;

    &lt;div style="display:none;"&gt;
    &lt;a href="http://slipsum.com"&gt;lorem ipsum&lt;/a&gt;&lt;/div&gt;

    &lt;!-- end slipsum code --&gt;
  &lt;/div&gt;
  &lt;p&gt;
    &lt;hx:include src="footer.php"&gt;&lt;/hx:include&gt;
  &lt;/p&gt;
&lt;/body&gt;
</code></pre>

<p></html>
<code>``
and add, in</code>header.php<code>and</code>footer.php`, a caching header,
which HInclude will made the browser take advantage of:</p>

<p><code>php At the top of header.php and footer.php
&lt;?php header('Cache-Control: max-age=3600'); ?&gt;
</code></p>

<p>For the first user requests it will require <code>~220ms</code> to render
the whole page: this is a pretty good starting gain, as we are
<strong>requesting header and footer in parallel</strong>, but as you retrieve
the page for the second time, performances will incredibly
improve, down to <code>~40/50ms</code>: it&rsquo;s, basically, a <strong>90% performance
gain</strong>, but you should be aware that the biggest load time should
be spent within the main body of the page, that I just ignored in
this example; but gaining almost a half second for each pageview
is just a great goal achieved.</p>

<p>As pointed out by other people on twitter, HInclude has a few
drawbacks &ndash; think about
<a href="https://twitter.com/#!/lyrixx/status/172849248868646912">SEO</a> &ndash;
but you should be able to use it with contents that rarely need
to play a major role in your SEO strategy (eg. never use HInclude
to retrieve the body of a blog post<sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup>).</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>You should know him for his contributions to the HTTP specification, httpbis, cache channels and &ndash; in general &ndash; the HTTP cache <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>Recently Matt Cutts came out with the assertion that Googlebot is capable to understand basic JS redirects, so&hellip; there&rsquo;s hope <a href='#fnref:2' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Application-level caching: fight the right battle ]]></title>
    <link href="http://odino.github.io/application-level-caching-fight-the-right-battle/"/>
    <updated>2011-11-22T15:01:00+04:00</updated>
    <id>http://odino.github.io/application-level-caching-fight-the-right-battle</id>
    <content type="html"><![CDATA[<p>I always receive a funny question, that I want to answer right here, right now, with the usual reply I give to people asking it to me:</p>

<blockquote><p>Why do you hate application-level caches?</p></blockquote>

<p>First of all, I don&rsquo;t.</p>

<p>And here&rsquo;s explained why I don&rsquo;t hate AL caches and why I do really hate how developers integrate caching in their applications.</p>

<!-- more -->


<h2>What should we cache</h2>

<p>There are a few aspects of our architecture/application that usually need caching-capabilities to improve performances, and I will analyze each one of them in order to understand whether they fit well in an application cache or not.</p>

<p>To summarize them, here&rsquo;s a brief list:</p>

<ul>
<li>finding file on the filesystem</li>
<li>metadata</li>
<li>routing</li>
<li>configuration</li>
<li>non-native data providers</li>
<li>output fragments</li>
</ul>


<h2>Finding files</h2>

<p>An AL cache is really good for finding files on the filesystem: autoloaders are pretty smart ( for example, in PHP, we have the <a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md">PSR-0</a> standard ) so they basically know a set of conventions and calculate the path to a required file: well, the process of calculating that path is really unnecessary when going live on production, because the core of our application is rarely meant to be moved/changed.</p>

<p>``` php autoloading.php
&lt;?php</p>

<p>array(
  &lsquo;Symfony\Component\Finder\Finder&rsquo; => <strong>DIR</strong> .&lsquo;/src/Symfony/Component/Finder/Finder.php&rsquo;,
  &hellip;
  &hellip;
);
```</p>

<p>Flushing the autoloading cache at every deploy is the solution for those rare scenarios.</p>

<h2>Reading metadata</h2>

<p>When you need to specify metadata on objects, a good solution is recurring to annotations:</p>

<p>``` php
&lt;?php</p>

<p>class Dog
{
  /<em>*
   *  @validation(int)
   </em>/
  protected $age;
}
```</p>

<p>but reading that data can be expensive, since you always need to parse and introspect an entity.</p>

<p>Doctrine2, the infamous PHP ORM, uses <a href="https://github.com/doctrine/common/tree/master/lib/Doctrine/Common/Cache">caching</a> exactly to solve the issue of always reading metadata from objects.</p>

<h2>Routing</h2>

<p>We usually compile YML/XML files for routing ( &lsquo;cause they are way easier to read/write ), which means that at every request we parse the URI, parse the routing file and find a match between them.</p>

<p>Reading the routing can be annoying, so we can easily compile down a PHP file with routing rules from the original routing file.</p>

<h2>Can I haz natives?</h2>

<p>As you might understand, a good solution is to cache when we need to face formats which are different from our language: so, for example, from configuration files we can compile &ndash; in PHP &ndash; arrays, or stuff like that.</p>

<p>Symfony2, for example, add the ability of <a href="http://www.slideshare.net/fabpot/dependency-injection-in-php-5354/100">compiling down the whole dependency injection container</a> from different formats to plain PHP.</p>

<h2>Bad smells, here they come</h2>

<p>So you may wonder why I hate application caches, and <strong>here it comes the tornado</strong>.</p>

<p>We are basically used to think that <strong>caching the output</strong> is just good, and we have those CMSes like Joomla! or Drupal doing that.</p>

<p>Think about how many things you are loosing re-implementing an output caching layer inside your application: your application needs to do the storage of cached files, it needs to calculate dates and evaluate if an HTML fragment have expired or not, it needs to be hit for 2 identical requests and then, the most disturbing thing, you need to add a layer on top of your application.</p>

<p>Adding new layers is bad, because as you add them, you potentially introduce bugs, coupling and limitations to your software: <strong>the more code you write, the more bugs happen</strong>.</p>

<p>Output caching should be done with the HTTP cache, which works at the protocol level: you don&rsquo;t have to add any layer to your application ( you only need a good framework ), and whether to cache or not a resource is demanded to the client&rsquo;s browser or to the reverse proxy.</p>

<p>In the HTTP cache, you can serve the same response to 1 milion clients just with a stupid reverse proxy; you can serve the same response after identical requests, to a single client, without even making the subsequent requests traverse the internet.</p>

<p>Custom output caches are not capable of doing 1% of what the HTTP cache has proven to be able to do.</p>

<p>Application-level output caches are an antipattern, get over it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some common questions about Edge Side Includes]]></title>
    <link href="http://odino.github.io/some-common-questions-about-edge-side-includes/"/>
    <updated>2011-05-30T15:07:00+04:00</updated>
    <id>http://odino.github.io/some-common-questions-about-edge-side-includes</id>
    <content type="html"><![CDATA[<p>After my <a href="http://www.slideshare.net/odino/rest-in-a-mobile-peace-whymca-05212011">REST in (a mobile) peace</a> talk at the WHYMCA in Milan, 2 weeks ago, I was surrounded by a few developers trying better understand how does Edge Side Includes behave: after I realized that some concepts are not so &ldquo;standard&rdquo;, here&rsquo;s a parade of little things to know about <a href="http://en.wikipedia.org/wiki/Edge_Side_Includes">ESI</a>.</p>

<!-- more -->


<h2>Is it a single-construct language?</h2>

<p>No: although the most used tag is the include one:</p>

<p><code>xml Typical ESI tag
&lt;esi:include src="http://www.example.net" /&gt;
</code></p>

<p>the ESI specification has a <a href="http://www.w3.org/TR/esi-lang">plethora of commands</a>, while the Oracle website has a specific section on more <a href="http://download.oracle.com/docs/cd/B15897_01/caching.1012/b14046/esi.htm">detailed insights</a>.</p>

<h2>If I install Varnish and use ESI, do I need to do something specific?</h2>

<p>No: after you set up Varnish in order to do <a href="http://www.varnish-cache.org/trac/wiki/ESIfeatures">ESI processing</a>, everything will magically happen :)</p>

<h2>Do I need, in my architecture, an ESI processor?</h2>

<p>Yes, otherwise the ESI tags won&rsquo;t be replaced.</p>

<p>Luckily, Varnish and Squid do it for free since years: the RAD framework for PHP Symfony2 implements a <a href="http://www.odino.org/343/symfony2-http-cache-the-good-parts-of-both-of-em">custom-made reverse proxy</a> and something is moving also in the <a href="https://github.com/ramsingla/rack-rsi">Ruby ecosystem</a>.</p>

<h2>Does it work with modern browsers?</h2>

<p>No: since ESI never got hype browser vendors never thought about implementing the specification.</p>

<p>The topic is also subject of <a href="/339/esi-upside-down-will-the-client-be-happier">various arguments</a>.</p>

<h2>Does ESI invalidate my output format?</h2>

<p>No: since ESI processors ( like Varnish ) work on the server side, before sending the response to the clients esi tags get replaced with the actual content.</p>

<h2>Does it work with HTML?</h2>

<p>Well, the specification works regardless the format of your response: it can be application/xml, json, html, a custom media type&hellip;</p>

<h2>How do I avoid my middleware to look for ESI tags in every response?</h2>

<p>Parsing responses, in order to look for ESI tags, is expensive, we all know.</p>

<p>In order to let your ESI processor ignore responses not containing ESI tags you can specify a declination of your content type:</p>

<p><code>bash HTTP response with profile parameter in the media type
HTTP/1.1 200 OK
Content-Type: application/xhtml+xml;profile=esi
</code></p>

<p>and make your processor checking this <code>profile</code> attribute.</p>

<p>Unfortunately, it seems that only the <code>application/xhtml+xml</code> <a href="http://www.ietf.org/rfc/rfc3236.txt">supports the <code>profile</code> attribute</a>, but you can &ldquo;hack&rdquo; the media type of your needs and make it support it, since you are working on the server side, without sending non-standardized media type descriptions over the internet.</p>

<h2>How does my application know if it can send ESI tags or not?</h2>

<p>There are 2 common scenarios:</p>

<ul>
<li>when a middleware supports the ESI specification, and your application can send a response with ESI tags</li>
<li>when you have no ESI processors in your architecture, and your application should assemble a single whole response</li>
</ul>


<p>In order to take this decision a custom HTTP header is used: <code>Surrogate-Capability</code>, which has been introduced in the <a href="http://www.w3.org/TR/edge-arch">edge side architectures</a> specification.</p>

<h2>Is ESI a new technology?</h2>

<p>10 years old, baby :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[REST better: HTTP cache]]></title>
    <link href="http://odino.github.io/rest-better-http-cache/"/>
    <updated>2011-03-17T14:12:00+04:00</updated>
    <id>http://odino.github.io/rest-better-http-cache</id>
    <content type="html"><![CDATA[<p>HTTP has a widely-ignored <a href="http://tools.ietf.org/html/rfc2616#section-13">cache specification</a> which helps us implementing fast, scaleable and fault-tolerant services.</p>

<!-- more -->


<p>What does this have in common with REST?</p>

<p>Is that only because HTTP is a <strong>REST-loving protocol</strong>?</p>

<p>No.</p>

<p>Cache is the third constraint of the REST architectural style, and there&rsquo;s a reason behind it:</p>

<p><blockquote><p>The advantage of adding cache constraints is that they have the potential to partially or completely eliminate some interactions, improving efficiency, scalability, and user-perceived performance by reducing the average latency of a series of interactions.</p><footer><strong>Roy Fielding <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_4">http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_4</a> Network cache</strong></footer></blockquote></p>

<h2>Why caching?</h2>

<p>If you aren&rsquo;t convinced by Fielding&rsquo;s words, here are other explanations:</p>

<ul>
<li><strong>improve speed</strong>, because we want to deliver fast content to our consumer</li>
<li><strong>fault tolerance</strong>, because we want our service to deliver content also when it encounters internal failures</li>
<li><strong>scalability</strong>, because the WWW scales to bilions of consumers through hypermedia documents and we just want to do the same thing</li>
<li><strong>reduce server load</strong>, because we don&rsquo;t want our servers to compute without the need of it</li>
</ul>


<h2>Types of cache</h2>

<p>There are a few types of caches, but not all of them fit well in a qualitative architecture:</p>

<h3>Local cache</h3>

<p><img class="right" src="/images/browser-cache.png"></p>

<p>It&rsquo;s a cache a single consumer implements.</p>

<p>When you surf an http-cache-loving service with the browser cache activated, you should be able to experience significant speed improvements when requesting the same page more than once: that&rsquo;s because your browser, according to the response&rsquo;s caching headers, has a local copy of the response on your machine, and when you request the page the second time it uses that local copy instead of making a real request over the network.</p>

<p>Needless to say, improvements on local caches can be obtained by using an <em>in-memory</em> caching strategy rather that a disk-persisting one.</p>

<h2>Proxy cache</h2>

<p>You may confuse proxy cache with gateway one: I&rsquo;m gonna talk about the latter in a few lines.</p>

<p>Proxy caches are shared caches that, for instance, your company can install in front of your firewall in order to store many resources, from many origin servers, on behalf of every agent in your company.</p>

<p>The difference between local and proxy cache is that the former can&rsquo;t serve more than one agent, so 2 identical requests from 2 consumers behind the same network effectively hit the origin server twice: again, needless to say, proxy caches serve cached responses slower than local ones.</p>

<h3>Application cache</h3>

<p><img class="right" src="/images/symfony-cache.png"></p>

<p>Oh, WTF.</p>

<p>This kind of caches are evil: we spent the last 15 years of web development on developing frameworks with their own super-cocky caching layer.</p>

<p>Although they might help reducing the web&rsquo;s inconsistency, they&rsquo;re <strong>a needless way to waste effort</strong>: the HTTP specification and the software implementing it ( some web frameworks, reverse proxies and browsers ) are the standard tools we should use in order to deliver cached content.</p>

<p>If we aren&rsquo;t satisfied by this tools, we can think about implementing a caching layer over our software, but <strong>only in this case</strong>.</p>

<p>You are probably wondering why I hate application caches, and the answer it&rsquo;s easy: you don&rsquo;t need to mantain a browser, nor a proxy, nor a reverse one; that means that without LoCs you have an efficient caching layer upon your architecture, for free. Thanks, HTTP.</p>

<p>Another reason I hate application cache is because it couples a peculiarity of your architecture ( being cacheable ) with the application at the base of it: that means that changing the implementation will change your architecture capabilities.</p>

<p>Are you OK with that? Well, I&rsquo;m not: <strong>loose over strong coupling</strong>, one of our primary goals.</p>

<h3>Gateway cache</h3>

<p><img class="right" src="/images/proxy-cache.jpg"></p>

<p>A gateway cache is a cache served by a proxy installed on the server side, called <em>reverse proxy</em>.</p>

<p>It&rsquo;s different from the proxy cache, in which the proxy stands into the client side: the advantage of implementing a gateway cache is that you can share the cache generated by a client with any other client of the planet doing the same request.</p>

<h2>A few words on WWW&rsquo;s inconsistency</h2>

<p>Cache introduces <strong>inconsistency</strong>, which is the situation that occurs when a resource served to a consumer is different from the one actually held by the server.</p>

<p>Crap, you say, and that&rsquo;s true, but is also the reason behind a system serving bilions of users with an unimaginable amount of data, <strong>the WWW</strong>.</p>

<p>You must be ok with this assumption: if you need consistency we will see later how to couple <strong>caching with high consistency</strong> ( keep in mind the word <a href="http://www.w3.org/TR/esi-lang">ESI</a> ).</p>

<h2>Caching headers</h2>

<p>There are a few HTTP headers you can use to specify caching rules for your resources: here&rsquo;s a recap about them.</p>

<h3>Expires</h3>

<p>Used in HTTP responses, the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21"><code>Expires</code>  header</a> tells the client when the resource is going to expire.</p>

<p>Usually, this headers has a date value that specifies from when the resource will be considered <em>stale</em> ( possibly out-of-date ), and so it needs to be revalidated.</p>

<p>In order to avoid caching of the response, this header can contain other values, like:</p>

<p><code>
Expires:  0
</code></p>

<p>or a date that equals the one in the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.18"><code>Date</code> header</a>.</p>

<p>When you want to mark the resource cacheable for long times, you can specify a date up to one year in the future.</p>

<p>The &ldquo;<em>one year</em>&rdquo; time is a constraint, as the HTTP spec says:</p>

<p><blockquote><p>To mark a response as &ldquo;never expires,&rdquo; an origin server sends an Expires date approximately one year from the time the response is sent.<br/>HTTP/1.1 servers SHOULD NOT send Expires dates more than one year in the future.</p></blockquote></p>

<h3>Cache-Control</h3>

<p>CC is a powerful header to manage your caching directives and strategies: is a way of combining different directives about the response&rsquo;s cache.</p>

<p>The cool thing about CC is that <strong>it can be also used in requests</strong>, so, for example, if your consumer wants to be sure that the data he is receiving are consistent, he can specify an header like the following:</p>

<p><code>
Cache-Control:  no-cache
</code></p>

<p>which basically tells all the caching layers to revalidate the response with the origin server.</p>

<h3>Etag</h3>

<p>The etag is a unique identifier for your response: it is used on <a href="http://www.odino.org/292/don-t-rape-http-if-none-match-the-412-http-status-code">conditional requests</a>, usually when a clients GETs a resource he also has in cache, sending to the origin server this identifier ( in the <code>If-None-Match</code> header in this case ).</p>

<h3>Last-Modified</h3>

<p>If <code>Date</code> is the header which tells when the resource has been firstly generated, <code>Last-Modified</code> tells us when it has been&hellip;   ..well, you guessed it.</p>

<h2>More about the Cache-Control</h2>

<p>As I said, the CC header combines different directives for specifying a caching strategy, that I briefly explain now.</p>

<p>If you want to specify how long should the response considered valid you use the <code>max-age</code> directive, available for local caches.</p>

<p>The corrisponding for shared caches ( proxies ) is <code>s-maxage</code>: the value of both is expressed in seconds.</p>

<p>If you want to make the response cacheable by both local and shared caches you declare it as <code>public</code>, while if you don&rsquo;t want to make it cacheable by proxies you should declare it <code>private</code>.</p>

<p>Yes, <strong>private doesn&rsquo;t mean not cacheable</strong>: that is achieved by using the <code>no-store</code> directive.</p>

<p>A weird story short, I tend to avoid the no-cache instruction because it&rsquo;s interpreted in different ways by different caches.</p>

<p>If you want to always revalidate your cached copy you should use <code>must-revalidate</code> for local caches, <code>proxy-revalidate</code> for proxy caches: that&rsquo;s useful when you have frequently updates on a resource and its etag is cheap to generate, so you spend some computation for comparing the etag with the <code>If-None-Match</code> header and telling the client the response has, or hasn&rsquo;t, been modified.</p>

<p>A smart instruction, for requests, is the <code>only-if-cached</code> one, when, usually, you deal with slow connectivity:</p>

<p><blockquote><p>In some cases, such as times of extremely poor network connectivity, a client may want a cache to return only those responses that it currently has stored, and not to reload or revalidate with the origin server.<br/>To do this, the client may include the only-if-cached directive in a request. If it receives this directive, a cache SHOULD either respond using a cached entry that is consistent with the other constraints of the request, or respond with a 504 (Gateway Timeout) status.<br/>However, if a group of caches is being operated as a unified system with good internal connectivity, such a request MAY be forwarded within that group of caches.</p><footer><strong>HTTP specification <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.4">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.4</a> Cache Revalidation and Reload Controls</strong></footer></blockquote></p>

<p><code>stale-while-revalidate</code> has a value, expressed in seconds, which tells that the cache should release a stale response ( out-of-date ) if the request has come during the specified ( as I said, in seconds ) interval, while <code>stale-if-error</code> has an identical behaviour but it deals with errors contanting the origin server: this directives spread <strong>availability over consistency</strong>.</p>

<p>Theory is always annoying, so let&rsquo;s see them in practice.</p>

<p><code>
Cache-Control: public, max-age=600, s-maxage=3600
</code></p>

<p>A response with the above CC means that the response:</p>

<ul>
<li>is cacheable by local and shared caches</li>
<li>is cacheable for 10 minutes for local caches</li>
<li>is cacheable for 1 hour for shared caches</li>
</ul>


<p>while</p>

<p><code>
Cache-Control: no-store
</code></p>

<p>tells that the response is <strong>not cacheable at all</strong>.</p>

<p>Talking about availability over consistency, the following</p>

<p><code>
Cache-Control: stale-while-revalidate=60, stale-if-error=7200, public
</code></p>

<p>is really interesting; it basically says that the response:</p>

<ul>
<li>is cacheable by local and shared caches</li>
<li>if it has expired in less that a minute, the cached copy can be released while persisting the original request to the origin server</li>
<li>if the request encounters an error and the cached copy has expired in less than 2 hours, the cached copy can be released to the client</li>
</ul>


<h2>Caching strategies</h2>

<p><blockquote><p>There are only two hard things in Computer Science: cache invalidation and naming things.<br/>dealing with cache consistency should be pretty hard.</p><footer><strong>Phil Karlton <a href="http://martinfowler.com/bliki/TwoHardThings.html">http://martinfowler.com/bliki/TwoHardThings.html</a> Two hard things</strong></footer></blockquote></p>

<p>You have to 2 ways to improve data&rsquo;s consistency: cache validation and expiration: only if you implement a mix between validation ( which basically asks you to specify the <code>Etag</code> and <code>Last-Modified</code> headers ) and expiration ( with the <code>Expires</code> header or some <code>Cache-Control</code> directives ) you&rsquo;re going to increase consistency between cached content and actual data.</p>

<h2>Edge Side Includes</h2>

<p>ESI, or <em>edge side includes</em>, is a specification introduced by Akamai and Oracle in 2001, which tries to solve the problem of composite webpages.</p>

<p>What is a composite? It is a resource which is composed by the aggregation of N resources, through server side includes ( not SSI ).</p>

<p>The typical ESI tag looks like the following one:</p>

<p><code>xml
&lt;esi:include src="http://www.acme.com/odino" /&gt;
</code></p>

<p>and basically tells a proxy that, before releasing a response it should make an HTTP request to the specified <code>src</code> and substitute the esi tag with the response.</p>

<p>ESI helps you having a working and effective gateway cache, because it lets you share a cached resource not only between different clients, but also between different requests.</p>

<p>Granularity FTW.</p>

<p>Another advatage, <strong>ESI improves response&rsquo;s consistency</strong>, because it lets you specify caching strategies for single resources that compose another one that you may declare not cacheable: the requested resource isn&rsquo;t cacheable, but some of the data it contains can be retrieved from the cache.</p>

<p>Needless to say, proxies understanding ESI tags are always put in front of our architecture, <strong>on the server side</strong>.</p>

<h2>Pushing ESI to the next level</h2>

<p>The next step in improving the web cache is to move ESI capable proxies to the clients' side: that would mean that a browser cache or a proxy cache would be able to receive responses with ESI tags and process it.</p>

<p>This would <strong>dramatically improve consistency and performances</strong>, because we would push cached copies more near to the client, but specifying different TTL ( time to live ) for the response fragments.</p>

<p>There&rsquo;s only a minor problem: actually, proxy and local caches don&rsquo;t understand very well ESI tags; for instance, any browser isn&rsquo;t able to process an ESI tag.</p>

<p>But the biggest problem is that <strong>there&rsquo;s no standard media type which embeds ESI tags in the response</strong>, so we would basically send our response, embedding ESI tags, with a custom and widely-unknown media format.</p>

<p>At the <a href="http://www.symfony-live.com/">Symfony Live</a> conference I talked with Symfony creator, <a href="http://fabien.potencier.org/">Fabien Potencier</a>, on the possibility of writing a media format for web responses which need to embed ESI tags: my goal is to start to define a standard for this kind of technology.</p>

<p><strong>Missing a standardized format is evil</strong>: you are basically ignoring the <a href="http://linkednotbound.net/2010/07/19/self-descriptive-hypermedia/">self descriptiveness</a> constraint of REST, making your architecture hard to consume, discover and mantain. And since self descriptiveness is one of the main actors behind REST&rsquo;s WSDL ( yes, <strong>REST has WSDL</strong>, composed by self-descriptiveness, hypermedia formats, media types and DAP<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup> ), you&rsquo;re missing a huge part of the service.</p>

<h2>People started to like HTTP cache</h2>

<p><blockquote><p>[The goal is to] never generate the same response twice.</p><footer><strong>Ryan Tomayko <a href="http://tomayko.com/writings/rack-cache-announce">http://tomayko.com/writings/rack-cache-announce</a> Introducing Rack cache</strong></footer></blockquote></p>

<p>People, get over application cache and re-inventing the wheel: popular tools like Ruby&rsquo;s Rack ( well, that&rsquo;s because of the great mind of <a href="http://tomayko.com/writings/rack-cache-announce">Ryan Tomayko</a> ) and PHP&rsquo;s <a href="http://symfony.com/doc/2.0/book/http_cache.html">Symfony2</a> RAD framework are abandoning application caches in favour of the HTTP caching mechanism.</p>

<h2>Resources</h2>

<p>You should really read Subbu Allamaraju&rsquo;s articles about <a href="http://www.subbu.org/blog/2005/01/http-caching">HTTP caching</a>.</p>

<p><a href="http://oreilly.com/catalog/9780596805838">REST in practice</a> has a cool chapter dealing with <strong>scaling through HTTP caching</strong>.</p>

<p>And remember:</p>

<p><blockquote><p>Make a reasonable guess. Whenever caching is involved, there is a possibility that the content that the end user is receiving is stale. Is this acceptable or not? It depends.</p><footer><strong>Subbu Allamaraju <a href="http://www.subbu.org/blog/2005/01/more-on-http-caching">http://www.subbu.org/blog/2005/01/more-on-http-caching</a> More on HTTP caching</strong></footer></blockquote></p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>Domain Application Protocols <a href='#fnref:1' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Don't rape HTTP: If-(None-)Match & the 412 HTTP status code]]></title>
    <link href="http://odino.github.io/don-t-rape-http-if-none-match-the-412-http-status-code/"/>
    <updated>2011-03-06T00:08:00+04:00</updated>
    <id>http://odino.github.io/don-t-rape-http-if-none-match-the-412-http-status-code</id>
    <content type="html"><![CDATA[<p>HTTP has a problem: it gets raped everyday.</p>

<p>Seriously, <strong>every single day</strong>.</p>

<!-- more -->


<p>That&rsquo;s because we don&rsquo;t leverage the power of our architectures using the simple tools and mechanisms that HTTP gave us <strong>since the late 80s</strong>.</p>

<h2>A bit about the Etag</h2>

<p>The <code>Etag</code> header is, generally, a string that represents our resource in the HTTP headers.</p>

<p>It&rsquo;s, banally, a code which identifies our resource, eventually used to check if the resource the client has ( in cache or wherever ) corresponds to the server&rsquo;s one.</p>

<p>Roughly speaking, if I request the resource <code>Alessandro Nadalin</code> to a website now and in 2012, the response <code>Etag</code> will surely be different, at least because of the age of Alessandro.</p>

<h2>If-Match</h2>

<p><code>If-Match</code> it&rsquo;s a <strong>preconditional HTTP header</strong>.</p>

<p>That means that the server should verify a precondition before completing the request&rsquo;s processing mechanism and giving a response.</p>

<p>In this case, when you send an <code>If-Match</code> header, usually containing the <code>Etag</code> of the resource representation you want to manipulate, the server compares the one you sent with the one of the current resource: if they match, the whole request can be processed.</p>

<p>Consider this request (with a YAML body):</p>

<p>```
PUT /people/alessandro-nadalin HTTP/1.1
If-Match: yuf8ew98ehf9h9h
Host: italianpeople.com</p>

<p>person:
  name:     Alessandro
  surname: Nadalin
  company: DNSEE
```</p>

<p>If the <code>Etag</code> of the resource <code>/people/alessandro-nadalin</code> is the same of the server&rsquo;s one, the PUT updates the user.</p>

<p>But if they don&rsquo;t match, the server responds with a <code>412 Precondition Failed</code> status code, which means that the resource is out of date.</p>

<p>Like SVN, for God&rsquo;s sake!</p>

<h2>If-None-Match, here comes the cache</h2>

<p><code>If-None-Match</code> acts in the reverse way: it&rsquo;s still a preconditional header, but it tells the server to process a whole response only if the <code>Etag</code> ( again, contained in the <code>If-None-Match</code> header ) is different from the one sent by the client.</p>

<p>Why this?</p>

<p>Because it let&rsquo;s you save bandwidth and CPU: you don&rsquo;t always have to generate a whole response if the <code>Etag</code> matches, but how?</p>

<p>Let&rsquo;s see a request similar to the one above:</p>

<p><code>
GET /people/alessandro-nadalin HTTP/1.1
If-None-Match: yuf8ew98ehf9h9h
Host: italianpeople.com
</code></p>

<p>If the <code>Etag</code> don&rsquo;t match, the server should recalculate the whole response and send it again to the client, but when they match it should only send back a <code>304 Not Modified</code> status code.</p>

<p>The <code>304</code> status code tells the client to use the resource it has in cache, because it hasn&rsquo;t changed.</p>
]]></content>
  </entry>
  
</feed>
