<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: testing | Alessandro Nadalin]]></title>
  <link href="http://odino.org/blog/categories/testing/atom.xml" rel="self"/>
  <link href="http://odino.org/"/>
  <updated>2013-09-21T16:55:44+04:00</updated>
  <id>http://odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AB testing in PHP with namshi/ab]]></title>
    <link href="http://odino.org/ab-testing-in-php-with-namshi-slash-ab/"/>
    <updated>2013-07-13T14:27:00+04:00</updated>
    <id>http://odino.org/ab-testing-in-php-with-namshi-slash-ab</id>
    <content type="html"><![CDATA[<p>AB testing is a powerful tecnique that
lets you gather metrics about different
versions of a feature: it basically
consist into displaying a number of
different variations of it to your
users and tracking the results to see
which variation performed better.</p>

<p><img class="right" src="/images/ab-testing.jpg"></p>

<p>An example? In an e-commerce system,
you usually have an &ldquo;Add to cart&rdquo; button:
have you ever though about the impact that
single sentence has on your customers?
What would sound better, between &ldquo;Add to cart&rdquo;
and &ldquo;Buy now&rdquo;, for example? Copywriters
away, you want <strong>data</strong> to tell you that!</p>

<p>This is why AB testing is important:
you serve different versions of something,
and track the results to improve the
experience users have while using your
application: for example, Google benchmarked
<a href="http://gigaom.com/2009/07/09/when-it-comes-to-links-color-matters/">40 different shades of blue</a>
to find out how the rate of clickthrough
would be altered.</p>

<p>At <a href="http://en-ae.namshi.com">Namshi</a> we
decided to ease AB testing by creating a
very simple library that would let you generate
and manage tests in a very easy and practical
way: that&rsquo;s how <a href="https://github.com/namshi/ab">Namshi/AB</a>
was born.</p>

<!--   more -->


<h2>Installation</h2>

<p>You can install the library via composer,
as it&rsquo;s available on <a href="https://packagist.org/packages/namshi/ab">packagist</a>.</p>

<p>Then include it, specifying a major and
minor version, in your <code>composer.json</code>:</p>

<p><code>
"namshi/ab": "1.0.*"
</code></p>

<h2>Creating and running tests</h2>

<p>The library is very small, and it comes bundled with
2 classes, <code>Test</code> and <code>Container</code>: as you can probably
guess, the first is a representation of an AB test and
the 2nd serves as a convenient container for all of your
test instances.</p>

<p>Here&rsquo;s how you can create a test:</p>

<p>``` php
&lt;?php</p>

<p>use Namshi\AB\Test;
use Namshi\AB\Container;</p>

<p>$cssTest = new Test(&lsquo;css&rsquo;, array(</p>

<pre><code>'default.css'   =&gt; 2,
'new.css'       =&gt; 1,
</code></pre>

<p>));</p>

<p>$abContainer = new Container(array(</p>

<pre><code>$cssTest
</code></pre>

<p>));
```</p>

<p>At this point, for example, you can start
AB testing your website by changing the CSS
in the view:</p>

<p>``` php
<html></p>

<pre><code>&lt;head&gt;
    &lt;link rel="stylesheet" type="text/css" href="&lt;?php echo $abContainer['css']-&gt;getVariation(); ?&gt;"  /&gt;
    ...
    ...
</code></pre>

<p>```</p>

<p><code>getVariation()</code> will calculate the variation
(<code>default.css</code> or <code>new.css</code>) according to the
odds of each variation (66% for the first one,
33% for the second one) and will return a string
representing the variation.</p>

<h2>Persisting the variations through an entire session</h2>

<p>Of course, you want to display variations but be
consistent with each user, so that if a user gets
a variation, it will continue getting the same variation
throughout his entire session: to do so, just calculate
a random integer (seed), store it in session and pass it to
each test:</p>

<p>``` php
&lt;?php</p>

<p>session_start();</p>

<p>if (!isset($_SESSION[&lsquo;seed_for_example_test&rsquo;])) {</p>

<pre><code>$_SESSION['seed_for_example_test'] = mt_rand();
</code></pre>

<p>}</p>

<p>$test = new Test(&lsquo;example&rsquo;, array(</p>

<pre><code>'a' =&gt; 1,
'b' =&gt; 1,
</code></pre>

<p>));</p>

<p>$test->setSeed($_SESSION[&lsquo;seed_for_example_test&rsquo;]);</p>

<p>// as long as the seed doesn&rsquo;t change
// getVariation() will always return the
// same variation
$test->getVariation();
```</p>

<p>Soon, you will realize that having a per-test seed
is <strong>not efficient at all</strong>, that&rsquo;s why you can create
a global seed and pass it to the container: from that
seed, the container will take care of generating a seed
for each test:</p>

<p>``` php
&lt;?php</p>

<p>session_start();</p>

<p>if (!isset($_SESSION[&lsquo;seed&rsquo;])) {</p>

<pre><code>$_SESSION['seed'] = mt_rand();
</code></pre>

<p>}</p>

<p>// pass the seed into the constructor
$abContainer = new Container(array(</p>

<pre><code>new Test('greet', array(
    'Hey dude!' =&gt; 1,
    'Welcome'   =&gt; 1,
)),
new Test('background-color', array(
    'yellow'    =&gt; 1,
    'white'     =&gt; 1,
)),
</code></pre>

<p>), $_SESSION[&lsquo;seed&rsquo;]);</p>

<p>// or with a setter
$abContainer->setSeed($_SESSION[&lsquo;seed&rsquo;]);
```</p>

<h2>Disabling the tests</h2>

<p>Sometimes you might want to disable tests
for different purposes, for example if
the user agent who is visiting the page is a bot:</p>

<p>``` php
&lt;?php</p>

<p>$test = new Test(&lsquo;my_ab_test&rsquo;, array(</p>

<pre><code>'a' =&gt; 0,
'b' =&gt; 1,
</code></pre>

<p>));</p>

<p>$test->disable();</p>

<p>$test->getVariation(); // will return &lsquo;a&rsquo;!
```</p>

<p>Once you disable the test and run it,
it will always return the first variation,
no matter what its odds are, even if it&rsquo;s zero.</p>

<h2>An example</h2>

<p>I would recommend you to have a look at the
<a href="https://github.com/namshi/AB/tree/master/examples">example provided</a> under the <code>examples</code> directory:
it&rsquo;s pretty silly, but it gives you an idea of
how easy is to create and run AB tests with
this library.</p>

<p><img class="center" src="/images/ab.png"></p>

<p>If you look at the code, you will soon realize that
it&rsquo;s very simple:</p>

<p>``` php
&lt;?php</p>

<p>require <strong>DIR</strong> . &lsquo;/../vendor/autoload.php&rsquo;;</p>

<p>use Namshi\AB\Test;
use Namshi\AB\Container;</p>

<p>session_start();</p>

<p>if (!isset($_SESSION[&lsquo;seed&rsquo;])) {</p>

<pre><code>$_SESSION['seed'] = mt_rand();
</code></pre>

<p>}</p>

<p>$abt = new Container(array(</p>

<pre><code>new Test('greet', array(
    'Hey dude!' =&gt; 1,
    'Welcome'   =&gt; 1,
)),
new Test('background-color', array(
    'yellow'    =&gt; 1,
    'white'     =&gt; 1,
)),
</code></pre>

<p>), $_SESSION[&lsquo;seed&rsquo;]);</p>

<p>?></p>

<p><html></p>

<pre><code>&lt;head&gt;
    &lt;style&gt;
        * {
            background-color: &lt;?php echo $abt['background-color']-&gt;getVariation(); ?&gt;;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;
        &lt;?php echo $abt['greet']-&gt;getVariation(); ?&gt;
    &lt;/h1&gt;

    &lt;div&gt;
        Your seed is &lt;?php echo $_SESSION['seed']; ?&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<p>Of course, never write an application like this ;&ndash;)
this serves just as an example.</p>

<h2>Additional features</h2>

<p>We tried to extensively cover the available features of
the library in its <a href="https://github.com/namshi/ab">README</a>,
so I will just sum them up here:</p>

<ul>
<li>the container implements the <code>ArrayAccess</code> interface, so you can
retrieve tests like if they were stored into an array (<code>$abContainer['my_test']</code>)</li>
<li>since AB tests are very useful only when you <strong>track</strong>
the results, we added a <strong>tracking name</strong> that you can specify
for each test: this is due to the fact that your test might be
called <code>add_to_cart_text</code> but in your tracking tool, you
have to reference the test with the tracking tool&rsquo;s ID, which
might be a very clueless string (ie. <code>test_id_4njktn4t4tjjnn4on</code>)</li>
<li>you can also add an array of parameters to each test and retrieve
them later on: this is due to the fact that once you track the test&rsquo;s
result, you might want to send additional data together with the
tracking name, the variation and the result</li>
</ul>


<h2>Why not choosing an existing library</h2>

<p>Of course we checked out what the market was
offering, but weren&rsquo;t able to find out a very
good, generic-purpose, library in order to
generate AB tests:</p>

<ul>
<li><a href="https://packagist.org/packages/jm/ab-bundle">jm/ab-bundle</a>
is unfortunately coupled with Symfony2 and Twig, so
you can&rsquo;t really call it a stack-free library: even though
we <strong>love</strong> Symfony2, not all of our services run with
it and we don&rsquo;t want to <strong>force a technology just to
have a functionality</strong></li>
<li><a href="http://phpabtest.com/index">phpabtest</a> is a full-stack
service, meaning that it provides a library to register and
handle tests but also tracks stuff via Google Analytics; moreover,
<a href="https://github.com/briancray/phpA-B/blob/master/phpab.php">we didn&rsquo;t like the code that much</a></li>
</ul>


<p>At the end of the day, <code>namshi/ab</code> is a <strong>1 man-day effort</strong>, so we
spiked for a bit and decided that it was worth it.</p>

<h2>Testing this library</h2>

<p>We added a few PHPUnit tests, so you just have to:</p>

<p>```
cd /path/to/namshi/ab</p>

<p>phpunit
```</p>

<p>The funny thing is that we also added some test to check that
the library correctly <a href="https://github.com/namshi/AB/blob/master/tests/Namshi/AB/Test/TestTest.php#L161">generates variations according to their odds</a>.</p>

<h2>FOSS</h2>

<p>The library is available on
<a href="https://github.com/namshi/AB">Github</a>: please let
<a href="https://github.com/namshi">us</a> know if you
would like to see something different, have a suggestion
or whatsoever: even better than that, <strong>feel free to open
a pull request</strong> if we screwed up with anything!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Desktop notifications for PHPUnit tests on Ubuntu]]></title>
    <link href="http://odino.org/desktop-notifications-for-phpunit-tests-on-ubuntu/"/>
    <updated>2013-06-21T03:48:00+04:00</updated>
    <id>http://odino.org/desktop-notifications-for-phpunit-tests-on-ubuntu</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/phpunit-notification-ko.png"></p>

<p>As everyone knows, automated tests are great
since they let you test a system without the need
of proactively checking anything: you launch your suite
and you get a feedback; moreover, systems like Jenkins or Travis-CI allow you
to even forget about checking the status of
a build since they can do all of this work for you:
the problem, instead, happens when you need
to run the tests locally, as you always need to
check the shell to know whether the tests passed or not.</p>

<p>A solution would be to launch the tests and mind
your own business, instead of having to check the CLI
output, waiting for a notification that tells
use about the tests' result.</p>

<!-- more -->


<h2>Notifications to the rescue</h2>

<p>A very simple program, written for Linux, can help
you with this task: it&rsquo;s <code>notify-send</code>.</p>

<p>Given that you have PHPUnit installed via composer
(so the binary is accessible at <code>./vendor/bin/phpunit</code>)
you can simply use a small shell function that can
sends notifications about the tests' results, that I
put on <a href="https://github.com/odino/phpunit-notifications">Github</a>.</p>

<h2>Installation</h2>

<p>Clone the repository and add the shell function to your
shell profile<sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup>:</p>

<p>```
cd wherever</p>

<p>git clone git@github.com:odino/phpunit-notifications.git</p>

<p>chmod +x phpunit-notifications/phpunit-notifications.sh</p>

<p>echo &lsquo;source wherever/phpunit-notifications/phpunit-notifications.sh&rsquo; >> ~/.zshrc
```</p>

<h2>Usage</h2>

<p>At this point you can open a new shell and run your tests with
the <code>phpunit</code> commmand:</p>

<p>```
cd ~/projects/my-project</p>

<p>phpunit</p>

<p>// or</p>

<p>phpunit -c config</p>

<p>// or</p>

<p>phpunit tests/My/Example/ClassTest.php
```</p>

<p><img class="left" src="/images/phpunit-notification-ok.png"></p>

<p>and see that as soon as the tests are over you will
see one of those usual notifications on the top right
of your screen, hopefully telling you that the automated
tests suite is greener than ever.</p>

<p>The <code>notify-send</code> utility is probably not available on
Macs, but I guess you can just replace it with <code>growlnotify</code>.</p>

<p>If you are interested into digging deeper into the topic,
I would suggest you to read a very nice article from
Giulio Di Donato which explains how to <a href="http://welcometothebundle.com/automate-test-and-code-inspection-in-php-with-guard-and-symfony2/">run PHPUnit tests for Symfony2 as soon as any file in your filesystem changes, and get the same type of notifications</a>:
even though I personally think this approach is a little
bit too extreme<sup id='fnref:3'><a href='#fn:3' rel='footnote'>3</a></sup>, it is anyhow interesting as
it pushes automation and time-management to their best limits.</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>Or, for example, to empty the tables of the right database after each test (there are different databases for each website) <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>I am personally using ZSH: https://github.com/robbyrussell/oh-my-zsh <a href='#fnref:2' rev='footnote'>↩</a></li><li id='fn:3'>If you modify 5 files and your test suite is 30secs long, woul will already have to wait 2 and a half minutes <a href='#fnref:3' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why our business choose Symfony2 over any other PHP framework]]></title>
    <link href="http://odino.org/why-we-choose-symfony2-over-any-other-php-framework/"/>
    <updated>2013-05-27T22:16:00+04:00</updated>
    <id>http://odino.org/why-we-choose-symfony2-over-any-other-php-framework</id>
    <content type="html"><![CDATA[<p>Everyone knows that I am a big fan of the
Symfony2 ecosystem, and going SOA with
this framework was a very trivial decision
for us at <a href="http://en-ae.namshi.com">Namshi</a>;
all in all, besides personal preferences,
there is a plethora of reasons to choose
this framework among the others available
in PHP, so I am going to list the most
important factors that influenced our
decision.</p>

<p>Believe it or not, all of the following
factors matter <strong>first for the business</strong>,
then for the developers.</p>

<!-- more -->


<h2>Testing</h2>

<p><img class="right" src="/images/behat.png"></p>

<p>We are firm believers in automated test practices,
and providing a layer that integrates very easily
with testing tools (such as Behat or PHPUnit) is a
must for us.</p>

<p>Symfony2 is a testing-prone framework because:</p>

<ul>
<li>it is well decoupled, so <em>unit testing</em> becomes very easy
since you can mock objects, isolate classes and inject stub
dependencies very easily</li>
<li>it provides a first layer for functional testing (with PHPUnit):
being an HTTP-centric framework, it provides a <a href="http://symfony.com/doc/2.0/book/testing.html#your-first-functional-test">base class</a>
that lets you simulate HTTP requests and examine the output; needless
to say, these kind of tests are way faster than the ones that you
would write with tools like Selenium, since they don&rsquo;t have the
overhead of testing with an actual browser</li>
<li>there is a <a href="http://extensions.behat.org/symfony2/">Behat extension</a>
that lets you integrate the framework with this behavioral testing tool</li>
</ul>


<p>At the end, you can see how Symfony2 and the ecosystem around it
provide the proper toolset to run <strong>unit</strong>, <strong>functional</strong> and
<strong>behavioral</strong> tests.
If you do care about testing, this is already a
huge point: we can&rsquo;t afford our developers to <strong>waste</strong>
a huge portion of their time doing manual testing, and
we don&rsquo;t want to increase overhead to build a
manual QA team; since we are a technology startup,
we should take advantage of technology to automate
expensive tasks that harm the business, like
manual testing<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>.</p>

<h2>Debugging</h2>

<p>I kind of had so much fun when, while still working
with symfony 1.4, I saw people developing with
frameworks like Yii or Zend Framework 1,
beating their heads on their desks tying to
understand which view to modify, var_dumping
SQL queries to output them and so on:
symfony 1.4 already had a very powerful
debug toolbar that would present all of these
informations in order to ease debugging.</p>

<p>Symfony2 goes beyond what we had before,
providing a way more powerful, extensible
toolbar and an integrated profiler.</p>

<p><img class="right" src="/images/symfony2-profiler.png"></p>

<p>Database inspection will let you realize
how many queries you are running and see the
SQL of all of them, with a nice overview of the
time they take, while the profiler itself
includes informations about every step
of the application: for example, with Joomla,
can you tell this easily how long it took to
render a particular view and how much memory
was used to execute a controller&rsquo;s action?</p>

<p>Now, imagine each of your developers
(let&rsquo;s say you have a team of 6),
spending 1 hour (very conservative estimate)
out of 40 (a working week) trying to obtain
informations that debugging tools natively give you:
it&rsquo;s almost a day per week; multiply that day for 52
weeks in a year and you will end up loosing
one of your developers for two moths.</p>

<p>We <strong>all</strong> honestly can&rsquo;t afford to let a guy
leave the company for 2 months for free, so why
would we keep using counterproductive tools?</p>

<h2>Doctrine 2</h2>

<p>It is no news that we, at Namshi,
<a href="/refactoring-your-architecture-go-for-soa/">are working with a Service-Oriented Architecture</a>,
and we are highly benefiting from the easy
integration that Symfony2 provides for
Doctrine.</p>

<p>One of the rules of thumb of designing
SOAs is that you can provide access to the
same data source to different services:
in simple terms, instead of talking via
webservices or messaging queues, services
can simply access the data stored <em>somewhere</em>
by other ones.</p>

<p><img class="left" src="/images/doctrine-cli.png"></p>

<p>Well, Doctrine 2 is the cherry on top of the
cake to access that <em>somewhere</em>: natively
providing support for multiple DB connections
and object-relational mappings, you can safely
use this tool, within Symfony2, to handle read
and writes to different databases without
polluting the domain model of each of the services
that take advantage of Doctrine; in addition to this,
I should enumerate the huge list of good things that
working with a data mapper like Doctrine 2 brings
on the table.</p>

<p>On another note, sharing the data model among different services
helps you overcoming though situations
where webservices or messaging queues are not
enough: think about a service which, due to
an update, needs to modify half a milion records
that &ldquo;belong&rdquo; to another service; of course,
istantly having 500k messages in a queue implies
a long, very long time to process them, while
a webservice might not be fully ok with sending
a huge payload over the HTTP protocol &ndash; and,
moreover, how do you start testing this feature,
when your developers need to send a lot of MB
through their browser? It is painful, believe me.</p>

<p>At this point, the ability of directly accessing
different DBs come out as a swiss-army knife, as
you can directly execute the 500k updates, in
batch, from the original service.</p>

<h2>Deployments</h2>

<p>Symfony2 has an <em>out of the box</em>
<a href="http://capifony.org/">integration with Capistrano</a>,
the most popular automated
deployment tool in the market.</p>

<p>This means that you should forget about
wasting time, money and energy to develop
your own in-house solution to automate
deployments or, even worse, rely on
manual procedure, which are prone to
errors where it hurts the most, on the
&ldquo;live server&rdquo;.</p>

<h2>DIC</h2>

<p>Let&rsquo;s say that you, for example, are
using <a href="http://graylog2.org/">Graylog2</a>
to handle logs in your application:
while you are developing locally, you
won&rsquo;t have a graylog2 server to connect to,
since it might be that you want to keep
your machine a bit cleaner and you might
find more useful to read local logs
from a file in the filesystem, or directly
output them to the browser.</p>

<p>In Symfony2, thanks to the <a href="http://symfony.com/doc/master/book/service_container.html">dependency-injection container</a>,
you can define the logger as a service:</p>

<p>``` bash config.yml
logger:</p>

<pre><code>class: 'Monolog\Logger'
arguments:
    name:           "applicationName-%kernel.environment%"
calls:
    - [ pushHandler, [ @monolog_handler.graylog ] ]  
</code></pre>

<p>monolog_handler.graylog:</p>

<pre><code>class: 'Monolog\Handler\GelfHandler'
arguments:
    publisher: @gelf.message_publisher
    level:     200
</code></pre>

<p>```</p>

<p>and, for development environments, you
can simply override the configuration in
the <code>config_dev.yml</code> file:</p>

<p>``` bash config_dev.yml
monolog_handler.graylog:</p>

<pre><code>class: 'Monolog\Handler\StreamHandler'
arguments:
  stream: "php://stdout"
</code></pre>

<p>```</p>

<p>This will allow you to output errors that
would normally go to graylog2 directly to
the developer&rsquo;s browser, easing debugging
when you can afford to display errors in
the browser &ndash; thing that is not possible
who&rsquo;s viewing your application is a
potential customer.</p>

<p>Apart from all the technicalities involved
in using a DIC, I would like to focus on
one point: again, simplicity and speed to implement a
solution to a problem (having different log
handlers depending on the application&rsquo;s environment,
in this case) are a winning factor for your
development team, which is translated in <strong>more
productivity for your company</strong>.</p>

<h2>Bundles</h2>

<p>When we kickstarted our first Symfony2-based
service in our architecture, we decided to meld
together 2 applications that support our CRM
and ERP systems: being inside Symfony2, these
layers are <strong>fully isolated</strong> in separate bundles,
giving us the ability of phisically decoupling them
in 2 installations in a matter of minutes.</p>

<p>Bundles are probably one of the most powerful
concepts of Symfony2, since they are
micro-applications inside your main application:
being able to totally separate logics from different
domains helps you in keeping a clean separation
of concerns and autonomously develop every single
feature of your domain.</p>

<h2>Declarative code</h2>

<p>Consider the following snippet, written using the
<a href="http://symfony.com/doc/master/components/finder.html">Symfony2 Finder component</a>:</p>

<p>``` php
&lt;?php</p>

<p>use Symfony\Component\Finder\Finder;
use Zend_Service_Amazon_S3 as Amazon_S3;</p>

<p>$s3 = new Amazon_S3($key, $secret);
$s3->registerStreamWrapper(&ldquo;s3&rdquo;);</p>

<p>$finder = new Finder();
$finder->name(&lsquo;photos*&rsquo;)&ndash;>size(&lsquo;&lt; 100K&rsquo;)&ndash;>date(&lsquo;since 1 hour ago&rsquo;);</p>

<p>foreach ($finder->in(&lsquo;s3://bucket-name&rsquo;) as $file) {</p>

<pre><code>print $file-&gt;getFilename();
</code></pre>

<p>}
```</p>

<p>After your <strong>first</strong> look at this code, you already know
what it is doing: now imagine that your team of developers
need to, instead, try to understand how the Drupal
framework works.</p>

<p>Taken from <a href="https://github.com/drupal/drupal/blob/7.x/modules/comment/comment.admin.inc#L271">Drupal&rsquo;s source code</a>:</p>

<p>``` php
&lt;?php</p>

<p>/<em>*
 * Process comment_confirm_delete form submissions.
 </em>/
function comment_confirm_delete_submit($form, &amp;$form_state) {
  $comment = $form[&lsquo;#comment&rsquo;];
  // Delete the comment and its replies.
  comment_delete($comment->cid);
  drupal_set_message(t(&lsquo;The comment and all its replies have been deleted.&rsquo;));
  watchdog(&lsquo;content&rsquo;, &lsquo;Deleted comment @cid and its replies.&rsquo;, array(&lsquo;@cid&rsquo; => $comment->cid));
  // Clear the cache so an anonymous user sees that his comment was deleted.
  cache_clear_all();</p>

<p>  $form_state[&lsquo;redirect&rsquo;] = &ldquo;node/$comment->nid&rdquo;;
}
```</p>

<p>I&rsquo;m far from saying that Drupal sucks, but some
questions rise into my mind:</p>

<ul>
<li>why do I have a <code>$form</code> and a separate <code>$form_state</code>?</li>
<li>what is <code>watchdog()</code> doing? Is it used for
logging? Or to display flash messages?</li>
<li>what is a <code>cid</code>? And what about the <code>nid</code>?</li>
<li>why should I clear my entire application&rsquo;s
cache to notify a user of a change?</li>
</ul>


<p>See, you don&rsquo;t want your developers to have to go
through an entire application to understand what
a piece of code does.</p>

<h2>Best practices</h2>

<p>Symfony2 is a framework made to take advantage
of clean and clear tested patterns as well as
tools to improve the final developer&rsquo;s
productivity: imagine your team, working
six months on this framework; how much would
they learn? How many structural changes
would they be able to do on your application without
introducing regressions?</p>

<p><img class="right" src="/images/best-practice.jpg"></p>

<p>For startups, by the way, a huge plus comes from
the fact that being highly decoupled, Symfony2 helps
when you want to drastically replace a piece of software,
or an adapter, with another one: for example,
thanks to the dependency-injection container,
you would be able to replace application services
with others that have the same API, but a different
implementation.</p>

<p>It is clear enough that Symfony2 provides the
flexibility you need to reach a very short
<em>time to market</em> and increases your developers'
awareness and efficiency by giving them the
guidance and the tools they need to care about
the domain of your services and not about how
many bugs they would introduce by changing an
untested piece of code.</p>

<h2>All in all&hellip;is it Symfony2?</h2>

<p>A very simple question that you should ask
yourself at the end of this reading is:
but, all in all, is this all thanks to
Symfony2 or its surrounding environment?</p>

<p>It is its surrounding environment, which
was born thanks to the framework itself:
when Symfony2 was released, no other framework
had the same level of quality that the open source
product from SensioLabs could offer;
a natural effect of this was that the
majority of well-known open source
PHP developers got amused by this framework
and embraced its way.</p>

<p>Basically, Symfony2 is a framework chosen by
the community, thus it can take advantage of
all the efforts of the OS developers around it:
from automated deployment tools to fully integrated
ORMs, from testing frameworks to tutorials
and best practices, through native, advanced
debugging tools, Symfony2 is, as of today the most
complete framework available in the PHP ecosystem
when you take in consideration learning curve,
integrations, stability and performances (don&rsquo;t forget
that one of <a href="http://highscalability.com/blog/2012/4/2/youporn-targeting-200-million-views-a-day-and-beyond.html">top 100 website in the Alexa rank</a>
is powered by Symfony2<sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup>).</p>

<p>Can other frameworks do all of this?</p>

<p>For the benefit of your <strong>business</strong>, this
is the main question that you should ask
yourself.</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>But - drumroll - since we are an e-commerce company, we always need to ensure that some critical parts of the system, like checkouts, are tested by a human reenacting our customers' behavior. So yes, for a few, business-critical things, we really *want* to do manual tests. <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>Even though I am sorry for using *that* website as an example, it is a very useful use-case when you consider its technical stack. <a href='#fnref:2' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automated tests from a novice's perspective]]></title>
    <link href="http://odino.org/automated-tests-from-a-novice-perspective/"/>
    <updated>2013-05-27T22:01:00+04:00</updated>
    <id>http://odino.org/automated-tests-from-a-novice-perspective</id>
    <content type="html"><![CDATA[<p>Today I got one of those moments of pride
when one of our developers, who is working
since &ndash; roughly &ndash; a year, decided to send an
email to the team after working on automated
tests for the first weeks of his career:</p>

<p><blockquote><p>Automated testing is great idea</p></p><p><p>If you have a ticket which requires a lot of changes (20 files, for example) Automated tests are very helpful and save your time, it saves about 30% of your time; even if it&rsquo;s still not perfect, its good<br/>For example look at this PR [link to a PR on Github], if i want to test all cases i need about half a day but it only took half an hour</p></blockquote></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Selenium and Symfony2 to help your frontend developers coding without risks]]></title>
    <link href="http://odino.org/using-behat-to-help-your-frontend-developers-coding-without-risks/"/>
    <updated>2013-03-10T11:39:00+04:00</updated>
    <id>http://odino.org/using-behat-to-help-your-frontend-developers-coding-without-risks</id>
    <content type="html"><![CDATA[<p>Since testing is one of those practices
that many consider <em>boring</em> (unless a major
catastrophe happens), you should help people
is easing their job while testing.</p>

<p>Today I am going to show the approach that
we just kickstarted, at Namshi, in order to
help designers and developers testing
frontend changes in a more automated, thus
easier, way.</p>

<!-- more -->


<p>Thanks to the <a href="https://github.com/namshi/NamshiVoyeurBundle">NamshiVoyeurBundle</a>,
it is really easy to start increasing
the efficiency of your testing department,
even if coders do not want to write
automated tests.</p>

<p>The bundle, that you can use <strong>inside a Symfony2
application</strong>, is actually very small and can be
extrapolated to be integrated in other frameworks
(like ZF2 or Cake).</p>

<p>The idea is very simple: you take some screenshots
of a website, deploy a new version, take another set of
screenshots (at the same URLs) and then compare
them, generating an image diff.</p>

<p>After you install the <code>NamshiVoyeurBundle</code> (via composer),
it is really easy to start taking screenshots;
you just have to configure a few services
and some parameters:</p>

<p>```yml Configuring the bundle
parameters:</p>

<pre><code>namshi_voyeur:
  browsers:
    - firefox
    - safari
    - chrome
  urls:
    homepage:     "/"
    new-arrivals: "new-products"
    women:        "women-shoes"
  shots_dir: "/Users/you/Downloads/screenshots"
  base_url:       "http://en-ae.namshi.com/"
</code></pre>

<p>services:</p>

<pre><code>safari:
    class:  Behat\Mink\Driver\Selenium2Driver
    calls:
      - [start]
    arguments:
      browser: safari
firefox:
    class:  Behat\Mink\Driver\Selenium2Driver
    calls:
      - [start]
chrome:
    class:  Behat\Mink\Driver\Selenium2Driver
    calls:
      - [start]
    arguments:
      browser: chrome
</code></pre>

<p>```</p>

<p>This configuration basically tells Voyeur that
you will be taking screenshots of three URLs:</p>

<ul>
<li><code>http://en-ae.namshi.com/</code></li>
<li><code>http://en-ae.namshi.com/new-products</code></li>
<li><code>http://en-ae.namshi.com/women-shoes</code></li>
</ul>


<p>with safari, firefox and google chrome.</p>

<p>To run the Voyeur, use the <code>cli</code>:</p>

<p><code>bash
php app/console namshi:voyeur
</code></p>

<p>Screenshots will be saved at <code>/Users/you/Downloads/screenshots</code>.</p>

<p>At this point, after you deployed a new version of the code,
run the Voyeur again, and you will be reay to generate the
diffs between the screenshots:</p>

<p><code>bash
php app/console namshi:voyeur:diff /Users/you/Downloads/screenshots/firefox/2013/03/10/1200 /Users/you/Downloads/screenshots/firefox/2013/03/10/1205
</code></p>

<p>Diffs will be generated at <code>/Users/you/Downloads/screenshots/firefox/2013/03/10/1205/diff</code>.</p>

<p>That&rsquo;s it: now you can start having a look at what changed and
ask your developers to do the same, even on their local
machine, before committing any changes.</p>
]]></content>
  </entry>
  
</feed>
