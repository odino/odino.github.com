<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: design patterns | Alessandro Nadalin]]></title>
  <link href="http://odino.org/blog/categories/design-patterns/atom.xml" rel="self"/>
  <link href="http://odino.org/"/>
  <updated>2013-06-28T14:30:27+04:00</updated>
  <id>http://odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Aspect-oriented logging with the Proxy pattern]]></title>
    <link href="http://odino.org/aspect-oriented-logging-with-the-proxy-pattern/"/>
    <updated>2012-11-23T10:39:00+04:00</updated>
    <id>http://odino.org/aspect-oriented-logging-with-the-proxy-pattern</id>
    <content type="html"><![CDATA[<p>One of the <strong>key</strong>-missing features
of PHP is the poor support that you
get from the language in terms of
<a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect Oriented Programming</a>:
essentially, there is no easy way
to distribute modules (or <em>aspects</em>)
of your application (it is usually done
with metaprogramming).</p>

<p>However, thanks to the <a href="/proxy-pattern-lazy-loading/">Proxy pattern</a>
and a <a href="http://fabien.potencier.org/article/12/do-you-need-a-dependency-injection-container">dependency-injection container</a>,
we can provide a layer supporting a bit
of AOP: in this article we will find out how
to, silently, implement <em>logging</em>
without modifying the behaviour of the classes
of your PHP application.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using the Proxy pattern to implement lazy-loading]]></title>
    <link href="http://odino.org/proxy-pattern-lazy-loading/"/>
    <updated>2012-11-23T10:38:00+04:00</updated>
    <id>http://odino.org/proxy-pattern-lazy-loading</id>
    <content type="html"><![CDATA[<p>This article mainly comes from what I&rsquo;ve seen
in <a href="http://www.doctrine-project.org/">Doctrine 2</a> and I tried to replicate in
<a href="https://github.com/congow/Orient">Orient</a>, an Object Document Mapper for
OrientDB, written in PHP: even though PHP
doesn&rsquo;t have a very good support for
metaprogramming and <a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">AOP</a>, proxying can be
really easy to implement and useful to
accomplish hard tasks.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use the Strategy to avoid the Switch-Case antipattern]]></title>
    <link href="http://odino.org/use-the-strategy-to-avoid-the-switch-case-antipattern/"/>
    <updated>2012-05-14T00:28:00+04:00</updated>
    <id>http://odino.org/use-the-strategy-to-avoid-the-switch-case-antipattern</id>
    <content type="html"><![CDATA[<p>In PHP we have tons of bad constructs/functions that don&rsquo;t actually
help newcomers on writing good code: the <code>SWITCH/CASE</code> statement is one
of those that I hate the most, although very few developers rely on
it.</p>

<!-- more -->


<p>The statement is pretty straightfoward</p>

<p>``` php Simple SWITCH/CASE statement
&lt;?php</p>

<p>class Logger
{</p>

<pre><code>public function logMessage($message = "CRITICAL::The system encountered a problem")
{
    $parts = explode('::', $message);
    $level = $parts[0];

    switch ($level) {
        case 'notice':
            ...
            break;
        case 'critical':
            ...
            break;
        case 'catastrophe':
            ...
            break;
    }
}
</code></pre>

<p>```</p>

<p>and is intended to make multiple IFs more readable.</p>

<p>It may seem useful, but at first you should recognize that <strong>multiple
IFs are already a bad smell</strong>, so, from the beginning there is something
with a code trying to make them look nicer.</p>

<p>The <a href="http://en.wikipedia.org/wiki/Strategy_pattern">Strategy pattern</a>,
one of my favourites, is a simple but powerful way to avoid writing
procedural code that relies on IFs.</p>

<p>The main concept is that you should contextualize the application&rsquo;s
workflow at runtime, deciding which steps (methods) to run based on
data which is external to the method itself.</p>

<p>``` php silly implementation of Strategy
&lt;?php</p>

<p>class Logger
{</p>

<pre><code>public function logMessage($message = "CRITICAL::The system encountered a problem")
{
    $parts  = explode('::', $message);
    $level  = $parts[0];
    $method = sprintf('log%sMessage', ucfirst($level));
    $output = $this-&gt;$method($parts[1]);
}
</code></pre>

<p>```</p>

<p>In this way we are able to isolate and keep clean the implementations
of the methods, thus the logic behind the application.</p>

<p>This means that we only need to implement submethods:</p>

<p>``` php
&lt;?php</p>

<p>public function logNoticeMessage($message);</p>

<p>public function logCriticalMessage($message);</p>

<p>public function logCatastropheMessage($message);
```</p>

<p>If this doesn&rsquo;t seem important to you, consider this scenario:
you are shipping a library with the <code>SWITCH/CASE</code> in the first example;
what would happen if another developer using that library would only
like to edit the logic when a <code>catastrophe</code> message is received?</p>

<p>Yes, he would need to override the entire <code>logMessage</code> method,
<strong>loosing the possibility to benefit of future software updates</strong>
for that specific method.</p>
]]></content>
  </entry>
  
</feed>
