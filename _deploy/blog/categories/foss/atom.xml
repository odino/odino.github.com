<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: FOSS | Alessandro Nadalin]]></title>
  <link href="http://odino.org/blog/categories/foss/atom.xml" rel="self"/>
  <link href="http://odino.org/"/>
  <updated>2013-09-21T22:03:13+04:00</updated>
  <id>http://odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AB testing in PHP with namshi/ab]]></title>
    <link href="http://odino.org/ab-testing-in-php-with-namshi-slash-ab/"/>
    <updated>2013-07-13T14:27:00+04:00</updated>
    <id>http://odino.org/ab-testing-in-php-with-namshi-slash-ab</id>
    <content type="html"><![CDATA[<p>AB testing is a powerful tecnique that
lets you gather metrics about different
versions of a feature: it basically
consist into displaying a number of
different variations of it to your
users and tracking the results to see
which variation performed better.</p>

<p><img class="right" src="/images/ab-testing.jpg"></p>

<p>An example? In an e-commerce system,
you usually have an &ldquo;Add to cart&rdquo; button:
have you ever though about the impact that
single sentence has on your customers?
What would sound better, between &ldquo;Add to cart&rdquo;
and &ldquo;Buy now&rdquo;, for example? Copywriters
away, you want <strong>data</strong> to tell you that!</p>

<p>This is why AB testing is important:
you serve different versions of something,
and track the results to improve the
experience users have while using your
application: for example, Google benchmarked
<a href="http://gigaom.com/2009/07/09/when-it-comes-to-links-color-matters/">40 different shades of blue</a>
to find out how the rate of clickthrough
would be altered.</p>

<p>At <a href="http://en-ae.namshi.com">Namshi</a> we
decided to ease AB testing by creating a
very simple library that would let you generate
and manage tests in a very easy and practical
way: that&rsquo;s how <a href="https://github.com/namshi/ab">Namshi/AB</a>
was born.</p>

<!--   more -->


<h2>Installation</h2>

<p>You can install the library via composer,
as it&rsquo;s available on <a href="https://packagist.org/packages/namshi/ab">packagist</a>.</p>

<p>Then include it, specifying a major and
minor version, in your <code>composer.json</code>:</p>

<p><code>
"namshi/ab": "1.0.*"
</code></p>

<h2>Creating and running tests</h2>

<p>The library is very small, and it comes bundled with
2 classes, <code>Test</code> and <code>Container</code>: as you can probably
guess, the first is a representation of an AB test and
the 2nd serves as a convenient container for all of your
test instances.</p>

<p>Here&rsquo;s how you can create a test:</p>

<p>``` php
&lt;?php</p>

<p>use Namshi\AB\Test;
use Namshi\AB\Container;</p>

<p>$cssTest = new Test(&lsquo;css&rsquo;, array(</p>

<pre><code>'default.css'   =&gt; 2,
'new.css'       =&gt; 1,
</code></pre>

<p>));</p>

<p>$abContainer = new Container(array(</p>

<pre><code>$cssTest
</code></pre>

<p>));
```</p>

<p>At this point, for example, you can start
AB testing your website by changing the CSS
in the view:</p>

<p>``` php
<html></p>

<pre><code>&lt;head&gt;
    &lt;link rel="stylesheet" type="text/css" href="&lt;?php echo $abContainer['css']-&gt;getVariation(); ?&gt;"  /&gt;
    ...
    ...
</code></pre>

<p>```</p>

<p><code>getVariation()</code> will calculate the variation
(<code>default.css</code> or <code>new.css</code>) according to the
odds of each variation (66% for the first one,
33% for the second one) and will return a string
representing the variation.</p>

<h2>Persisting the variations through an entire session</h2>

<p>Of course, you want to display variations but be
consistent with each user, so that if a user gets
a variation, it will continue getting the same variation
throughout his entire session: to do so, just calculate
a random integer (seed), store it in session and pass it to
each test:</p>

<p>``` php
&lt;?php</p>

<p>session_start();</p>

<p>if (!isset($_SESSION[&lsquo;seed_for_example_test&rsquo;])) {</p>

<pre><code>$_SESSION['seed_for_example_test'] = mt_rand();
</code></pre>

<p>}</p>

<p>$test = new Test(&lsquo;example&rsquo;, array(</p>

<pre><code>'a' =&gt; 1,
'b' =&gt; 1,
</code></pre>

<p>));</p>

<p>$test->setSeed($_SESSION[&lsquo;seed_for_example_test&rsquo;]);</p>

<p>// as long as the seed doesn&rsquo;t change
// getVariation() will always return the
// same variation
$test->getVariation();
```</p>

<p>Soon, you will realize that having a per-test seed
is <strong>not efficient at all</strong>, that&rsquo;s why you can create
a global seed and pass it to the container: from that
seed, the container will take care of generating a seed
for each test:</p>

<p>``` php
&lt;?php</p>

<p>session_start();</p>

<p>if (!isset($_SESSION[&lsquo;seed&rsquo;])) {</p>

<pre><code>$_SESSION['seed'] = mt_rand();
</code></pre>

<p>}</p>

<p>// pass the seed into the constructor
$abContainer = new Container(array(</p>

<pre><code>new Test('greet', array(
    'Hey dude!' =&gt; 1,
    'Welcome'   =&gt; 1,
)),
new Test('background-color', array(
    'yellow'    =&gt; 1,
    'white'     =&gt; 1,
)),
</code></pre>

<p>), $_SESSION[&lsquo;seed&rsquo;]);</p>

<p>// or with a setter
$abContainer->setSeed($_SESSION[&lsquo;seed&rsquo;]);
```</p>

<h2>Disabling the tests</h2>

<p>Sometimes you might want to disable tests
for different purposes, for example if
the user agent who is visiting the page is a bot:</p>

<p>``` php
&lt;?php</p>

<p>$test = new Test(&lsquo;my_ab_test&rsquo;, array(</p>

<pre><code>'a' =&gt; 0,
'b' =&gt; 1,
</code></pre>

<p>));</p>

<p>$test->disable();</p>

<p>$test->getVariation(); // will return &lsquo;a&rsquo;!
```</p>

<p>Once you disable the test and run it,
it will always return the first variation,
no matter what its odds are, even if it&rsquo;s zero.</p>

<h2>An example</h2>

<p>I would recommend you to have a look at the
<a href="https://github.com/namshi/AB/tree/master/examples">example provided</a> under the <code>examples</code> directory:
it&rsquo;s pretty silly, but it gives you an idea of
how easy is to create and run AB tests with
this library.</p>

<p><img class="center" src="/images/ab.png"></p>

<p>If you look at the code, you will soon realize that
it&rsquo;s very simple:</p>

<p>``` php
&lt;?php</p>

<p>require <strong>DIR</strong> . &lsquo;/../vendor/autoload.php&rsquo;;</p>

<p>use Namshi\AB\Test;
use Namshi\AB\Container;</p>

<p>session_start();</p>

<p>if (!isset($_SESSION[&lsquo;seed&rsquo;])) {</p>

<pre><code>$_SESSION['seed'] = mt_rand();
</code></pre>

<p>}</p>

<p>$abt = new Container(array(</p>

<pre><code>new Test('greet', array(
    'Hey dude!' =&gt; 1,
    'Welcome'   =&gt; 1,
)),
new Test('background-color', array(
    'yellow'    =&gt; 1,
    'white'     =&gt; 1,
)),
</code></pre>

<p>), $_SESSION[&lsquo;seed&rsquo;]);</p>

<p>?></p>

<p><html></p>

<pre><code>&lt;head&gt;
    &lt;style&gt;
        * {
            background-color: &lt;?php echo $abt['background-color']-&gt;getVariation(); ?&gt;;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;
        &lt;?php echo $abt['greet']-&gt;getVariation(); ?&gt;
    &lt;/h1&gt;

    &lt;div&gt;
        Your seed is &lt;?php echo $_SESSION['seed']; ?&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<p>Of course, never write an application like this ;&ndash;)
this serves just as an example.</p>

<h2>Additional features</h2>

<p>We tried to extensively cover the available features of
the library in its <a href="https://github.com/namshi/ab">README</a>,
so I will just sum them up here:</p>

<ul>
<li>the container implements the <code>ArrayAccess</code> interface, so you can
retrieve tests like if they were stored into an array (<code>$abContainer['my_test']</code>)</li>
<li>since AB tests are very useful only when you <strong>track</strong>
the results, we added a <strong>tracking name</strong> that you can specify
for each test: this is due to the fact that your test might be
called <code>add_to_cart_text</code> but in your tracking tool, you
have to reference the test with the tracking tool&rsquo;s ID, which
might be a very clueless string (ie. <code>test_id_4njktn4t4tjjnn4on</code>)</li>
<li>you can also add an array of parameters to each test and retrieve
them later on: this is due to the fact that once you track the test&rsquo;s
result, you might want to send additional data together with the
tracking name, the variation and the result</li>
</ul>


<h2>Why not choosing an existing library</h2>

<p>Of course we checked out what the market was
offering, but weren&rsquo;t able to find out a very
good, generic-purpose, library in order to
generate AB tests:</p>

<ul>
<li><a href="https://packagist.org/packages/jm/ab-bundle">jm/ab-bundle</a>
is unfortunately coupled with Symfony2 and Twig, so
you can&rsquo;t really call it a stack-free library: even though
we <strong>love</strong> Symfony2, not all of our services run with
it and we don&rsquo;t want to <strong>force a technology just to
have a functionality</strong></li>
<li><a href="http://phpabtest.com/index">phpabtest</a> is a full-stack
service, meaning that it provides a library to register and
handle tests but also tracks stuff via Google Analytics; moreover,
<a href="https://github.com/briancray/phpA-B/blob/master/phpab.php">we didn&rsquo;t like the code that much</a></li>
</ul>


<p>At the end of the day, <code>namshi/ab</code> is a <strong>1 man-day effort</strong>, so we
spiked for a bit and decided that it was worth it.</p>

<h2>Testing this library</h2>

<p>We added a few PHPUnit tests, so you just have to:</p>

<p>```
cd /path/to/namshi/ab</p>

<p>phpunit
```</p>

<p>The funny thing is that we also added some test to check that
the library correctly <a href="https://github.com/namshi/AB/blob/master/tests/Namshi/AB/Test/TestTest.php#L161">generates variations according to their odds</a>.</p>

<h2>FOSS</h2>

<p>The library is available on
<a href="https://github.com/namshi/AB">Github</a>: please let
<a href="https://github.com/namshi">us</a> know if you
would like to see something different, have a suggestion
or whatsoever: even better than that, <strong>feel free to open
a pull request</strong> if we screwed up with anything!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notificator, sending notifications through PHP in a clean and lightweight way]]></title>
    <link href="http://odino.org/notificator-sending-notifications-through-php-in-clean-and-lightweight-way/"/>
    <updated>2013-07-11T01:20:00+04:00</updated>
    <id>http://odino.org/notificator-sending-notifications-through-php-in-clean-and-lightweight-way</id>
    <content type="html"><![CDATA[<p>While implementing various pieces of our
<a href="/why-we-choose-symfony2-over-any-other-php-framework/">Service-Oriented Architecture</a>
we, at <a href="http://en-ae.namshi.com">Namshi</a>,
realized that a central notification
service would have been very good in order
to abstract the way we notify our customers
and everyone in the company (ie. skype messages
when a task is due a certain date).</p>

<p>We initially implemented all of this
<a href="/configuring-a-symfony2-application-to-support-soa/">inside a Symfony2 bundle</a>,
but soon realized that we could
abstract and generalize our implementation
in order to extract it into a library for the public
domain, and that&rsquo;s how
<a href="https://github.com/namshi/notificator">notificator</a>
was born.</p>

<!-- more -->


<h2>Aim of the library: a monolog-like implementation for notifications</h2>

<p>The aim of this library is to provide a very
clean abstraction for a task, handling notifications,
that can be spread across multiple channels (for example
emails, skype messages, desktop notifications, &hellip;):
by following this target, we soon realized that by merging
together 2 simple things, <a href="https://github.com/Seldaek/monolog">Monolog</a>
and the concept of <a href="http://en.wikipedia.org/wiki/Observer_pattern">event dispatching</a>,
we could have easily reached our goal.</p>

<p>Honestly, it&rsquo;s true that you can achieve the same goal with
Monolog, but the problem, there, is that it&rsquo;s a library
specifically built for logging, thus, when your domain
deals with simple notifications, your code would really
be inexpressive.</p>

<p>Even though <strong>Notificator is way simpler</strong>, we took a lot
of inspiration from Monolog: for example, the concept of
handlers is a total steal ;&ndash;)</p>

<h2>Installation</h2>

<p>The library is available via composer,
as you can see from its
<a href="https://packagist.org/packages/namshi/notificator">packagist page</a>.</p>

<p>Using semantic versioning, I recommend you
to pick a minor release (<code>1.0</code>, for example)
and stick to it in your <code>composer.json</code>:
what we try to do is that, if there is a BC break
in the API, we increase the minor version (<code>1.0.X</code> to <code>1.1.X</code>, for example).</p>

<p>At the end, you <strong>should</strong> require it like this:</p>

<p><code>
"namshi/notificator": "1.0.*"
</code></p>

<h2>Hello world! example</h2>

<p>Just to give a very rough and simple example on how this
library works, let&rsquo;s see how you can trigger a notification
via <strong>both</strong> email (with PHP&rsquo;s <code>mail</code> function<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>)
and the <code>notify-send</code> utility available on ubuntu (I&rsquo;ve already spoke
about it in <a href="/desktop-notifications-for-phpunit-tests-on-ubuntu/">a previous post</a>).</p>

<p>First of all, we would need to create a <em>plain-old-php-class</em>
representing the notification, which implements 2 interfaces:</p>

<p>``` php
&lt;?php</p>

<p>use Namshi\Notificator\Notification;
use Namshi\Notificator\NotificationInterface;</p>

<p>interface NotifySendNotificationInterface extends NotificationInterface
{</p>

<pre><code>public function getMessage();
</code></pre>

<p>}</p>

<p>interface EmailNotificationInterface extends NotificationInterface
{</p>

<pre><code>public function getAddress();
public function getSubject();
public function getBody();
</code></pre>

<p>}</p>

<p>class DoubleNotification extends Notification implements NotifySendNotificationInterface, EmailNotificationInterface
{</p>

<pre><code>protected $address;
protected $body;
protected $subject;

public function __construct($address, $subject, $body, array $parameters = array())
{
    parent::__construct($parameters);

    $this-&gt;address  = $address;
    $this-&gt;body     = $body;
    $this-&gt;subject  = $subject;
}

public function getAddress()
{
    return $this-&gt;address;
}

public function getSubject()
{
    return $this-&gt;subject;
}

public function getBody()
{
    return $this-&gt;body;
}

public function getMessage()
{
    return $this-&gt;getBody();
}
</code></pre>

<p>}
```</p>

<p>At this point we need 2 notification handlers, which
will separately handle the notification:</p>

<p>``` php
&lt;?php</p>

<p>use Namshi\Notificator\Notification\Handler\HandlerInterface;
use Namshi\Notificator\NotificationInterface;</p>

<p>class NotifySendNotificationHandler implements HandlerInterface
{</p>

<pre><code>public function shouldHandle(NotificationInterface $notification)
{
    return $notification instanceOf NotifySendNotificationInterface;
}

public function handle(NotificationInterface $notification)
{
    shell_exec(sprintf('notify-send "%s"', $notification-&gt;getMessage()));
}
</code></pre>

<p>}</p>

<p>class EmailNotificationHandler implements HandlerInterface
{</p>

<pre><code>public function shouldHandle(NotificationInterface $notification)
{
    return $notification instanceOf EmailNotificationInterface;
}

public function handle(NotificationInterface $notification)
{
    mail($notification-&gt;getAddress(), $notification-&gt;getSubject(), $notification-&gt;getBody());
}
</code></pre>

<p>}
```</p>

<p>We&rsquo;re basically there: with a bunch of code we can now trigger
a notification both via email and <code>notify-send</code>:</p>

<p>``` php
&lt;?php</p>

<p>// create the manager and assign handlers to it
use Namshi\Notificator\Manager;</p>

<p>$manager = new Manager();
$manager->addHandler(new NotifySendNotificationHandler());
$manager->addHandler(new EmailNotificationHandler());</p>

<p>$notification = new DoubleNotification(&lsquo;<a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#97;&#108;&#x65;&#115;&#115;&#x61;&#x6e;&#100;&#x72;&#x6f;&#x2e;&#110;&#97;&#100;&#x61;&#108;&#105;&#110;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;">&#97;&#x6c;&#101;&#115;&#115;&#x61;&#x6e;&#100;&#114;&#111;&#46;&#x6e;&#x61;&#x64;&#x61;&#108;&#105;&#110;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;</a>&rsquo;, &lsquo;Test email&rsquo;, &lsquo;Hello!&rsquo;);</p>

<p>//  trigger the notification
$manager->trigger($notification);
```</p>

<p><img class="right" src="/images/notification-email.png"></p>

<p>At this point, if you run this example<sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup>, you should
see a notification popping up on your desktop and, in a few seconds,
you will also receive an email to the address you&rsquo;ve given, with the subject
&ldquo;Test email&rdquo; and &ldquo;Hello!&rdquo; in the body.</p>

<p>By the way, if you want to see some examples on
how the library works, <a href="https://github.com/namshi/notificator/tree/master/examples">check them out on github</a>.</p>

<h2>Sending notifications via RabbitMQ</h2>

<p>It is no news that we heavily rely on
<a href="http://odino.org/refactoring-your-architecture-go-for-soa/">RabbitMQ in our SOA</a>,
so it&rsquo;s pretty obvious that, to implement the notification service,
we send messages containing the notifications, that will
be intercepted by our notification service, which relies on
Notificator.</p>

<p>To do so, we take advantage of the great job done by
<a href="https://twitter.com/old_sound">Alvaro Videla</a>
on RabbitMQ for PHP and Symfony2, through the
<a href="https://github.com/videlalvaro/php-amqplib">PHP AMQP library</a>
and the <a href="https://github.com/videlalvaro/RabbitMqBundle">RabbitMQ bundle</a>.</p>

<p>If you are familiar with them, you know that in order to consume messages,
you have to declare your consumer as a callback of the actual, generic
rabbitmq consumer, through the <code>config.yml</code> file:</p>

<p>``` yaml app/config/config.yml
old_sound_rabbit_mq:</p>

<pre><code>consumers:
    notification:
        connection: default
        exchange_options: {name: 'notifications', type: direct}
        queue_options:    {name: 'notifications'}
        callback:         namshi.notification.consumer
</code></pre>

<p>services:</p>

<pre><code>namshi.notification.consumer:
    class: Namshi\Notificator\Messaging\RabbitMQ\Symfony2\Consumer
    arguments: [@namshi.notification.manager]
namshi.notification.manager:
    class: Namshi\Notificator\Manager
    calls:
      - [addhandler, [@namshi.notification.handler.notify_send] ]
namshi.notification.handler.notify_send:
    class: Namshi\Notificator\Notification\Handler\NotifySend
</code></pre>

<p>```</p>

<p>We already provide a <a href="https://github.com/namshi/notificator/blob/master/src/Namshi/Notificator/Messaging/RabbitMQ/Symfony2/Consumer.php">very basic consumer callback</a>
to be used with the RabbitMQ bundle.</p>

<p>The main idea behind this is that the publisher serializes the notification
and sends it through RabbitMQ, while the consumer unserializes and
triggers it through the <code>Manager</code>. The publisher code would be very, very simple:</p>

<p>``` php
&lt;?php</p>

<p>$publisher = $container->get(&lsquo;old_sound_rabbit_mq.notifications_producer&rsquo;);</p>

<p>$notification = new MySampleNotification(&ldquo;man, this comes from RabbitMQ and Symfony2!&rdquo;);</p>

<p>$publisher->publish(serialize($notification));
```</p>

<p>and to start consuming messages you would only need to
start the consumer:</p>

<p><code>
php app/console rabbitmq:consumer -w notification
</code></p>

<h2>FOSS</h2>

<p>I&rsquo;ve tried to write a pretty extensive
<a href="https://github.com/namshi/notificator/">README</a> that you can use as a reference, on Github
(check the <a href="https://github.com/namshi/notificator/tree/master/tests">tests</a>, as well, to get an idea of the internals):
if you spot any typo or mistake, don&rsquo;t hesitate to
reach out and point it out.</p>

<p>This library is part of the efforts,
from <a href="https://github.com/namshi">Namshi</a>,
to be able to give back to the
OSS community as much as possible: you
are therefore strongly encouraged to open a PR
or express your opinion if you find that something
should be fixed or could be improved (there&rsquo;s a lot
of room for improvement, starting by implementing
many more <a href="https://github.com/namshi/notificator/tree/master/src/Namshi/Notificator/Notification/Handler">handlers</a>).</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>Only used for its simplicity here, please do not use it in production, use stuff like SwiftMailer instead! <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>I mostly took the example code from the README of the library on github, so forgive me if there are synthax errors or some typo. You can anyhow have a look at the examples (in the examples/ folder) to check some working code <a href='#fnref:2' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
</feed>
