<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Symfony2 | Alessandro Nadalin]]></title>
  <link href="http://odino.org/blog/categories/symfony2/atom.xml" rel="self"/>
  <link href="http://odino.org/"/>
  <updated>2012-05-14T14:37:17+04:00</updated>
  <id>http://odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Create a Composer command line installer with the Symfony2 CLI]]></title>
    <link href="http://odino.org/install-composer-dependencies-with-the-symfony2-cli/"/>
    <updated>2012-02-21T10:51:00+04:00</updated>
    <id>http://odino.org/install-composer-dependencies-with-the-symfony2-cli</id>
    <content type="html"><![CDATA[<p><ol class="aseries">
	<p>This post is part of the "<strong>Symfony2 components in your own userland</strong>" series; here is a list of all the articles contained this series:</p>
	<li>
		<a href="/using-the-symfony2-dependency-injection-container-as-a-standalone-component/">Using the Symfony2 Dependency Injection Container as a standalone component</a>
	</li>
	<li>
		<a href="/launching-phpunit-tests-from-a-browser-with-symfony2/">Launching PHPUnit tests from a browser with Symfony2</a>
	</li>
	<li>
		<a href="/install-composer-dependencies-with-the-symfony2-cli/">Using the Console component to write an interactive installer for Composer</a>
	</li>
</ol>
</p>

<p>Today we are going to see the power of Symfony2's
<a href="https://github.com/symfony/console">Console component</a>,
which lets us build powerful interactive command line applications
in pure PHP.</p>

<!-- more -->


<p><img class="right" src="/images/installer.png"></p>

<p>In this episode we are going to create an interactive shell
able to generate new composer-based projects: we will have a
command to define which dependencies we need and another one
to:</p>

<ul>
<li>create the installation directory</li>
<li>download composer</li>
<li>generate  a <code>composer.json</code> according to the required dependencies</li>
<li>run a <code>php composer.phar install</code> to install everything</li>
</ul>


<p>The approach we're going to use will be very rough and incomplete: no
error handling, no decent abstraction, but is intended to give you a
clue about the potentiality of the CLI tool and to show you how you can
easily create PHP command line applications without the need to
write too much good code.</p>

<h2>Approach and installation</h2>

<p>The Symfony2 Console lets use extend the <code>Console\Command\Command</code> class to
implement your own commands, so we will add a couple custom commands, one to
<strong>register dependencies</strong> and one to <strong>execute the installation</strong>.</p>

<p>First of all, let create our own <code>composer.json</code>, to download the Console
and <a href="/launching-phpunit-tests-from-a-browser-with-symfony2/">Process</a><sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>
components:</p>

<p>``` bash composer.json
{</p>

<pre><code>"require": {
    "php": "&gt;=5.3.2",
    "symfony/console": "2.0.10",
    "symfony/process": "2.0.10"
}
</code></pre>

<p>}
```</p>

<p>then install everything and create your <code>installer.php</code> script which
serves as the entry point for the console:</p>

<p>``` bash installing the dependencies
wget http://getcomposer.org/composer.phar</p>

<p>php composer.phar install
```</p>

<p>``` php installer.php
&lt;?php</p>

<p>require 'vendor/.composer/autoload.php';
require 'Command/DependencyContainer.php';
require 'Command/Install.php';</p>

<p>use Symfony\Component\Console\Shell;
use Symfony\Component\Console\Application;</p>

<p>$application            = new Application('Installer', '1.0.0-alpha');
$dependencyContainer    = new DependencyContainer();
$application->add($dependencyContainer);
$application->add(new Install($dependencyContainer));
$shell = new Shell($application);</p>

<p>$shell->run();
```</p>

<p>In the <code>installer.php</code> we are instantiating a new interactive shell
application, adding to it 2 new commands and then we run it: don't try it now,
as the added command classes don't exist yet.</p>

<h2>A container for the dependencies</h2>

<p>The first custom command we are going to add is a dependency container, which is
a convenient class storing the dependencies, like <code>symfony/yaml</code>, in an
attribute, and exposes a <code>getDependencies()</code> method that will be used by the
installer command to retrieve the dependencies to install.</p>

<p>``` php Command/DependencyContainer.php
&lt;?php</p>

<p>use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;</p>

<p>class DependencyContainer extends Command
{</p>

<pre><code>protected $dependencies = array();

public function getDependencies()
{
    return $this-&gt;dependencies;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
    $dialog  = $this-&gt;getHelperSet()-&gt;get('dialog');
    $package = $dialog-&gt;ask($output, '&lt;question&gt;Please enter the name of the package you want to install&lt;/question&gt;');

    if ($package) {
        $this-&gt;dependencies[] = '"' . $package . '": "master"';
        $output-&gt;writeln(sprintf('&lt;info&gt;Package %s was succesfully registered&lt;/info&gt;', $package));
    } else {
        $output-&gt;writeln('&lt;error&gt;You must insert a package name&lt;/error&gt;');   
    }
}

protected function configure()
{
    $this
        -&gt;setName('add-dependency');
    ;
}
</code></pre>

<p>}
```</p>

<p>As you see, the command will be called when doing a <code>add-dependency</code> from the console
and will ask the user to prompt the dependency we wants to add; a basic check is done:</p>

<p>``` php Checking for non-empty input
&lt;?php
...</p>

<p>if ($package) {</p>

<pre><code>$this-&gt;dependencies[] = '"' . $package . '": "master"';
$output-&gt;writeln(sprintf('&lt;info&gt;Package %s was succesfully registered&lt;/info&gt;', $package));
</code></pre>

<p>} else {</p>

<pre><code>$output-&gt;writeln('&lt;error&gt;You must insert a package name&lt;/error&gt;');   
</code></pre>

<p>}
```</p>

<p>Note that, for being <em>quick'n'dirty</em>, we store the dependencies in the composer way:</p>

<p><code>bash
"dependencyvendor/dependencyname": "dependencyversion"
</code></p>

<p>and we use <code>master</code> as the only version available<sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup>.</p>

<p>This is it: now we only need to create the command to install everything.</p>

<h2>The installation command</h2>

<p>The <code>Install</code> command will be called with <code>install</code> from the command line, and
executes 4 sub-tasks to finish the installation process:</p>

<ul>
<li>create the installation directory</li>
<li>download composer via <code>wget</code></li>
<li>generate the <code>composer.json</code> according to the dependencies specified in the
DependencyContainer</li>
<li>run the composer traditional installation (<code>php composer.phar install</code>)</li>
</ul>


<p>This command takes a <code>DependencyContainer</code> argument in the constructor
to extract the dependencies needed to be installed:</p>

<p>``` php Command/Install.php
&lt;?php</p>

<p>use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Process\Process;</p>

<p>class Install extends Command
{</p>

<pre><code>protected $installDir;
protected $failingProcess;
protected $dependenciesContainer;

public function __construct(DependencyContainer $dependenciesContainer)
{
    parent::__construct();

    $this-&gt;dependenciesContainer = $dependenciesContainer;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
    if ($this-&gt;createInstallationDirectory($output)
     &amp;&amp; $this-&gt;downloadComposer($output)
     &amp;&amp; $this-&gt;generateJson($output)
     &amp;&amp; $this-&gt;install($output)) {
        $output-&gt;writeln('&lt;info&gt;MISSION ACCOMPLISHED&lt;/info&gt;');
    } else {
        $output-&gt;writeln('&lt;error&gt;Nasty error happened :\'-(&lt;/error&gt;');

        if ($this-&gt;failingProcess instanceOf Process) {
            $output-&gt;writeln('&lt;error&gt;%s&lt;/error&gt;', $this-&gt;failingProcess-&gt;getErrorOutput());   
        }
    }
}

protected function configure()
{
    $this
        -&gt;setName('install')
    ;
}
</code></pre>

<p>}
```</p>

<p>as you see we execute this 4 tasks and, if an error happens, we output an error,
otherwise a confirmation message tells the user that everything went fine.</p>

<p>If a failure happens, we get the error message thanks to the <code>Process</code> method <code>getErrorOutput()</code>.</p>

<p>Let's see how the tasks are implemented in this class: first of all, we need a <code>createInstallationDirectory()</code>
method that launches a new <code>mkdir</code> process and returns a boolean value, indicating the
successfulness of the process; before returning false, the class' internal attribute
<code>$failingProcess</code> is updated:</p>

<p>``` php
&lt;?php
...</p>

<p>protected function createInstallationDirectory(OutputInterface $output)
{</p>

<pre><code>$dialog             = $this-&gt;getHelperSet()-&gt;get('dialog');
$this-&gt;installDir   = $dialog-&gt;ask($output, '&lt;question&gt;Please specify a non-existing directory to start the installation&lt;/question&gt;');

if (!is_dir($this-&gt;installDir)) {
    $mkdir = new Process(sprintf('mkdir -p %s', $this-&gt;installDir));
    $mkdir-&gt;run();

    if ($mkdir-&gt;isSuccessful()) {
        $output-&gt;writeln(sprintf('&lt;info&gt;Directory %s succesfully  created&lt;/info&gt;', $this-&gt;installDir));

        return true;
    }
}

$this-&gt;failingProcess = $mkdir;
return false;
</code></pre>

<p>}
```</p>

<p>As you see, the user will be asked to provide an <code>$installDir</code> in which we are going
to execute the whole process.</p>

<p>Now we need to create the <code>downloadComposer()</code> method, which uses <code>wget</code> to put <code>composer.phar</code>
in the installation directory:</p>

<p>``` php
&lt;?php
...</p>

<p>protected function downloadComposer(OutputInterface $output)
{</p>

<pre><code>$wget = new Process(sprintf('wget getcomposer.org/composer.phar -O %s/composer.phar', $this-&gt;installDir, $this-&gt;installDir));
$wget-&gt;run();

if ($wget-&gt;isSuccessful()) {
    $output-&gt;writeln('&lt;info&gt;Downloaded composer in the installation directory&lt;/info&gt;');

    return true;
}

$this-&gt;failingProcess = $wget;
return false;
</code></pre>

<p>}
```</p>

<p>Then we generate a <code>composer.json</code> in the installation directory:</p>

<p>``` php
&lt;?php
...</p>

<p>protected function generateJson(OutputInterface $output)
{</p>

<pre><code>$skeleton       = file_get_contents(__DIR__ . "/../composer.s");
$dependencies   = implode(',', $this-&gt;dependenciesContainer-&gt;getDependencies());
$skeleton       = str_replace('PLACEHOLDER', $dependencies, $skeleton);

if (file_put_contents($this-&gt;installDir . "/composer.json", $skeleton)) {
    $output-&gt;writeln('&lt;info&gt;composer.json has been generated&lt;/info&gt;');

    return true;
}

return false;
</code></pre>

<p>}
```</p>

<p>Note that you will need a template file to do so:</p>

<p>``` bash composer.s
{</p>

<pre><code>"require": {
    PLACEHOLDER
}
</code></pre>

<p>}
```</p>

<p>The last step consists in launching a new process which runs the
usual composer's installation process on the installation directory:</p>

<p>``` php
&lt;?php
...</p>

<p>protected function install(OutputInterface $output)
{</p>

<pre><code>$install = new Process(sprintf('cd %s &amp;&amp; php composer.phar install', $this-&gt;installDir));
$install-&gt;run();

if ($install-&gt;isSuccessful()) {
    $output-&gt;writeln('&lt;info&gt;Packages succesfully installed&lt;/info&gt;');

    return true;
}

$this-&gt;failingProcess = $install;
return false;
</code></pre>

<p>}
```</p>

<p>This is the console output for generating a new project which depends on
<code>symfony/yaml</code> and <code>symfony/dom-crawler</code>:</p>

<p><img class="center" src="/images/shell.png"></p>

<p>The auto-generated <code>composer.json</code> will look like:</p>

<p>``` bash
{</p>

<pre><code>"require": {
    "symfony/yaml": "master","symfony/dom-crawler": "master"
}
</code></pre>

<p>}
```</p>

<h2>Conclusion</h2>

<p>As said, this implementation is pretty naive and can definitely be improved:
but with a couple classes and basic logic you are able to write a powerful
tool that doesn't require a web frontend and runs directly from the command line
with a pure implementation in PHP, thanks to the Symfony2 components.</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>The Process component will be used to execute shell commands directly from PHP <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>Tip: if you want, you can add the code to show the user another dialog to indicate the dependency version, and use master as a fallback <a href='#fnref:2' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Launching PHPUnit tests from a browser with Symfony2]]></title>
    <link href="http://odino.org/launching-phpunit-tests-from-a-browser-with-symfony2/"/>
    <updated>2012-02-20T13:41:00+04:00</updated>
    <id>http://odino.org/launching-phpunit-tests-from-a-browser-with-symfony2</id>
    <content type="html"><![CDATA[<p><ol class="aseries">
	<p>This post is part of the "<strong>Symfony2 components in your own userland</strong>" series; here is a list of all the articles contained this series:</p>
	<li>
		<a href="/using-the-symfony2-dependency-injection-container-as-a-standalone-component/">Using the Symfony2 Dependency Injection Container as a standalone component</a>
	</li>
	<li>
		<a href="/launching-phpunit-tests-from-a-browser-with-symfony2/">Launching PHPUnit tests from a browser with Symfony2</a>
	</li>
	<li>
		<a href="/install-composer-dependencies-with-the-symfony2-cli/">Using the Console component to write an interactive installer for Composer</a>
	</li>
</ol>
</p>

<p>Today we are going to launch interactive PHPUnit tests thanks to the
Symfony2 <a href="https://github.com/symfony/Process">Process</a> component.</p>

<!-- more -->


<h2>Premise</h2>

<p>This article will show you how to build a script to run your unit tests
from a browser and render the output to the webpage: since the aim
of this series of articles is to show you how easily you can integrate
Symfony2 code into your own projects, I will use nasty scripts to
accomplish our requirements.</p>

<h2>The approach</h2>

<p>Our approach will be very basic and dummy: we are goint to execute a shell
command from PHP, write each output buffers into a file and poll the file
from the frontend to progressively read its content.</p>

<h2>Into the mix</h2>

<p>To do so, let's create a JS-loving <code>index.php</code> file:</p>

<p>``` html The entry point of out application
<html>
  <body></p>

<pre><code>&lt;h1&gt;PHPUnit web tests&lt;/h1&gt;
&lt;a href="#" id="run"&gt;
  Run tests
&lt;/a&gt;
&lt;div id="output"&gt;&lt;/div&gt;

&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
  $(document).ready(function(){
    var getOutput = function(){
      $.ajax({
        url: "output.php",
        success: function(data) {
          $('#output').html(data.content);

          if (data.stop != 1) {
            getOutput();
          }
        }
      });
    };
    $('#run').click(function(){
      $.ajax({
        url: "process.php",
      });
      getOutput();
    });
  });
&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>As you see, as you click on the <code>Run tests</code> link you will fire an event that:</p>

<ul>
<li>makes a <code>GET</code> call to <code>process.php</code></li>
<li>makes a recursive <code>GET</code> request to <code>output.php</code>, until the output object
does not contain the <code>stop</code> attribute</li>
</ul>


<p>The output script is really easy:</p>

<p>``` php
&lt;?php</p>

<p>$fileName = sys_get_temp_dir() . '/test.output.txt';
header('Content-Type: application/json');</p>

<p>if (file_exists($fileName)) {
  $f = file_get_contents(sys_get_temp_dir() . '/test.output.txt');</p>

<p>  echo json_encode(array('content' => $f));<br/>
} else {
  $f = file_get_contents(sys_get_temp_dir() . '/test.output.txt.f');</p>

<p>  echo json_encode(array('content' => $f, 'stop' => 1));
  unlink($f);
}
```</p>

<p>As you see, each time we call this script, it reads the content of the <code>test.output.txt</code>
file in the temporary directory of your system: if it doesn't find it, it reads the
<code>test.output.txt.f</code> file<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>.</p>

<h2>Enter Process</h2>

<p>In our final step, let's install the Process component:</p>

<p>``` bash composer.json
{</p>

<pre><code>"require": {
    "php": "&gt;=5.3.2",
    "symfony/process": "2.0.10"
}
</code></pre>

<p>}</p>

<p>```</p>

<p>```
wget http://getcomposer.org/composer.phar</p>

<p>php composer.phar install
```</p>

<p>then we can create our <code>process.php</code> script:</p>

<p>``` php
&lt;?php</p>

<p>require <strong>DIR</strong> . '/vendor/.composer/autoload.php';</p>

<p>use Symfony\Component\Process\Process;</p>

<p>$file = sys_get_temp_dir() . '/test.output.txt';</p>

<p>$handle   = fopen($file, 'w+');
$process  = new Process('phpunit -c /home/foor/bar/phpunit.xml /home/foo/bar');
$process->run(function ($type, $buffer) use($handle) {
  fwrite($handle, nl2br($buffer));
});</p>

<p>fclose($handle);</p>

<p>rename($file, $file . ".f");
```</p>

<p>As you see we are launching the test suite and, at each buffer, thanks to a
lambda, we write a new chunk to the file: at the end of the process the
<code>txt</code> file gets renamed, so the <code>output.php</code> script knows that it needs to
notify the frontend that he's not required to poll it anymore, adding
the <code>stop</code> attribute to the JSON object it outputs:</p>

<p>``` php fragment of output.php
&lt;?php</p>

<p>echo json_encode(array('content' => $f, 'stop' => 1));
```</p>

<p><img class="center" src="/images/phpunit-process.png"></p>

<h2>Benefits from the Process component</h2>

<p><blockquote><p>I can do that crap with shell_exec() too!</p></blockquote></p>

<p>There are some advantages of using Process instead of writing your own command
executor: first of all, if you don't want to take care of the subtle <strong>differences
between the different platforms</strong> everything is done for you;
then <strong>error handling becomes very easy</strong> since you are able to catch all the buffers:</p>

<p>``` php
&lt;?php
...</p>

<p>$process->run(function ($type, $buffer) {</p>

<pre><code>if ('err' === $type) {
    echo 'Something nasty happened';
          syslog(LOG_ERR, $buffer);
} else {
    echo $buffer;
}
</code></pre>

<p>});
```</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>Flaw here: no error handling when the .f file is not found <a href='#fnref:1' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using the Symfony2 DIC as a standalone component]]></title>
    <link href="http://odino.org/using-the-symfony2-dependency-injection-container-as-a-standalone-component/"/>
    <updated>2012-02-15T20:06:00+04:00</updated>
    <id>http://odino.org/using-the-symfony2-dependency-injection-container-as-a-standalone-component</id>
    <content type="html"><![CDATA[<p><ol class="aseries">
	<p>This post is part of the "<strong>Symfony2 components in your own userland</strong>" series; here is a list of all the articles contained this series:</p>
	<li>
		<a href="/using-the-symfony2-dependency-injection-container-as-a-standalone-component/">Using the Symfony2 Dependency Injection Container as a standalone component</a>
	</li>
	<li>
		<a href="/launching-phpunit-tests-from-a-browser-with-symfony2/">Launching PHPUnit tests from a browser with Symfony2</a>
	</li>
	<li>
		<a href="/install-composer-dependencies-with-the-symfony2-cli/">Using the Console component to write an interactive installer for Composer</a>
	</li>
</ol>
</p>

<p>The <a href="https://github.com/symfony/symfony/tree/master/src/Symfony/Component">Symfony2 components</a> are powerful libraries that you can easily integrate in your own code: in this article we will se how to integrate the <a href="https://github.com/symfony/DependencyInjection#readme">dependency injection container</a> in a <em>framework-free</em> PHP small library.</p>

<!-- more -->


<h2>Premise</h2>

<p>have you ever heard about the <a href="http://en.wikipedia.org/wiki/QOTD">QOTD protocol</a><sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>?</p>

<p>It's a <a href="http://www.ietf.org/rfc/std/std23.txt">standard</a> protocol, defined in
<a href="http://tools.ietf.org/html/rfc865">RFC-0865</a>, for a dummy client/server interaction that allows
a server to listen on port 17 and emit a quote in ASCII text whenever a connection
is opened by a client.</p>

<p>To give you an example, try this from the command line<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>:</p>

<p><code>
telnet alpha.mike-r.com 17
</code></p>

<p><blockquote><p>First love is only a little foolishness and a lot of curiosity, no<br/>really self-respecting woman would take advantage of it.</p><footer><strong>George Bernard Shaw</strong> <cite><a href='http://alpha.mike-r.com'>alpha.mike-r.com</a></cite></footer></blockquote></p>

<p>So today we are going to see how to implement a QOTD script in PHP, using Symfony2's
DIC: the mini-library that we are going to write is dummy and really easy, so you won't
get lost following its flow; I won't use any autoloader - apart for the DIC stuff - so
the code will exactly look like the ancient PHP, the one you daily need to refactor.</p>

<h2>QOTD scripts</h2>

<p>We have 3 scripts that compose our small library; the first one is the entry point:</p>

<p>``` php index.php
&lt;?php</p>

<p>require 'QOTD.php';</p>

<p>$qotd = new QOTD();
echo $qotd->enchantUs() . "\n";
```</p>

<p>and then the QOTD class:</p>

<p>``` php Quotes Of The Day generator class
&lt;?php</p>

<p>class QOTD
{
  protected $wtfMode;
  protected $quotes = array(</p>

<pre><code>  "michael jordan" =&gt; array(
      "Always turn a negative situation into a positive situation",
      "I can accept failure, everyone fails at something. But I can't accept not trying"
  ),
  "Mahatma Gandhi"  =&gt; array(
      "A coward is incapable of exhibiting love; it is the prerogative of the brave"
  ),
</code></pre>

<p>  );</p>

<p>  public function __construct($wtfMode = false)
  {</p>

<pre><code>  $this-&gt;wtfMode = $wtfMode;
</code></pre>

<p>  }</p>

<p>  public function enchantUs()
  {</p>

<pre><code>  $authorQuotes = $this-&gt;quotes[array_rand($this-&gt;quotes)];

  if ($this-&gt;wtfMode === true &amp;&amp; is_int(time(true)/2)) {
    return "WTFed!!!";
  }

  return $authorQuotes[array_rand($authorQuotes)];
</code></pre>

<p>  }
}
```</p>

<p>As you see, the implementation is trivial: we have an array of <code>$quotes</code> and in the <code>enchantUs()</code>
method we extract a random quote from that array: note that there is a boolean parameter
- in the constructor - which enables or disables the <code>WTF mode</code>; when the mode is active, if</p>

<p>``` php
&lt;?php</p>

<p>is_int(time(true)/2)
```</p>

<p>is true the QOTD class will output <code>WTFed!!!</code> instead of the usual quote from <code>$quotes</code>.</p>

<p>Let's say that we also want to creare a class for Michael Jordan's quotes:</p>

<p>``` php Michael Jordan quotes
&lt;?php</p>

<p>class JordanQOTD extends QOTD
{
  protected $quotes = array(</p>

<pre><code>  "michael jordan" =&gt; array(
      "Always turn a negative situation into a positive situation",
      "I can accept failure, everyone fails at something. But I can't accept not trying"
  ),
</code></pre>

<p>  );
}
```</p>

<p>which basically restricts the <code>$quotes</code> to MJ's ones<sup id='fnref:3'><a href='#fn:3' rel='footnote'>3</a></sup>.</p>

<p>If we want to change the class used to output quotes, we just need to edit the <code>index.php</code>:</p>

<p>``` php index.php
&lt;?php</p>

<p>require 'QOTD.php';
require 'JordanQOTD.php';</p>

<p>$qotd = new JordanQOTD();
echo $qotd->enchantUs() . "\n";
```</p>

<h2>Enter Symfony2 Dependency Injection Container</h2>

<p>The boss just told us that we'll need to implement some more <em>modes</em> and lots of
person-specific quote classes, with some other logic to decide which QOTD class
to use and so on: your first decision is to try to parametrize the configuration
of the QOTD "service", using a DIC ; although the problem and its design are quite
simple, it would be a good choice to have a single, central point to manage
services used in your code and their configuration.</p>

<p>First of all, create a <code>composer.json</code> file in the root of your project, to manage
the dependency to the DIC:</p>

<p>``` bash composer.json
{</p>

<pre><code>"require": {
    "php": "&gt;=5.3.2",
    "symfony/dependency-injection": "2.0.10"
}
</code></pre>

<p>}
```</p>

<p>then download Composer and install the DIC:</p>

<p>```
wget http://getcomposer.org/composer.phar</p>

<p>php composer.phar install
```</p>

<p>Now you can edit the <code>index.php</code> to add some configuration:</p>

<p>``` php index.php
&lt;?php</p>

<p>require <strong>DIR</strong> . '/vendor/.composer/autoload.php';
require 'QOTD.php';
require 'JordanQOTD.php';
require 'container.php';</p>

<p>echo $container->get('QOTD')->enchantUs() . "\n";
```</p>

<p>The <code>container.php</code> uses the Symfony2 DIC to register a <code>QOTD</code> service with
a <code>QOTD.mode</code> argument:</p>

<p>``` php configuration of the container
&lt;?php</p>

<p>use Symfony\Component\DependencyInjection\ContainerBuilder;</p>

<p>$container = new ContainerBuilder();
$container->register('QOTD', '%qotd.class%')</p>

<pre><code>      -&gt;addArgument('%QOTD.mode%');
</code></pre>

<p>$container->setParameter('qotd.class', 'QOTD');
$container->setParameter('QOTD.mode', false);
```</p>

<p>For example, we can modify the configuration to enable the WTF mode:</p>

<p>``` php enabling WTF mode
&lt;?php</p>

<p>use Symfony\Component\DependencyInjection\ContainerBuilder;</p>

<p>$container = new ContainerBuilder();
$container->register('QOTD', '%qotd.class%')</p>

<pre><code>      -&gt;addArgument('%QOTD.mode%');
</code></pre>

<p>$container->setParameter('qotd.class', 'QOTD');
$container->setParameter('QOTD.mode', true);
```</p>

<p>or to change the service class, to only output MJ's quotes:</p>

<p>``` php changing the service class
&lt;?php</p>

<p>use Symfony\Component\DependencyInjection\ContainerBuilder;</p>

<p>$container = new ContainerBuilder();
$container->register('QOTD', '%qotd.class%')</p>

<pre><code>      -&gt;addArgument('%QOTD.mode%');
</code></pre>

<p>$container->setParameter('qotd.class', 'JordanQOTD');
$container->setParameter('QOTD.mode', false);
```</p>

<p>As you might understand, with a DIC it's possible to drastically <strong>change the
behaviour of your application</strong> editing a configuration file, with a bunch of
additional lines of code into your own application; another great thing is that
you can also use different "languages" to configure the DIC, for example YAML.</p>

<p>To do so, add the required dependency to composer:</p>

<p>``` bash composer.json
{</p>

<pre><code>"require": {
    "php": "&gt;=5.3.2",
    "symfony/dependency-injection": "2.0.10",
    "symfony/config": "2.0.10",
    "symfony/yaml": "2.0.10"
}
</code></pre>

<p>}
```</p>

<p><code>
php composer.phar update
</code></p>

<p>then edit the <code>container.php</code>:</p>

<p>``` php
&lt;?php</p>

<p>use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\YamlFileLoader;
use Symfony\Component\Config\FileLocator;</p>

<p>$container = new ContainerBuilder();
$container->register('QOTD', '%qotd.mode%')</p>

<pre><code>      -&gt;addArgument('%mode%');
</code></pre>

<p>$loader = new YamlFileLoader($container, new FileLocator(<strong>DIR</strong>));
$loader->load('container.yml');
```</p>

<p>and then configure the DIC creating a <code>container.yml</code>:</p>

<p>```
services:
  QOTD:</p>

<pre><code>class: QOTD
arguments:
  mode: true
</code></pre>

<p>```</p>

<p><a href="http://en.wikipedia.org/wiki/INI_file">INI</a> is another - not documented in
<a href="http://symfony.com/doc/current/book/service_container.html">Symfony2's docs</a> - option:</p>

<p>``` php
&lt;?php</p>

<p>use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\IniFileLoader;
use Symfony\Component\Config\FileLocator;</p>

<p>$container = new ContainerBuilder();
$container->register('QOTD', '%qotd.class%')</p>

<pre><code>      -&gt;addArgument('%qotd.mode%');
</code></pre>

<p>$loader = new IniFileLoader($container, new FileLocator(<strong>DIR</strong>));
$loader->load('container.ini');
```</p>

<p><code>ini
[parameters]
  qotd.class = "QOTD"
  qotd.mode = 1
</code></p>

<p>There you go: with a few lines you have a completely working instance of the
Symfony2 dependency injection container: organizing dependencies and services'
instantiation becomes very easy with this kind of layer and, since its
implementation is trivial, I recommend you to gain familiarity with this
component.</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>Quote Of The Day <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>alpha-mike is the only known public service that implements QOTD protocol <a href='#fnref:2' rev='footnote'>↩</a></li><li id='fn:3'>This is not an optimal design for resolving such this kind of thing, but we'll use it as it's fairly simple to understand <a href='#fnref:3' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Symfony2, HTTP cache & the good parts of both of'em]]></title>
    <link href="http://odino.org/symfony-2-http-cache/"/>
    <updated>2011-05-15T23:27:00+04:00</updated>
    <id>http://odino.org/symfony-2-http-cache</id>
    <content type="html"><![CDATA[<p>If you missed my talk about HTTP caching and Symfony2 at the PHPDay, here are the slides that I published friday.</p>

<!-- more -->


<p><div class="slideshare" id="__ss_7954490"><iframe src="http://www.slideshare.net/slideshow/embed_code/7954490 " width="800" height="720" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Re-doing things with Symfony2]]></title>
    <link href="http://odino.org/re-doing-things-with-symfony2/"/>
    <updated>2011-03-13T10:46:00+04:00</updated>
    <id>http://odino.org/re-doing-things-with-symfony2</id>
    <content type="html"><![CDATA[<p>At the end I realized I should re-write this website with the latest ( not stable ) version of my favourite framework: Symfony2.</p>

<p>I downloaded the PR7 and started converting the old Sf1.x application to Symfony2: since I had really cool impressions, and since I made a few mistakes, I want to share a few considerations.</p>

<!-- more -->


<h2>What's the stack?</h2>

<p><img class="right" src="/images/symfony2.png"></p>

<p>The Symfony2 version is the PR7, as I said, while I used, for the first time, Twig.</p>

<p>I mapped a single entity, <a href="https://github.com/odino/odino_org/blob/master/src/Odino/BlogBundle/Entity/Content.php">Content</a>, through Doctrine2.</p>

<p>The backend is still the one made with symfony 1.4, since I had no reason at all to spend time on a backend without the admin generator.</p>

<p>I heavily used the HTTP caching headers: that's basically why I decided to move this site to Symfony2; I will monitor the stats of this VPS in order to get some conclusions in a few days.</p>

<h2>Twig</h2>

<p>That's amazing.</p>

<p>Templates become <a href="https://github.com/odino/odino_org/blob/master/src/Odino/BlogBundle/Resources/views/Default/tags.html.twig#L10">declarative</a> is a second.</p>

<p>Something we will definitely appreciate are the filters and the tests..</p>

<p>The filters are a way to format a variable:</p>

<p><code>
article.publishedDate | date
</code></p>

<p>and they become powerful when you think that, behind the scenes, Twig is purely OO, so you can plug it with stuff like:</p>

<p><code>
article.title | slug
</code></p>

<p>The <strong>testers</strong> are another really cool thing.</p>

<p>As far as I undertood, they follow a is statement:</p>

<p><code>
if article.id is odd
</code></p>

<p>Again, really powerful when you think at:</p>

<p><code>

{% if author.country is european %}
...
{% if article.date is summer %}

</code></p>

<p>However, I've made a few mistakes with the templates, because I didn't find a way to avoid the duplication of <a href="https://github.com/odino/odino_org/blob/master/src/Odino/BlogBundle/Resources/views/Default/content.html.twig#L3">declaring the metatags</a> in every single template.</p>

<h2>Controllers</h2>

<p>I practically have a <a href="https://github.com/odino/odino_org/blob/master/src/Odino/BlogBundle/Controller/BlogController.php">single controller</a>, which handles the whole blog.</p>

<p>Since I wanted to deploy the blog as faster as I could, I decided to have <strong>fat controllers</strong> without using the <strong>repository pattern</strong>, which is the one we will use for high-value code.</p>

<p><a href="https://github.com/odino/odino_org/blob/master/src/Odino/BlogBundle/Controller/BlogController.php#L82">Mapping your routes with the annotations</a>, well, that is awesome: since the routing gets compiled down into the cache the overhead is really small.</p>

<p>Be aware that if you have <a href="https://github.com/odino/odino_org/blob/master/src/Odino/BlogBundle/Controller/BlogController.php#L140">multiple parameters in the route</a>, you must specify the requirements, otherwise <strong>mess will come</strong>.</p>

<p>I wrote tons of LoCs in the controller, but with the annotations you should be able to let the controller only fetch stuff from the DB (without even specifying the <a href="http://bundles.symfony-reloaded.org/frameworkextrabundle/annotations/view.html#usage">template rendering</a> LoCs in PHP).</p>

<h2>Querying the database</h2>

<p>The fact that you can use <a href="https://github.com/odino/odino_org/blob/master/src/Odino/BlogBundle/Controller/BlogController.php#L92">N placeholders</a> for the query variables is really good, and the whole API hasn't changed so much from Doctrine 1.2.</p>

<h2>Conclusions</h2>

<p>I've boiled a few spaghetti on GitHub this weekend, but I'm pretty satisfied that I know where I failed and why ( were we speaking about high-value code? ;-) ).</p>

<p>Symfony2 seems amazing, as I said <a href="http://www.odino.org/268/creating-your-own-services-for-the-symfony2-dic">looking at the DIC</a>.</p>

<p>Other conclusions, dealing with the HTTP cache and server resources, will come in a few days...</p>

<h2>Ah, wait!</h2>

<p>If you find that something is broken, tell me in the comments or wherever!</p>
]]></content>
  </entry>
  
</feed>
