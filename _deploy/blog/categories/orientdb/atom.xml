<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Category: OrientDB | Alessandro Nadalin]]></title>
  <link href="http://odino.org/blog/categories/orientdb/atom.xml" rel="self"/>
  <link href="http://odino.org/"/>
  <updated>2014-02-28T21:04:06-05:00</updated>
  <id>http://odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OrientDB, the Fastest Document-based Graph Database]]></title>
    <link href="http://odino.org/orientdb-the-fastest-document-based-graph-database/"/>
    <updated>2014-02-26T15:25:00-05:00</updated>
    <id>http://odino.org/orientdb-the-fastest-document-based-graph-database</id>
    <content type="html"><![CDATA[<p>Today I gave the first of my talks here at the 2014 edition
of the confoo in Montreal, &ldquo;<a href="http://www.slideshare.net/odino/orientdb-the-fastest-documentbased-graph-database-confoo-2014-in-montreal-ca">OrientDB, the fastest
document-based graphdb</a>&rdquo;.</p>

<!-- more -->


<p>For the ones interested in the slides, I am also publishing them,
as usual, here:</p>

<p><div class="slideshare" id="__ss_31683783"><iframe src="http://www.slideshare.net/slideshow/embed_code/31683783 " width="850" height="650" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Starting to Play With the Doctrine OrientDB ODM]]></title>
    <link href="http://odino.org/starting-to-play-with-the-doctrine-orientdb-odm/"/>
    <updated>2013-01-20T23:00:00-05:00</updated>
    <id>http://odino.org/starting-to-play-with-the-doctrine-orientdb-odm</id>
    <content type="html"><![CDATA[<p>Since I am actively playing around with it, I
wanted to share some snippets to use the
<a href="https://github.com/doctrine/orientdb-odm">Doctrine OrientDB ODM</a>
in your PHP applications.</p>

<!-- more -->


<h2>Prelude</h2>

<p>In the last few weeks I&rsquo;ve started working,
for fun <strong>and</strong> profit, to a personal project,
nothing really exciting as of now.</p>

<p>The thing is, since I wanted to get back on some
cool piece of software, I decided to go for
OrientDB for the persistence and a
mini-framework <em>a-la</em> Symfony2 as foundation for the
PHP application &ndash; I actually considered NodeJS first,
but I need a prototype in 2 months so&hellip;</p>

<p>Point being, I&rsquo;d like to share with you my basic
approach to the OrientDB ODM.</p>

<h2>The container</h2>

<p>Given I&rsquo;ve been inspired to Symfony2,
instantiating the main ODM classes
happens in the DIC:</p>

<p>``` yml container.yml
services:
  orientdb.binding.parameters:</p>

<pre><code>class: Doctrine\OrientDB\Binding\BindingParameters
arguments:
  host:     127.0.0.1
  port:     2480
  username: admin
  password: admin
  database: DBNAME
</code></pre>

<p>  orientdb.binding:</p>

<pre><code>class: Doctrine\OrientDB\Binding\HttpBinding
arguments:
  parameters: @orientdb.binding.parameters
</code></pre>

<p>  odm:</p>

<pre><code>class: Doctrine\ODM\OrientDB\Manager
arguments:
  mapper: @odm.mapper
  binding: @orientdb.binding
</code></pre>

<p>  odm.mapper:</p>

<pre><code>class: Doctrine\ODM\OrientDB\Mapper
arguments:
  documentProxyDirectory: %base-dir%/tmp/
  annotationReader: @odm.annotation-reader
calls:
  - [setDocumentDirectories, [ %base-dir%/src/PROJECT/Entity/ : "PROJECT\Entity" ] ]
</code></pre>

<p>  odm.annotation-reader:</p>

<pre><code>class: Doctrine\ODM\OrientDB\Mapper\Annotations\Reader
arguments:
  cacheReader: @cache.array
</code></pre>

<p>  cache.array:</p>

<pre><code>class: Doctrine\Common\Cache\ArrayCache    
</code></pre>

<p>parameters:
  base-dir: /Users/odino/Sites/PROJECT
```</p>

<p>As you see, you need:</p>

<ul>
<li>the <code>Manager</code>, which requires a <code>Mapper</code> and a connection to
OrientDB through a binding class implementing the
<code>Doctrine\OrientDB\Binding\BindingInterface</code></li>
<li>the <code>Mapper</code>, which requires a directory where it can write
proxy classes (for lazy loading), and an annotation reader
(this is not required, I&rsquo;ll explain it later), plus a source
directory to locate entities</li>
<li>the <code>HttpBinding</code>, used by the <code>Manager</code>, that does raw
queries to the OrientDB server</li>
<li>the <code>Annotations\Reader</code></li>
<li>a cache implementing the interface <code>Doctrine\Common\Cache\Cache</code>:
in dev environments it is needed since <code>ApcCache</code> is the default
one, and you would need to flush APC every time you change an
annotation in your entities (we will probably change it and put
<code>ArrayCache</code> by default, so that you will need to tweak the live
environment, not the dev one)</li>
</ul>


<h2>Autoloading</h2>

<p>The autoloading is straightforward, thanks to the <code>PSR-0</code>; the
only thing that you should keep in mind is that you will need
to specify a separate autoloader for proxy classes, since they can
be generated wherever you want (ideally, in a temporary folder,
since they should be removed every time you deploy):</p>

<p>```php autoload.php
&lt;?php</p>

<p>require_once <strong>DIR</strong>.&lsquo;/../vendor/symfony/symfony/src/Symfony/Component/ClassLoader/UniversalClassLoader.php&rsquo;;</p>

<p>use Symfony\Component\ClassLoader\UniversalClassLoader;</p>

<p>$loader = new UniversalClassLoader();</p>

<p>$loader->registerNamespaces(array(</p>

<pre><code>'Symfony'                       =&gt; __DIR__.'/../vendor/symfony/symfony/src',
'Doctrine\Common'               =&gt; __DIR__.'/../vendor/doctrine/common/lib',
'Doctrine\OrientDB'             =&gt; __DIR__.'/../vendor/doctrine/orientdb-odm/src',
'Doctrine\ODM\OrientDB'         =&gt; __DIR__.'/../vendor/doctrine/orientdb-odm/src',
'Doctrine\OrientDB\Proxy'       =&gt; __DIR__.'/../tmp',
</code></pre>

<p>));</p>

<p>$loader->register();
```</p>

<p>You should set the autoloader for <code>Doctrine\OrientDB\Proxy</code>
accordingly to the argument <code>documentProxyDirectory</code> of the
<code>odm.mapper</code> service.</p>

<h2>Entities</h2>

<p>Following what we specified in the <code>container.yml</code>,
entities should be located in
<code>%base-dir%/src/PROJECT/Entity/</code> and follow the namespace
<code>PROJECT\Entity</code>:</p>

<p>```php
&lt;?php</p>

<p>namespace PROJECT\Entity;</p>

<p>use Doctrine\ODM\OrientDB\Mapper\Annotations as ODM;</p>

<p>/<em>*
* @ODM\Document(class=&ldquo;user&rdquo;)
</em>/
class User
{</p>

<pre><code>/**
 * @ODM\Property(name="@rid", type="string")
 */
protected $rid;

/**
 * @ODM\Property(type="string")
 */
protected $email;

/**
 * @ODM\Property(type="string", notnull="false")
 */
protected $nick;

/**
 * @ODM\Property(type="linklist")
 */
protected $addresses;

/**
 * Returns the nickname of the user, or his email if he has no nick set.
 * 
 * @return string
 */
public function getNick()
{
    return $this-&gt;nick ?: $this-&gt;getEmail();
}

public function setNick($nick)
{
    $this-&gt;nick = $nick;
}

public function getEmail()
{
    return $this-&gt;email;
}

public function setEmail($email)
{
    $this-&gt;email = $email;
}

public function getAddresses()
{
    return $this-&gt;addresses;
}

public function setAddresses($adresses)
{
    $this-&gt;addresses = $addresses;
}

public function getRid()
{
    return $this-&gt;rid;
}

public function setRid($rid)
{
    $this-&gt;rid = $rid;
}
</code></pre>

<p>}
```</p>

<p>As you see, mapping an entity is pretty easy:
the first annotation is at class level, to define
which OrientDB classes are mapped by the entity,
then for every property that you want to be
persisted / hydrated, you define another annotation and
public getters / setters; if you want the property to be
public, you dont need getters / setters.</p>

<p>The property-level annotation has 3 parameters:</p>

<ul>
<li><strong>type</strong>: defines the type of the property in OrientDB
( <code>boolean</code>, <code>link</code>, <code>linklist</code>, <code>string</code>, <code>integer</code>, etc )</li>
<li><strong>name</strong>: the name of the attribute in the OrientDB class
(you might have a PHP property called <code>$createdAt</code> and in OrientDB
you call it <code>created_at</code>)</li>
<li><strong>notnull</strong>: defines whether the property can be <code>null</code> or not<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup></li>
</ul>


<h2>What about controllers?</h2>

<p>You can access the ODM from within
controllers of your application by
just using the container:</p>

<p>``` php PROJECT/Controller/User.php
&lt;?php</p>

<p>namespace PROJECT\Controller;</p>

<p>use Project\Entity\User;</p>

<p>class UserController
{</p>

<pre><code>public function somethingAction()
{
    $user       = new User();
    $manager    = $this-&gt;getService('odm');

    $manager-&gt;...
}
</code></pre>

<p>}
```</p>

<h2>Repositories</h2>

<p>At this point, after boostrapping the environment and creating your first entity,
you might want to play with the repository in your controllers, to
manipulate and retrieve collections:</p>

<p>``` php PROJECT/Controller/User.php
&lt;?php</p>

<p>$manager        = $this->getService(&lsquo;odm&rsquo;);
$userRepository = $manager->getRepository(&lsquo;PROJECT\Entity\User&rsquo;)
```</p>

<p>then, with the repository, you can start retrieving objects:</p>

<p>``` php Using the repository
&lt;?php</p>

<p>// find all users
$userRepository->findAll();</p>

<p>// find one user given its RID
$userRepository->find($rid);</p>

<p>// find all users with the nick &ldquo;overlord&rdquo;
$userRepository->findByNick(&ldquo;overlord&rdquo;);</p>

<p>// find the user with the nick &ldquo;TheOnlyOverlord&rdquo;
$userRepository->findOneByNick(&ldquo;TheOnlyOverlord&rdquo;);</p>

<p>// find jack&rsquo;s wife
$jack  = $userRepository->findOneByName(&ldquo;Jack&rdquo;);
$wifey = $userRepository->findOneBySpouse($jack); // spouse is an attribute of type &ldquo;link&rdquo;
```</p>

<p>and it&rsquo;s not over, since you can, of course, add
<strong>custom repository classes</strong>.</p>

<p>Custom repositories must be located in the entity&rsquo;s folder
and follow the naming convention <code>EntitytheymapRepository</code>:
for our <code>User</code> entity, we would need to create a <code>UserRepository</code>
class in <code>%base-dir%/src/PROJECT/Entity/</code>:</p>

<p>``` php PROJECT\Entity\UserRepository
&lt;?php</p>

<p>namespace PROJECT\Entity;</p>

<p>use Doctrine\ODM\OrientDB\Repository;</p>

<p>class UserRepository extends Repository
{</p>

<pre><code>/**
 * Retrieves a random user.
 * 
 * @return \PROJECT\Entity\User
 */
public function findRandomUser()
{
    return array_rand($this-&gt;findAll());
}
</code></pre>

<p>}
```</p>

<p>so then you can call your new methods over repositories:</p>

<p>``` php Using custom repositories
&lt;?php</p>

<p>$manager->getRepository(&lsquo;PROJECT\Entity\User&rsquo;)&ndash;>findRandomUser();
```</p>

<h2>Can I haz raw queries?</h2>

<p>Entities and repositories are good, but what about
adding some <code>SQL+</code><sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup> to the mix?</p>

<p>That&rsquo;s very easy, thanks to the <strong>query builder</strong>
that&rsquo;s packed with the ODM:</p>

<p>``` php Example queries
&lt;?php</p>

<p>use Doctrine\OrientDB\Query\Query;</p>

<p>// instantiate a query object
$query = new Query();</p>

<p>// simple SELECT
$query->from(array(&lsquo;user&rsquo;))&ndash;>where(&lsquo;nick = ?&rsquo;, $nick);</p>

<p>// throwing some spice into the mix
$query->orWhere(&lsquo;attribute = ?&rsquo;, $attribute)</p>

<pre><code>  -&gt;orWhere('(this IS NULL OR that IS NOT NULL)')
  -&gt;limit(10)
  -&gt;orderBy(...);
</code></pre>

<p>// SELECTing a single record
$query->from(array($rid));</p>

<p>// SELECTing two records
$query->from(array($rid1, $rid2));
```</p>

<p>When you manipulate the <code>$query</code> object you are basically
creating an SQL query with an object-oriented fluent interface;
to eventually execute the query, just pass the object to
the <code>Manager</code>:</p>

<p>``` php Executing a query
&lt;?php</p>

<p>$query = new Query();
$query->from(array(&lsquo;user&rsquo;))&ndash;>where(&lsquo;gender = ?&rsquo;, &ldquo;male&rdquo;);</p>

<p>$males = $manager->execute($query);
```</p>

<h2>Point being, how do you save data?</h2>

<p>Since persistence is not already handled by the <code>Manager</code>,
you will need to use raw queries for now:</p>

<p>``` php Saving data
&lt;?php</p>

<p>$user = array(
  &lsquo;name&rsquo; => &lsquo;Jack&rsquo;
);</p>

<p>$query = new Query();
$query->insert()&ndash;>into(&lsquo;user&rsquo;)&ndash;>fields(array_keys($user))&ndash;>values($user);</p>

<p>$manager->execute($query);
```</p>

<h2>From the trenches</h2>

<p>We&rsquo;ve been very active since a couple months,
and we&rsquo;ve actually been able to roll out some major
bugfixes and improvements (more than 10 in the last
few weeks):</p>

<ul>
<li>repositories <a href="https://github.com/doctrine/orientdb-odm/issues/138">filtering by multiple criterias</a></li>
<li><a href="https://github.com/doctrine/orientdb-odm/issues/139">custom repository</a> classes</li>
<li>added ability to <a href="https://github.com/doctrine/orientdb-odm/issues/141">map timestamps</a> as DateTime objects</li>
<li>unable to <a href="https://github.com/doctrine/orientdb-odm/issues/144">update attributes if they are a collection</a></li>
<li>support for <a href="https://github.com/doctrine/orientdb-odm/commit/cbd9c3250d1fd6fc7ec1f39566b91d1f0e1531f2">INSERTing collections</a></li>
<li>proxy classes dont <a href="https://github.com/doctrine/orientdb-odm/issues/147">import signatures</a></li>
<li><code>findBy*</code> and <code>findOneBy*</code> <a href="https://github.com/doctrine/orientdb-odm/issues/149">&ldquo;magic&rdquo; methods</a></li>
<li><a href="https://github.com/doctrine/orientdb-odm/issues/150">fetchplans in <code>find*</code></a> methods of repositories</li>
<li>following <code>SQL+</code>, added <a href="https://github.com/doctrine/orientdb-odm/issues/99"><code>REBUILD INDEX</code> command</a></li>
</ul>


<p>I would not advise you to install one of the old tags,
or even the last one, which brings the namespace
changes for the incubation in the Doctrine
organization, but to install it directly from master
via composer:</p>

<p><code>json
"doctrine/orientdb-odm": "dev-master",
</code></p>

<p>as we are constantly doing bugfixes and so on
(I would day you would get an update &ndash; at least &ndash;
every week).</p>

<p>That is it, now <strong>start playing around!</strong></p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>Be aware that if you are retrieving a property which is NULL in the DB and you don't declare it as NULLable, an exception will be thrown (and there is an issue to improve the exception message https://github.com/doctrine/orientdb-odm/issues/152) <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>OrientDB's QL is called SQL+, as it looks like SQL but has some major improvements, as it's very developer-friendly <a href='#fnref:2' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Please Welcome the Doctrine2 OrientDB ODM]]></title>
    <link href="http://odino.org/please-welcome-the-doctrine-orientdb-odm/"/>
    <updated>2012-12-28T23:12:00-05:00</updated>
    <id>http://odino.org/please-welcome-the-doctrine-orientdb-odm</id>
    <content type="html"><![CDATA[<p>It took almost 2 years from the
<a href="https://github.com/doctrine/orientdb-odm/commit/65929ec57a2e2cb1f4af034d722e17b5339b9d48">first commit</a>,
but <a href="http://www.orientdb.org/">OrientDB</a>&rsquo;s <a href="https://github.com/doctrine/orientdb-odm">PHP ODM</a>
has been finally moved to the
<a href="https://github.com/doctrine/">Doctrine</a>
organization.</p>

<!-- more -->


<h2>New daddy</h2>

<p>I&rsquo;ve blogged <a href="/blog/categories/orientdb/">so many times</a>
about an imminent
integration into the Doctrine ecosystem, but
due to the workload of our contributors and
some major issues we wanted to solve before this,
we were only able to seriously approach the
Doctrine team today.</p>

<p>This is a very good news, as we will be able
to take advantage of the experience of all the
doctrine contributors as well as have a bigger stage
where we can show the ODM: the biggest part of the
ODM is still pending (persistence), but
HTTP binding, query builder and object
hydration are working like a charm, and the few
bugs that we face in <a href="https://github.com/odino/sharah">real-world scenarios</a>
are solved in a matter of minutes.</p>

<h2>And now?</h2>

<p>All the namespaces have been changed, so the old
<code>Congow\Orient</code> has been replaced by
<code>Doctrine\ODM\OrientDB</code> and <code>Doctrine\OrientDB</code>:
if you were already using the library, you will need
to work on the migration a bit.</p>

<p>You may also want to have a look at the new
<a href="https://packagist.org/packages/doctrine/orientdb-odm">Packagist page</a>,
as it contains the references to the new repository.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Video Introduction About NoSQL Graph Databases and OrientDB]]></title>
    <link href="http://odino.org/video-introduction-about-nosql-graph-databases-and-orientdb/"/>
    <updated>2012-12-08T15:56:00-05:00</updated>
    <id>http://odino.org/video-introduction-about-nosql-graph-databases-and-orientdb</id>
    <content type="html"><![CDATA[<p>During October of the last year, me and my ex-colleague David
took some time off to partecipate to the <a href="http://phpcon.pl/2011/pl/">polish PHP Conference</a>
with a talk about graph databases, OrientDB and how to integrate it
in PHP.</p>

<!-- more -->


<p>I recently found out that the videos recorded at the conference
finally made it to Vimeo: enjoy some tarzan english!</p>

<iframe src="http://player.vimeo.com/video/53451968?badge=0" width="720" height="600" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p> <p><a href="http://vimeo.com/53451968">Alessandro Nadalin, David Funaro: Graph databases and PHP: time for serious stuff</a> from <a href="http://vimeo.com/user10854134">PLUG</a> on <a href="http://vimeo.com">Vimeo</a>.</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OrientDB ODM Beta 5: Repositories, Compatibility With 1.2.0 and More Stability]]></title>
    <link href="http://odino.org/orientdb-odm-beta-5-repositories-compatibility-with-1-dot-2-0-and-more-stability/"/>
    <updated>2012-11-23T09:10:00-05:00</updated>
    <id>http://odino.org/orientdb-odm-beta-5-repositories-compatibility-with-1-dot-2-0-and-more-stability</id>
    <content type="html"><![CDATA[<p>It has almost been a baby&rsquo;s delivery, but we eventually made it:
the PHP <a href="http://css.dzone.com/articles/era-object-document-mapping">ODM</a> for <a href="http://code.google.com/p/orient/">OrientDB</a> has finally reached its <strong>5th beta</strong>.</p>

<!-- more -->


<p>Thanks to the huge effort of <a href="http://davidfunaro.com">David Funaro</a> and the push from <a href="https://twitter.com/Ocramius">Marco Pivetta</a> we
have just released the <code>beta-5</code> version of this library, which lets
you work with the infamous GraphDB in PHP: there is a plethora of
changes and some news about the future of the library, so I&rsquo;ll try
to recap a bit what we&rsquo;ve done so far in almost <strong>one year</strong> of
active development.</p>

<h2>Composer</h2>

<p>The entire library (query builder, HTTP binding and ODM) is now
<em>composerified</em> (have a look at the <a href="https://github.com/congow/Orient/blob/beta-5/composer.json#L24">dependencies</a>):
this was an important step since we wanted to completely get
rid of git submodules and embrace this new and &ndash; sorry PEAR &ndash;
finally decent packaging system for PHP.</p>

<h2>Symfony2: gimme MOAR</h2>

<p>We hate the <a href="http://en.wikipedia.org/wiki/Not_invented_here">NIH approach</a>, so whenever there is a library which is tested, decoupled
and does what we need, we tend to use it instead of rewriting from scratch some new
userland code.</p>

<p>This has been the case for our filesystem classes, that &ndash; as they were first very simple
but tended to grow &ndash; have now been replaced with the <a href="http://symfony.com/doc/2.0/components/finder.html">Symfony2 finder</a>.</p>

<p>At the same time we also added the <a href="http://symfony.com/doc/2.0/components/class_loader.html">ClassLoader component</a>, which replaces
our old <a href="https://github.com/congow/Orient/blob/beta-5/test/PHPUnit/bootstrap.php">PSR-0 compatible basic autoloader</a>.</p>

<h2>Compatibility with the stable OrientDB 1.2.0</h2>

<p>OrientDB is stable <a href="http://www.h-online.com/open/news/item/NoSQL-Document-Graph-database-OrientDB-1-0-released-1576260.html">since months</a>,
we couldn&rsquo;t release a version of our library without
upgrading the compatibility to OrientDB (we were still at version <code>1.0-rc6</code>):
we are now compatible with OrientDB <code>1.2.0</code>.</p>

<p>The move has been quite easy thanks to the test suite that we have
built so far, but we are still probably missing a few features
introduced in <code>1.1</code> and <code>1.2</code>: as soon as we will go on with the
library we will map what the OrientDB team has added to the DB &ndash;
for example, <a href="http://nuvolabase.blogspot.com/2012/09/orientdb-supports-functions.html">functions</a>.</p>

<h2>Fetchplans integrated in the Manager</h2>

<p><a href="http://code.google.com/p/orient/wiki/FetchingStrategies">Fetchplans</a> specify the way OrientDB should lazy-load records:
we have now <a href="https://github.com/congow/Orient/commit/57a5c33ebb02ba8c3d738c2abe1de1c27ba4e846">added support to them</a>,
meaning that if you dont want to lazy-load linked records (<code>*:-1</code>),
the ODM is able to read the entire result from OrientDB and
build linked records as PHP objects (or array of objects).</p>

<p>In the <a href="https://github.com/congow/Orient/commit/57a5c33ebb02ba8c3d738c2abe1de1c27ba4e846#L12L74">example</a>,
you see that <code>$post-&gt;comments</code>:</p>

<ul>
<li>is an array (which eventually contains objects)</li>
<li>is not a <code>Proxy\Collection</code>, which would mean it&rsquo;s a collection of lazy-loaded records</li>
</ul>


<p>by just using the correct fetchplan:</p>

<p>``` php
&lt;?php</p>

<p>$post = $this->manager->find(&lsquo;27:0&rsquo;, &lsquo;*:-1&rsquo;);</p>

<p>var_dump($post->getComments(); // an array of objects, no lazy-loading
```</p>

<h2>Repositories</h2>

<p>We implemented the <a href="https://github.com/congow/Orient/blob/beta-5/src/Congow/Orient/ODM/Repository.php">repository pattern</a> &ndash; as
Doctrine 2 does: you are now able to access
virtual collections and retrieve records
through them:</p>

<p>``` php
&lt;?php</p>

<p>use Congow\Orient\ODM\Manager;</p>

<p>$manager    = new Manager(&hellip;);
$repository = $manager->getRepository(&lsquo;Users&rsquo;);</p>

<p>$user = $repository->find($id);
```</p>

<h2>Doctrine persistence</h2>

<p>Since one of our aims is to be as compatible
as possible with Doctrine&rsquo;s ODMs, we integrated
the <a href="https://github.com/congow/Orient/issues/71"><em>Persistence</em> interfaces from Doctrine 2</a>:
most of the methods are not implemented yet (<code>throw new Exception()</code>),
as actual persistence should come in <code>beta-6</code>/<code>rc-1</code>, but
the good news is that when retrieving objects from the DB
you can still use the same APIs that the Doctrine ODMs
provide you.</p>

<h2>Integration tests</h2>

<p>This release was mainly delayed because of
integration tests<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>: we promised a fully-tested
hydration mechanisms (converting DB records in
POPOs) for <code>beta-5</code> and this has been, slowly,
accomplished.</p>

<p><a href="https://github.com/congow/Orient/commit/37cfe0fdad7f0caba2b22cfdce1006ddacfc63e7">Repositories</a>,
<a href="https://github.com/congow/Orient/commit/b3706dfb3470eb27e12c4944e398a5d911fe2598">hydration</a>
and <a href="https://github.com/congow/Orient/issues/68">data types</a>
are now covered by integration tests.</p>

<h2>Refactoring proxies</h2>

<p>The way we <a href="https://github.com/nrk/Orient/commit/0bed0196f83c6048b971accbe2d80f3a8c81c31b">generate proxies</a> is one of the
most interesting parts of the library:
with this release we changed the way we
do it in order to provide
a <strong>more flexible and straightforward
mechanism for doing lazy-loading</strong>.</p>

<p>Usually when you retrieve a record in OrientDB
you won&rsquo;t have related records:</p>

<p>``` bash SELECT FROM Address LIMIT 1
{
  &ldquo;result&rdquo;: [{</p>

<pre><code>    "@type": "d", 
    "@rid": "#19:0", 
    "@version": 6, 
    "@class": "Address", 
    "type": "Residence", 
    "street": "Piazza Navona, 1", 
    "city": "#21:0", 
    "nick": "Luca2"
}
</code></pre>

<p>  ]
}
```</p>

<p>as you see, by default OrientDB doesn&rsquo;t
retrieve the related record (<code>city</code>), but
provides a <em>pointer</em> to that record (the <code>RID</code>).</p>

<p>When you retrieve a record via the <code>Manager</code> class,
the ODM doesn&rsquo;t return you a <a href="https://github.com/congow/Orient/blob/beta-5/test/Integration/Document/Address.php">POPO</a>, but a <a href="https://github.com/congow/Orient/blob/beta-5/test/proxies/Congow/Orient/Proxy/test/Integration/Document/Address.php">proxy class
that overrides the POPO</a>, allowing lazy-loading.</p>

<p>Proxy classes, basically, just call parent methods,
and if the parent method has something to return:</p>

<ul>
<li>if the <em>returnable</em> is a string, an array, etc <strong>or a POPO</strong>, they return it</li>
<li>if the returnable is an <code>AbstractProxy</code> object,
it means that there is a record/collection of records
that have to be loaded from OrientDB with an extra-query</li>
</ul>


<p>``` php Code example to understand lazy-loading
&lt;?php</p>

<h1>A proxy class is returned</h1>

<p>namespace Congow\Orient\Proxy\test\Integration\Document;</p>

<p>class Address extends \test\Integration\Document\Address
{</p>

<pre><code>  public function getCity() {
    $parent = parent::getCity();

    if (!is_null($parent)) {
        if ($parent instanceOf \Congow\Orient\ODM\Proxy\AbstractProxy) {
            return $parent();
        }

        return $parent;
    }
}
public function setCity($city) {
    $parent = parent::setCity($city);

    if (!is_null($parent)) {
        if ($parent instanceOf \Congow\Orient\ODM\Proxy\AbstractProxy) {
            return $parent();
        }

        return $parent;
    }
}
</code></pre>

<p>}</p>

<h1>When calling $address->getCity(), we will actually</h1>

<h1>call the __invoke() method of a Proxy object</h1>

<p>namespace Congow\Orient\ODM;</p>

<p>use Congow\Orient\ODM\Mapper;
use Congow\Orient\ODM\Proxy\AbstractProxy;</p>

<p>class Proxy extends AbstractProxy
{</p>

<pre><code>protected $manager;
protected $rid;
protected $record;

/**
 * Istantiates a new Proxy.
 *
 * @param Mapper $manager
 * @param string $rid
 */
public function __construct(Manager $manager, $rid)
{
    $this-&gt;manager = $manager;
    $this-&gt;rid = $rid;
}

/**
 * Returns the record loaded with the Mapper.
 *
 * @return object
 */
public function __invoke()
{
    if (!$this-&gt;record) {
        $this-&gt;record = $this-&gt;getManager()-&gt;find($this-&gt;getRid());
    }

    return $this-&gt;record;
}
</code></pre>

<p>}
```</p>

<p>As you see, calling the <code>__invoke()</code> method
of a proxied object will make the manager do
an extra-query to retrieve the lazy-loaded record.</p>

<h2>Support of sessions in the HTTP client</h2>

<p><a href="https://github.com/nrk">Daniele Alessandri</a> took his time to add <a href="https://github.com/congow/Orient/pull/118">native support for cookies</a> in the
HTTP client which is used in the native HTTP binding: thanks
to this we can decide whether to re-use an existing session
while querying the DB.</p>

<h2>Simplified requirements</h2>

<p>We have now removed <a href="https://github.com/nrk/Orient/commit/bc8f94e7c07147aec1c0c4ed852b7b9d02f4a96c">APC as a requirement</a> for the library: since it
was an easy fix we thought it makes sense not to force everyone to have
APC installed everywhere<sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup>.</p>

<h2>Contributions</h2>

<p>I&rsquo;ve been pretty busy over the last months, but
the efforts of the already-mentioned Daniele and
David have been <a href="https://github.com/congow/Orient/graphs/contributors?from=2012-03-31&amp;to=2012-11-18&amp;type=c">huge</a>
to release <code>beta-5</code>: I virtually clap my hands
for them, as they are the main reason behind all
of this progress.</p>

<h2>Tests and CI</h2>

<p>As always, green tests: the build is handled by
Travis-CI. Also that one <a href="https://secure.travis-ci.org/#!/congow/Orient">is green</a>.</p>

<h2>Doctrine and beta-6</h2>

<p>David is already working on refactoring the
namespaces to ask the Doctrine team to
integrate the library into their organization:
as agreed months ago, there shouldn&rsquo;t be a big
problem in doing so.</p>

<p>As this will be <strong>the first ODM for a GraphDB</strong>,
everyone is pretty excited about it:</p>

<ul>
<li>we will get more support and contributions for the library itself</li>
<li>it&rsquo;s the first GraphDB that goes into Doctrine and the PHP world &ndash; I mean, <strong>properly</strong></li>
</ul>


<p>After that, we will face the <a href="https://github.com/congow/Orient/issues?milestone=4&amp;page=1&amp;state=open">biggest challenges</a> so far:</p>

<ul>
<li>decoupling ODM, HTTP binding and Query Builder into 3 separate libraries/repositories</li>
<li>refactor a big portion of the codebase according to the feedbacks from the Doctrine community</li>
<li>implement persistence (from POPOs to DB)</li>
</ul>


<p>I&rsquo;m pretty sure the next months will be
productive, intense and full of changes, but
I&rsquo;d realy like to suggest you one thing before
leaving you: <strong>use this library</strong>.</p>

<p>Even though the ODM is not finished yet, <strong>HTTP binding
and Query Builder are already at a stable stage</strong>:
the first one is <strong>already faster</strong> than the <a href="https://github.com/AntonTerekhov/OrientDB-PHP">binary-protocol implementation</a>,
while the second one is a very convenient library to
help you <strong>saving a lot of time</strong> when writing OrientDB&rsquo;s
SQL+.</p>

<p>Again, their level of maturity is pretty high, and we
accept and review bugs/feature requests pretty fastly.</p>

<p>So, what? Now, there are <strong>no more excuses</strong>.</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>We have a test suite that runs &ldquo;on paper&rdquo;, meaning that those are tests running based on the OrientDB documentation. Integration tests are done, instead, with a real OrientDB instance <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>It is used to provide a basic caching layer for annotations <a href='#fnref:2' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
</feed>