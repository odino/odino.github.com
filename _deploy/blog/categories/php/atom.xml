<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: PHP | Alessandro Nadalin]]></title>
  <link href="http://www.odino.org/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://www.odino.org/"/>
  <updated>2012-08-03T19:07:26+04:00</updated>
  <id>http://www.odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Monolog for PHP error reporting on New Relic]]></title>
    <link href="http://www.odino.org/using-monolog-for-php-error-reporting-on-new-relic/"/>
    <updated>2012-07-27T08:00:00+04:00</updated>
    <id>http://www.odino.org/using-monolog-for-php-error-reporting-on-new-relic</id>
    <content type="html"><![CDATA[<p>I <strong>do</strong> really like <a href="http://newrelic.com/">New Relic</a>, a real-time
error reporting solution available for many
platforms, so a few days ago I decided to
integrate it with <a href="https://github.com/Seldaek/monolog/">Monolog</a>, the other
main logging tool that we use here at
Rocket.</p>

<!-- more -->


<p>The idea behind it is very simple: since
New Relic is not always available on
development platforms, you first verify
that the PHP extension is loaded, then,
if it is, log a report on New Relic:
if the extension is not available, another
logging handler will act as a fallback.</p>

<p>To reach our goal we will simply need the
New Relic PHP extension, Monolog and the
Symfony2 <a href="http://symfony.com/doc/current/book/service_container.html">dependency injection container</a>.</p>

<h2>Catching the error and reporting it</h2>

<p>Let's start with a real world example, you
have a controller action that receives some
<code>POST</code> data and throws an exception whenever
the input data is missing some values<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>.</p>

<p>``` php A simple action
&lt;?php</p>

<p>namespace Application\Webservice;</p>

<p>use Application\MVC\Controller as BaseController;
use Application\Webservice\Exception;</p>

<p>class Controller extends BaseController
{</p>

<pre><code>public function updateDatabaseData(array $data)
{
    try {
        $this-&gt;validateData($data);

        // ...
    } catch (Exception $e) {
        $this-&gt;container-&gt;get('logger.new-relic')-&gt;error($e-&gt;getMessage(), $data);
    }
}
</code></pre>

<p>}
```</p>

<p>So, at this point, we just need to define the <code>logger.new-relic</code>
service in the DIC configuration file:</p>

<p>``` yml The DIC configuration file
services:
  logger.new-relic:</p>

<pre><code>class: "Monolog\\Logger"
arguments:
  name: "new-relic"
calls:
  - [ pushHandler, [@log.handler.new-relic] ]
</code></pre>

<p>  log.handler.new-relic:</p>

<pre><code>class:  "\\Application\\Log\\Handler\\NewRelic"
calls:
  - [ setFallbackHandler, [@log.handler.standard] ]
</code></pre>

<p>  log.handler.standard:</p>

<pre><code>class:  "Monolog\\Handler\\StreamHandler"
arguments:
  stream: "/tmp/error-log.txt"
</code></pre>

<p>```</p>

<p>As you see we define a Monolog logger designed
specifically for New Relic (<code>logger.new-relic</code>)
and an handler that will try to log everything
on the remote NR server: this handler also has a
fallback handler, if the New Relic PHP extension is
not available, which is configurable directly
within the YAML file (<code>log.handler.error</code>).</p>

<h2>The log handler</h2>

<p>The New Relic handler is <strong>really</strong>
straightforward:</p>

<p>``` php The New Relic log handler
&lt;?php</p>

<p>/<em>*
 * Class used to log on New Relic.
 </em>/</p>

<p>namespace Application\Log\Handler;</p>

<p>use Monolog\Handler\AbstractProcessingHandler;
use Monolog\Handler;</p>

<p>class NewRelic extends AbstractProcessingHandler
{</p>

<pre><code>protected $fallbackHandler;

/**
 * Logs a $record on New Relic, providing additional parameters from the
 * record's context.
 * If the New Relic extension is not available and a fallback handler is
 * provided, it will simply log the error with a fallback.
 * 
 * @param array $record 
 */
protected function write(array $record)
{
    if (extension_loaded('newrelic')) {
        newrelic_notice_error($record['message']);

        foreach ($record['context'] as $key =&gt; $parameter) {
            newrelic_add_custom_parameter($key, $parameter);
        }
    } elseif ($this-&gt;fallbackHandler instanceOf AbstractProcessingHandler) {
        $this-&gt;fallbackHandler-&gt;write($record);
    }
}

/**
 * Sets the fallback handler to be used to log informations if the New Relic
 * extension is not available.
 *
 * @param Monolog\Handler\AbstractProcessingHandler $handler 
 */
public function setFallbackHandler(AbstractProcessingHandler $handler)
{
    $this-&gt;fallbackHandler = $handler;
}
</code></pre>

<p>}
```</p>

<p>So, the code is pretty simple: we implement the <code>write</code> method
of <code>AbstractProcessingHandler</code> in our <code>New Relic</code> class,
using New Relic's low level functions to notice the
error and add some more informations about the
context surrounding the exception: the fallback
handler will take stage only if the New Relic
extension isn't loaded.</p>

<h2>Log systems and analysis</h2>

<p>Simple but pretty useful: if you use either
New Relic or Monolog I strongly recommend you
to integrate into your log management system
the missing tool since:</p>

<ul>
<li>New Relic serves as a nice reporting tool,
giving you an overview of the amount of
errors logged over some time, letting you
define tresholds for error reporting and
grouping errors to measure the impact a code
change can have on your applications<sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup></li>
<li>Monolog gives you a great abstraction and
log handlers, which can very easily ease
your job in taking the right action for
different types of errors<sup id='fnref:3'><a href='#fn:3' rel='footnote'>3</a></sup>
(as you saw, with the DIC it's pure joy to
instantiate and use different handlers based
on a configuration file)</li>
</ul>


<p>At Rocket Turkey &amp; MENA we really care about logs:
being a product-based company, <strong>a bug in our
system is a bug on our core business</strong>, so we need
to easily be able to spot problems.</p>

<p>So far, using Monolog and New Relic as both standalone and combined
products has been a very good choice, since with
New Relic with have a pretty overview about
error reporting, while Monolog gives us the
ability to easily debug problems in our
integrations, since solving problems with all
the data we track with it it's really easier,
and if we need to change logs' format or add new data
to the logs because we notice that it would speed
up troubleshooting and log analysis, making
the change is relatively easy, since it's a
really well OOP-written library.</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>Bare in mind that I will be very brief in my examples, so you won't learn how to bootstrap the DIC here, for example <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>I say applications since, as you may know, in New Relic you can handle multiple machines to be registered as different applications (like frontend/backend/mail server/cron slave/gateway) <a href='#fnref:2' rev='footnote'>↩</a></li><li id='fn:3'>In fact,whenever an email is not delivered by your email sever, it's not a problem, but when you start seeing that the amount of mails that are not delivered are too much, you may consider to use a critical handler, specifically designed to send an SMS/email to some contacts <a href='#fnref:3' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Y U NO access WHOIS informations in PHP?]]></title>
    <link href="http://www.odino.org/y-u-no-access-whois-informations-in-php/"/>
    <updated>2012-04-16T00:38:00+04:00</updated>
    <id>http://www.odino.org/y-u-no-access-whois-informations-in-php</id>
    <content type="html"><![CDATA[<p><ol class="aseries">
	<p>This post is part of the "<strong>WHOIS in PHP: consuming the Robowhois API</strong>" series; here is a list of all the articles contained this series:</p>
	<li>
		<a href="/a-php-library-to-retrieve-whois-informations/">A PHP library to retrieve WHOIS informations</a>
	</li>
	<li>
		<a href="/retrieving-raw-whois-informations-in-php/">Retrieving raw WHOIS informations in PHP</a>
	</li>
	<li>
		<a href="/checking-a-domain-s-availability-with-php/">Checking a domain's availability with PHP</a>
	</li>
  <li>
    <a href="/y-u-no-access-whois-informations-in-php/">Y U NO access WHOIS informations in PHP?</a>
  </li>
</ol>
</p>

<p>In these days we finalized the last parts of the official
<a href="https://github.com/robowhois/robowhois-php">PHP client for the Robowhois API</a>
, and here are the changes for the <code>0.9.0</code> version.</p>

<!-- more -->


<h2>Parts and properties API</h2>

<p>As part of our job, we needed to implement the last
2 API endpoints provided by Robowhois, <code>properties</code>
and <code>parts</code>.</p>

<p>Everything is documented in the
<a href="https://github.com/robowhois/robowhois-php/blob/master/README.md">README</a>
but you can also follow the examples under the <code>sample/</code> directory:</p>

<p>``` php Using the properties API
&lt;?php</p>

<p>use Robowhois\Robowhois;
use Robowhois\Exception;</p>

<p>require 'vendor/.composer/autoload.php';</p>

<p>$robowhois = new Robowhois('INSERT-YOUR-API-KEY-HERE');</p>

<p>try {</p>

<pre><code>$domain = $robowhois-&gt;whoisProperties('robowhois.com');

echo $domain['properties']['created_on'] . "\n";
</code></pre>

<p>} catch (Exception $e) {</p>

<pre><code>echo "The following error occurred: " . $e-&gt;getMessage();
</code></pre>

<p>}
```</p>

<p>``` php Using the parts API
&lt;?php</p>

<p>use Robowhois\Robowhois;
use Robowhois\Exception;</p>

<p>require 'vendor/.composer/autoload.php';</p>

<p>$robowhois = new Robowhois('INSERT-YOUR-API-KEY-HERE');</p>

<p>try {</p>

<pre><code>$domain = $robowhois-&gt;whoisParts('robowhois.com');

echo $domain['parts'][0]['body'] . "\n";
</code></pre>

<p>} catch (Exception $e) {</p>

<pre><code>echo "The following error occurred: " . $e-&gt;getMessage();
</code></pre>

<p>}
```</p>

<h2>Magic objects, behaving like arrays</h2>

<p>We implemented the <code>\ArrayObject</code> interface for the objects
returned by the API, which means that now you can access
the results of an API call just like an array:</p>

<p>``` php
&lt;?php</p>

<p>$account = $robowhois->account();</p>

<p>// $account is an instance of Robowhois\Account
echo sprintf('You have %d API calls left', $account['credits_remaining']);
```</p>

<p>but, for those like us who like the OO synthax, we implemented
some magic to let you retrieve those values via getters, which
are built <em>on-the-fly</em> thanks to PHP's <code>__call()</code> method:</p>

<p>``` php
&lt;?php</p>

<p>echo $account->getCreditsRemaining();
```</p>

<p>Getters are a camelized version of the array keys, and are
built thanks to the
<a href="https://github.com/robowhois/robowhois-php/blob/master/composer.json#L28">Doctrine Inflector</a>.</p>

<h2>Mapping the existing API</h2>

<p>We renamed the methods accessing the API in order to 100% reflect
the ones exposed by the API, also used in the
<a href="https://github.com/robowhois/robowhois-ruby">Ruby client</a>: so now the
<code>Robowhois\Robowhois</code> object has:</p>

<ul>
<li><code>-&gt;account()</code></li>
<li><code>-&gt;whois()</code></li>
<li><code>-&gt;whoisProperties()</code></li>
<li><code>-&gt;whoisParts()</code></li>
<li><code>-&gt;whoisRecord()</code></li>
<li><code>-&gt;whoisAvailability()</code></li>
</ul>


<h2>Simplified exceptions</h2>

<p>We initially added tons of exceptions but we eventually
decide to keep the only <code>Robowhois\Exception</code> class.</p>

<h2>Now?</h2>

<p>Wanna retrieve WHOIS informations in PHP at a
<a href="http://www.robowhois.com/pricing">decent price</a>?</p>

<p>Start consuming the Robowhois APIs, with PHP.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Checking a domain's availability with PHP]]></title>
    <link href="http://www.odino.org/checking-a-domain-s-availability-with-php/"/>
    <updated>2012-03-20T09:49:00+04:00</updated>
    <id>http://www.odino.org/checking-a-domain-s-availability-with-php</id>
    <content type="html"><![CDATA[<p><ol class="aseries">
	<p>This post is part of the "<strong>WHOIS in PHP: consuming the Robowhois API</strong>" series; here is a list of all the articles contained this series:</p>
	<li>
		<a href="/a-php-library-to-retrieve-whois-informations/">A PHP library to retrieve WHOIS informations</a>
	</li>
	<li>
		<a href="/retrieving-raw-whois-informations-in-php/">Retrieving raw WHOIS informations in PHP</a>
	</li>
	<li>
		<a href="/checking-a-domain-s-availability-with-php/">Checking a domain's availability with PHP</a>
	</li>
  <li>
    <a href="/y-u-no-access-whois-informations-in-php/">Y U NO access WHOIS informations in PHP?</a>
  </li>
</ol>
</p>

<p>It's been a while I don't blog about the
<a href="https://github.com/robowhois/robowhois-php">Robowhois PHP client</a> that I'm developing
together with <a href="http://davidfunaro.com">David</a> so, since we recently released
the <code>0.8.0</code> version I want to share with you what you can do with it now.</p>

<!-- more -->


<h2>Checking a domain's availability</h2>

<p>The <a href="http://docs.robowhois.com/api/whois/">availability API</a> is probably the
greatest feature of the <a href="http://www.robowhois.com/">Robowhois</a> webservice,
letting you check for a domain's availability with a simple, uniform HTTP
request.</p>

<p>``` php Checking if google.com is available
&lt;?php</p>

<p>use Robowhois\Robowhois;</p>

<p>$robowhois = new Robowhois('INSERT-YOUR-API-KEY-HERE');</p>

<p>if ($robowhois->isAvailable('google.com')) {
  echo "pretty nice dream, uhm?";
}
```</p>

<p>The opposite thing is achieved using the <code>-&gt;isRegistered()</code> method.</p>

<p>You can also retrieve an array as returned from the webservice, by doing:</p>

<p>``` php
&lt;?php</p>

<p>use Robowhois\Robowhois;</p>

<p>$robowhois = new Robowhois('INSERT-YOUR-API-KEY-HERE');</p>

<p>if ($availability = $robowhois->whoisAvailability('google.com')) {
  echo $availability['available'];
  echo $availability['registered'];
  echo $availability['daystamp'];
}
```</p>

<h2>Retrieve informations about your account</h2>

<p>A <em>must-have</em>, since you should always check how many remaining credits
you have, the <code>account</code> API lets you retrieve some of your personal data
from your Robowhois.com account:</p>

<p>``` php Calculating how many left credits you have
&lt;?php</p>

<p>use Robowhois\Robowhois;</p>

<p>$robowhois = new Robowhois('INSERT-YOUR-API-KEY-HERE');</p>

<p>try {</p>

<pre><code>$credits = $robowhois-&gt;whoisAccount()-&gt;getCreditsRemaining();

    if ($credits &gt; 100) {
            echo "No problem fella!";
} else {
            echo "Time to go shopping looking for new API calls, uhm?";
}
</code></pre>

<p>} catch (Exception $e) {</p>

<pre><code>echo "The following error occurred: " . $e-&gt;getMessage();
</code></pre>

<p>}
```</p>

<h2>Minor things</h2>

<p>We also polished some code, refactored stuff and added some tests (unit and
integration ones).</p>

<p>For instance, when using the <code>record</code> API, you can retrieve the daystamp of the
response as <code>DateTime</code> object:</p>

<p>``` php retrieving the daystamp as an object or a string
&lt;?php</p>

<p>use Robowhois\Robowhois;</p>

<p>$robowhois = new Robowhois('INSERT-YOUR-API-KEY-HERE');</p>

<p>if ($whois = $robowhois->whoisRecord('google.com')) {
  // returns a DateTime object
  echo $whois->getDaystamp();</p>

<p>  // formats the DateTime
  echo $whois->getDaystamp()->format('Y-m-d');</p>

<p>  // returns a string
  echo $whois->getDaystamp(true);
}
```</p>

<p>You can download the <a href="https://github.com/robowhois/robowhois-php/tree/0.8.0">latest tag</a>
of the library (currently <code>0.8.0</code>) and start using it: the <a href="https://github.com/robowhois/robowhois-php/blob/master/README.md">README</a>
exhaustively explains what you can do with this small client, and some
<a href="https://github.com/robowhois/robowhois-php/tree/master/sample">samples</a>
are provided under the <code>sample</code> directory.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Create a Composer command line installer with the Symfony2 CLI]]></title>
    <link href="http://www.odino.org/install-composer-dependencies-with-the-symfony2-cli/"/>
    <updated>2012-02-21T10:51:00+04:00</updated>
    <id>http://www.odino.org/install-composer-dependencies-with-the-symfony2-cli</id>
    <content type="html"><![CDATA[<p><ol class="aseries">
	<p>This post is part of the "<strong>Symfony2 components in your own userland</strong>" series; here is a list of all the articles contained this series:</p>
	<li>
		<a href="/using-the-symfony2-dependency-injection-container-as-a-standalone-component/">Using the Symfony2 Dependency Injection Container as a standalone component</a>
	</li>
	<li>
		<a href="/launching-phpunit-tests-from-a-browser-with-symfony2/">Launching PHPUnit tests from a browser with Symfony2</a>
	</li>
	<li>
		<a href="/install-composer-dependencies-with-the-symfony2-cli/">Using the Console component to write an interactive installer for Composer</a>
	</li>
</ol>
</p>

<p>Today we are going to see the power of Symfony2's
<a href="https://github.com/symfony/console">Console component</a>,
which lets us build powerful interactive command line applications
in pure PHP.</p>

<!-- more -->


<p><img class="right" src="/images/installer.png"></p>

<p>In this episode we are going to create an interactive shell
able to generate new composer-based projects: we will have a
command to define which dependencies we need and another one
to:</p>

<ul>
<li>create the installation directory</li>
<li>download composer</li>
<li>generate  a <code>composer.json</code> according to the required dependencies</li>
<li>run a <code>php composer.phar install</code> to install everything</li>
</ul>


<p>The approach we're going to use will be very rough and incomplete: no
error handling, no decent abstraction, but is intended to give you a
clue about the potentiality of the CLI tool and to show you how you can
easily create PHP command line applications without the need to
write too much good code.</p>

<h2>Approach and installation</h2>

<p>The Symfony2 Console lets use extend the <code>Console\Command\Command</code> class to
implement your own commands, so we will add a couple custom commands, one to
<strong>register dependencies</strong> and one to <strong>execute the installation</strong>.</p>

<p>First of all, let create our own <code>composer.json</code>, to download the Console
and <a href="/launching-phpunit-tests-from-a-browser-with-symfony2/">Process</a><sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>
components:</p>

<p>``` bash composer.json
{</p>

<pre><code>"require": {
    "php": "&gt;=5.3.2",
    "symfony/console": "2.0.10",
    "symfony/process": "2.0.10"
}
</code></pre>

<p>}
```</p>

<p>then install everything and create your <code>installer.php</code> script which
serves as the entry point for the console:</p>

<p>``` bash installing the dependencies
wget http://getcomposer.org/composer.phar</p>

<p>php composer.phar install
```</p>

<p>``` php installer.php
&lt;?php</p>

<p>require 'vendor/.composer/autoload.php';
require 'Command/DependencyContainer.php';
require 'Command/Install.php';</p>

<p>use Symfony\Component\Console\Shell;
use Symfony\Component\Console\Application;</p>

<p>$application            = new Application('Installer', '1.0.0-alpha');
$dependencyContainer    = new DependencyContainer();
$application->add($dependencyContainer);
$application->add(new Install($dependencyContainer));
$shell = new Shell($application);</p>

<p>$shell->run();
```</p>

<p>In the <code>installer.php</code> we are instantiating a new interactive shell
application, adding to it 2 new commands and then we run it: don't try it now,
as the added command classes don't exist yet.</p>

<h2>A container for the dependencies</h2>

<p>The first custom command we are going to add is a dependency container, which is
a convenient class storing the dependencies, like <code>symfony/yaml</code>, in an
attribute, and exposes a <code>getDependencies()</code> method that will be used by the
installer command to retrieve the dependencies to install.</p>

<p>``` php Command/DependencyContainer.php
&lt;?php</p>

<p>use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;</p>

<p>class DependencyContainer extends Command
{</p>

<pre><code>protected $dependencies = array();

public function getDependencies()
{
    return $this-&gt;dependencies;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
    $dialog  = $this-&gt;getHelperSet()-&gt;get('dialog');
    $package = $dialog-&gt;ask($output, '&lt;question&gt;Please enter the name of the package you want to install&lt;/question&gt;');

    if ($package) {
        $this-&gt;dependencies[] = '"' . $package . '": "master"';
        $output-&gt;writeln(sprintf('&lt;info&gt;Package %s was succesfully registered&lt;/info&gt;', $package));
    } else {
        $output-&gt;writeln('&lt;error&gt;You must insert a package name&lt;/error&gt;');   
    }
}

protected function configure()
{
    $this
        -&gt;setName('add-dependency');
    ;
}
</code></pre>

<p>}
```</p>

<p>As you see, the command will be called when doing a <code>add-dependency</code> from the console
and will ask the user to prompt the dependency we wants to add; a basic check is done:</p>

<p>``` php Checking for non-empty input
&lt;?php
...</p>

<p>if ($package) {</p>

<pre><code>$this-&gt;dependencies[] = '"' . $package . '": "master"';
$output-&gt;writeln(sprintf('&lt;info&gt;Package %s was succesfully registered&lt;/info&gt;', $package));
</code></pre>

<p>} else {</p>

<pre><code>$output-&gt;writeln('&lt;error&gt;You must insert a package name&lt;/error&gt;');   
</code></pre>

<p>}
```</p>

<p>Note that, for being <em>quick'n'dirty</em>, we store the dependencies in the composer way:</p>

<p><code>bash
"dependencyvendor/dependencyname": "dependencyversion"
</code></p>

<p>and we use <code>master</code> as the only version available<sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup>.</p>

<p>This is it: now we only need to create the command to install everything.</p>

<h2>The installation command</h2>

<p>The <code>Install</code> command will be called with <code>install</code> from the command line, and
executes 4 sub-tasks to finish the installation process:</p>

<ul>
<li>create the installation directory</li>
<li>download composer via <code>wget</code></li>
<li>generate the <code>composer.json</code> according to the dependencies specified in the
DependencyContainer</li>
<li>run the composer traditional installation (<code>php composer.phar install</code>)</li>
</ul>


<p>This command takes a <code>DependencyContainer</code> argument in the constructor
to extract the dependencies needed to be installed:</p>

<p>``` php Command/Install.php
&lt;?php</p>

<p>use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Process\Process;</p>

<p>class Install extends Command
{</p>

<pre><code>protected $installDir;
protected $failingProcess;
protected $dependenciesContainer;

public function __construct(DependencyContainer $dependenciesContainer)
{
    parent::__construct();

    $this-&gt;dependenciesContainer = $dependenciesContainer;
}

protected function execute(InputInterface $input, OutputInterface $output)
{
    if ($this-&gt;createInstallationDirectory($output)
     &amp;&amp; $this-&gt;downloadComposer($output)
     &amp;&amp; $this-&gt;generateJson($output)
     &amp;&amp; $this-&gt;install($output)) {
        $output-&gt;writeln('&lt;info&gt;MISSION ACCOMPLISHED&lt;/info&gt;');
    } else {
        $output-&gt;writeln('&lt;error&gt;Nasty error happened :\'-(&lt;/error&gt;');

        if ($this-&gt;failingProcess instanceOf Process) {
            $output-&gt;writeln('&lt;error&gt;%s&lt;/error&gt;', $this-&gt;failingProcess-&gt;getErrorOutput());   
        }
    }
}

protected function configure()
{
    $this
        -&gt;setName('install')
    ;
}
</code></pre>

<p>}
```</p>

<p>as you see we execute this 4 tasks and, if an error happens, we output an error,
otherwise a confirmation message tells the user that everything went fine.</p>

<p>If a failure happens, we get the error message thanks to the <code>Process</code> method <code>getErrorOutput()</code>.</p>

<p>Let's see how the tasks are implemented in this class: first of all, we need a <code>createInstallationDirectory()</code>
method that launches a new <code>mkdir</code> process and returns a boolean value, indicating the
successfulness of the process; before returning false, the class' internal attribute
<code>$failingProcess</code> is updated:</p>

<p>``` php
&lt;?php
...</p>

<p>protected function createInstallationDirectory(OutputInterface $output)
{</p>

<pre><code>$dialog             = $this-&gt;getHelperSet()-&gt;get('dialog');
$this-&gt;installDir   = $dialog-&gt;ask($output, '&lt;question&gt;Please specify a non-existing directory to start the installation&lt;/question&gt;');

if (!is_dir($this-&gt;installDir)) {
    $mkdir = new Process(sprintf('mkdir -p %s', $this-&gt;installDir));
    $mkdir-&gt;run();

    if ($mkdir-&gt;isSuccessful()) {
        $output-&gt;writeln(sprintf('&lt;info&gt;Directory %s succesfully  created&lt;/info&gt;', $this-&gt;installDir));

        return true;
    }
}

$this-&gt;failingProcess = $mkdir;
return false;
</code></pre>

<p>}
```</p>

<p>As you see, the user will be asked to provide an <code>$installDir</code> in which we are going
to execute the whole process.</p>

<p>Now we need to create the <code>downloadComposer()</code> method, which uses <code>wget</code> to put <code>composer.phar</code>
in the installation directory:</p>

<p>``` php
&lt;?php
...</p>

<p>protected function downloadComposer(OutputInterface $output)
{</p>

<pre><code>$wget = new Process(sprintf('wget getcomposer.org/composer.phar -O %s/composer.phar', $this-&gt;installDir, $this-&gt;installDir));
$wget-&gt;run();

if ($wget-&gt;isSuccessful()) {
    $output-&gt;writeln('&lt;info&gt;Downloaded composer in the installation directory&lt;/info&gt;');

    return true;
}

$this-&gt;failingProcess = $wget;
return false;
</code></pre>

<p>}
```</p>

<p>Then we generate a <code>composer.json</code> in the installation directory:</p>

<p>``` php
&lt;?php
...</p>

<p>protected function generateJson(OutputInterface $output)
{</p>

<pre><code>$skeleton       = file_get_contents(__DIR__ . "/../composer.s");
$dependencies   = implode(',', $this-&gt;dependenciesContainer-&gt;getDependencies());
$skeleton       = str_replace('PLACEHOLDER', $dependencies, $skeleton);

if (file_put_contents($this-&gt;installDir . "/composer.json", $skeleton)) {
    $output-&gt;writeln('&lt;info&gt;composer.json has been generated&lt;/info&gt;');

    return true;
}

return false;
</code></pre>

<p>}
```</p>

<p>Note that you will need a template file to do so:</p>

<p>``` bash composer.s
{</p>

<pre><code>"require": {
    PLACEHOLDER
}
</code></pre>

<p>}
```</p>

<p>The last step consists in launching a new process which runs the
usual composer's installation process on the installation directory:</p>

<p>``` php
&lt;?php
...</p>

<p>protected function install(OutputInterface $output)
{</p>

<pre><code>$install = new Process(sprintf('cd %s &amp;&amp; php composer.phar install', $this-&gt;installDir));
$install-&gt;run();

if ($install-&gt;isSuccessful()) {
    $output-&gt;writeln('&lt;info&gt;Packages succesfully installed&lt;/info&gt;');

    return true;
}

$this-&gt;failingProcess = $install;
return false;
</code></pre>

<p>}
```</p>

<p>This is the console output for generating a new project which depends on
<code>symfony/yaml</code> and <code>symfony/dom-crawler</code>:</p>

<p><img class="center" src="/images/shell.png"></p>

<p>The auto-generated <code>composer.json</code> will look like:</p>

<p>``` bash
{</p>

<pre><code>"require": {
    "symfony/yaml": "master","symfony/dom-crawler": "master"
}
</code></pre>

<p>}
```</p>

<h2>Conclusion</h2>

<p>As said, this implementation is pretty naive and can definitely be improved:
but with a couple classes and basic logic you are able to write a powerful
tool that doesn't require a web frontend and runs directly from the command line
with a pure implementation in PHP, thanks to the Symfony2 components.</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>The Process component will be used to execute shell commands directly from PHP <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>Tip: if you want, you can add the code to show the user another dialog to indicate the dependency version, and use master as a fallback <a href='#fnref:2' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Launching PHPUnit tests from a browser with Symfony2]]></title>
    <link href="http://www.odino.org/launching-phpunit-tests-from-a-browser-with-symfony2/"/>
    <updated>2012-02-20T13:41:00+04:00</updated>
    <id>http://www.odino.org/launching-phpunit-tests-from-a-browser-with-symfony2</id>
    <content type="html"><![CDATA[<p><ol class="aseries">
	<p>This post is part of the "<strong>Symfony2 components in your own userland</strong>" series; here is a list of all the articles contained this series:</p>
	<li>
		<a href="/using-the-symfony2-dependency-injection-container-as-a-standalone-component/">Using the Symfony2 Dependency Injection Container as a standalone component</a>
	</li>
	<li>
		<a href="/launching-phpunit-tests-from-a-browser-with-symfony2/">Launching PHPUnit tests from a browser with Symfony2</a>
	</li>
	<li>
		<a href="/install-composer-dependencies-with-the-symfony2-cli/">Using the Console component to write an interactive installer for Composer</a>
	</li>
</ol>
</p>

<p>Today we are going to launch interactive PHPUnit tests thanks to the
Symfony2 <a href="https://github.com/symfony/Process">Process</a> component.</p>

<!-- more -->


<h2>Premise</h2>

<p>This article will show you how to build a script to run your unit tests
from a browser and render the output to the webpage: since the aim
of this series of articles is to show you how easily you can integrate
Symfony2 code into your own projects, I will use nasty scripts to
accomplish our requirements.</p>

<h2>The approach</h2>

<p>Our approach will be very basic and dummy: we are goint to execute a shell
command from PHP, write each output buffers into a file and poll the file
from the frontend to progressively read its content.</p>

<h2>Into the mix</h2>

<p>To do so, let's create a JS-loving <code>index.php</code> file:</p>

<p>``` html The entry point of out application
<html>
  <body></p>

<pre><code>&lt;h1&gt;PHPUnit web tests&lt;/h1&gt;
&lt;a href="#" id="run"&gt;
  Run tests
&lt;/a&gt;
&lt;div id="output"&gt;&lt;/div&gt;

&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
  $(document).ready(function(){
    var getOutput = function(){
      $.ajax({
        url: "output.php",
        success: function(data) {
          $('#output').html(data.content);

          if (data.stop != 1) {
            getOutput();
          }
        }
      });
    };
    $('#run').click(function(){
      $.ajax({
        url: "process.php",
      });
      getOutput();
    });
  });
&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>As you see, as you click on the <code>Run tests</code> link you will fire an event that:</p>

<ul>
<li>makes a <code>GET</code> call to <code>process.php</code></li>
<li>makes a recursive <code>GET</code> request to <code>output.php</code>, until the output object
does not contain the <code>stop</code> attribute</li>
</ul>


<p>The output script is really easy:</p>

<p>``` php
&lt;?php</p>

<p>$fileName = sys_get_temp_dir() . '/test.output.txt';
header('Content-Type: application/json');</p>

<p>if (file_exists($fileName)) {
  $f = file_get_contents(sys_get_temp_dir() . '/test.output.txt');</p>

<p>  echo json_encode(array('content' => $f));<br/>
} else {
  $f = file_get_contents(sys_get_temp_dir() . '/test.output.txt.f');</p>

<p>  echo json_encode(array('content' => $f, 'stop' => 1));
  unlink($f);
}
```</p>

<p>As you see, each time we call this script, it reads the content of the <code>test.output.txt</code>
file in the temporary directory of your system: if it doesn't find it, it reads the
<code>test.output.txt.f</code> file<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>.</p>

<h2>Enter Process</h2>

<p>In our final step, let's install the Process component:</p>

<p>``` bash composer.json
{</p>

<pre><code>"require": {
    "php": "&gt;=5.3.2",
    "symfony/process": "2.0.10"
}
</code></pre>

<p>}</p>

<p>```</p>

<p>```
wget http://getcomposer.org/composer.phar</p>

<p>php composer.phar install
```</p>

<p>then we can create our <code>process.php</code> script:</p>

<p>``` php
&lt;?php</p>

<p>require <strong>DIR</strong> . '/vendor/.composer/autoload.php';</p>

<p>use Symfony\Component\Process\Process;</p>

<p>$file = sys_get_temp_dir() . '/test.output.txt';</p>

<p>$handle   = fopen($file, 'w+');
$process  = new Process('phpunit -c /home/foor/bar/phpunit.xml /home/foo/bar');
$process->run(function ($type, $buffer) use($handle) {
  fwrite($handle, nl2br($buffer));
});</p>

<p>fclose($handle);</p>

<p>rename($file, $file . ".f");
```</p>

<p>As you see we are launching the test suite and, at each buffer, thanks to a
lambda, we write a new chunk to the file: at the end of the process the
<code>txt</code> file gets renamed, so the <code>output.php</code> script knows that it needs to
notify the frontend that he's not required to poll it anymore, adding
the <code>stop</code> attribute to the JSON object it outputs:</p>

<p>``` php fragment of output.php
&lt;?php</p>

<p>echo json_encode(array('content' => $f, 'stop' => 1));
```</p>

<p><img class="center" src="/images/phpunit-process.png"></p>

<h2>Benefits from the Process component</h2>

<p><blockquote><p>I can do that crap with shell_exec() too!</p></blockquote></p>

<p>There are some advantages of using Process instead of writing your own command
executor: first of all, if you don't want to take care of the subtle <strong>differences
between the different platforms</strong> everything is done for you;
then <strong>error handling becomes very easy</strong> since you are able to catch all the buffers:</p>

<p>``` php
&lt;?php
...</p>

<p>$process->run(function ($type, $buffer) {</p>

<pre><code>if ('err' === $type) {
    echo 'Something nasty happened';
          syslog(LOG_ERR, $buffer);
} else {
    echo $buffer;
}
</code></pre>

<p>});
```</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>Flaw here: no error handling when the .f file is not found <a href='#fnref:1' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
</feed>
