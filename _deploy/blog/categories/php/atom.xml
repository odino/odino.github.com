<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: php | Alessandro Nadalin]]></title>
  <link href="http://www.odino.org/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://www.odino.org/"/>
  <updated>2013-01-25T22:31:32+04:00</updated>
  <id>http://www.odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Making the OrientDB ODM 5 times faster]]></title>
    <link href="http://www.odino.org/making-the-orientdb-odm-5-times-faster/"/>
    <updated>2013-01-25T17:39:00+04:00</updated>
    <id>http://www.odino.org/making-the-orientdb-odm-5-times-faster</id>
    <content type="html"><![CDATA[<p>Today, after heavily testing performances
on a project, I pushed some small but
precious changes to the
<a href="https://github.com/doctrine/orientdb-odm">orientdb-odm</a>.</p>

<!-- more -->


<h2>Prelude</h2>

<p><blockquote><p>Premature optimization is the root of all evil</p><footer><strong>Donald Knuth</strong> <cite><a href='http://c2.com/cgi/wiki?PrematureOptimization'>C2 Wiki</a></cite></footer></blockquote></p>

<p>In these days I was testing performances of a
service I am building with
<a href="https://github.com/nuvolabase/orientdb">OrientDB</a>
and the doctrine ODM that
<a href="/please-welcome-the-doctrine-orientdb-odm/">we built so far</a>.</p>

<p>Following one of the golden rules for software
architects, we didn't paid attention to performances - at first -
but rather went for a design which would allow us
to inject behaviours and easily change portions of code
(also thanks to the <a href="https://travis-ci.org/doctrine/orientdb-odm">test suite</a>),
I knew that I would have noticed huge flaws at
performance level when testing it with
<strong>production data</strong>.</p>

<p>A few days ago we committed fetchplans for repository
classes, but it wasnt enough: rather then concentrating
on which data we should fetch, I realized one major
improvement could be applied on how we <strong>map</strong> data.</p>

<h2>The golden rule</h2>

<p><span class='pullquote-right' data-pullquote='abstraction comes with a cost:
slow performances'>
When you write a OXM (object-something mapper) you will
shortly understand that a huge portion of your job
consist into abstract your design, to ease
integration of multiple components into your application:
repositories, the object manager, POXO, the data mapper,
proxy classes and so on.</p>

<p>Of course, abstraction comes with a cost:
slow performances, so one of the first things that you do is starting
to <strong>cache everything</strong>.
</span></p>

<h2>How we did it</h2>

<p>With a <a href="https://github.com/doctrine/orientdb-odm/commit/df875c946e02a9c84eee22f0c86e0a3b06bd70ec">single commit</a>
- there's always room for improvements - the ODM is now able
to hydrate objects <strong>5 times faster</strong>: when you hydrate similar
objects from OrientDB (for example, 2 records that share the same
attributes' values, like <code>is_published</code> or <code>country</code>), there is
no need to duplicate operations, so we added a <a href="https://github.com/doctrine/orientdb-odm/blob/df875c946e02a9c84eee22f0c86e0a3b06bd70ec/src/Doctrine/OrientDB/Util/Inflector/Cached.php">cached inflector</a>
(with an in-memory / single request cache) and did some other
improvements to the <code>Mapper</code>:</p>

<ul>
<li>cached the relations between <a href="https://github.com/doctrine/orientdb-odm/commit/df875c946e02a9c84eee22f0c86e0a3b06bd70ec#L0L297">PHP classes and OrientDB classes</a> (if 2 records of the same OrientDB class are hydrated, there is only one single <em>search</em> operation to find the PHP class that should map them)</li>
<li>cached the <a href="https://github.com/doctrine/orientdb-odm/commit/df875c946e02a9c84eee22f0c86e0a3b06bd70ec#L0L223">casting of properties</a> (if 2 objects have the same value for the <code>is_published</code> attribute, casting is done once)</li>
<li>cached <a href="https://github.com/doctrine/orientdb-odm/commit/df875c946e02a9c84eee22f0c86e0a3b06bd70ec#L0L466">properties' annotations</a> (property-level annotations are inspected once per class)</li>
</ul>


<p>There is no rocket science in what we did, but benchmarks ensure that
it's a <strong>huge performance improvement</strong>.</p>

<h2>By the way, we used Webgrind</h2>

<p><img class="right" src="/images/webgrind.png"></p>

<p>Doing almost all of my work from a Mac, I kind of
missed <a href="http://kcachegrind.sourceforge.net/html/Home.html">KCacheGrind</a>
for profiling, so I was looking for an
alternative (no, installing
<a href="https://github.com/facebook/xhprof">XHPROF</a> isn't an alternative at 2 in the morning)
and I found Webgrind (which is cross-platform), a web profiler
that requires zero setup:
you basically just need to provide it access from the webserver
and, by opening it with a browser, the application automatically
launches and parses the cachegrind files generated by XDebug.</p>

<p>Webgrind's code is a bit of a mess, but then, the
result is still pretty good - you get a good overview
of the expensiveness of your calls as well as a
call graph compiled in <a href="http://en.wikipedia.org/wiki/DOT_language">DOT</a>,
which is a de-facto standard for graph generation.</p>
]]></content>
  </entry>
  
</feed>
