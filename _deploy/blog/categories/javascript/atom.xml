<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | Alessandro Nadalin]]></title>
  <link href="http://odino.org/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://odino.org/"/>
  <updated>2013-11-10T09:20:39+04:00</updated>
  <id>http://odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Securing your HTTP API with JavaScript Object Signing and Encryption]]></title>
    <link href="http://odino.org/securing-your-http-api-with-javascript-object-signing-and-encryption/"/>
    <updated>2013-06-04T00:31:00+04:00</updated>
    <id>http://odino.org/securing-your-http-api-with-javascript-object-signing-and-encryption</id>
    <content type="html"><![CDATA[<p>One thing that is always difficult, enough to
deserve <a href="http://www.amazon.com/Ajax-Security-Billy-Hoffman/dp/0321491939">its own book</a>,
is to <strong>secure HTTP API</strong> that interact with client-side
applications: today, after a discussion about how to face
the problem in our company, we bumped into the
<a href="http://datatracker.ietf.org/doc/draft-ietf-jose-json-web-signature/?include_text=1">JOSE</a>
&ndash; JavaScript Object Signing and Encryption &ndash;
specification.</p>

<!-- more -->


<p>Basically, the specification defines 4 entities:</p>

<ul>
<li>JWS, <a href="http://tools.ietf.org/html/draft-jones-json-web-signature-04">JSON Web Signature</a>,
a signed representation of data</li>
<li>JWT, <a href="http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html">JSON Web Token</a>,
a representation of data
(it differs from JWS as JWT is not signed)</li>
<li>JWE, <a href="http://self-issued.info/docs/draft-ietf-jose-json-web-encryption.html">JSON Web Encryption</a>,
an encrypted JSON representation of data</li>
<li>JWA, <a href="http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-00">JSON Web Algorithms</a>,
a list of safe algorithms to be used with JWS and JWE</li>
</ul>


<p>For the sake of basic knowledge, we will only have a look
at JWS and JWT / JWE now: the specifications about these
entities are quite extensive and not very straightforward,
so for further details you should <strong>really</strong> give them
a look.</p>

<p><img class="right" src="/images/jws.png"></p>

<h2>JWT</h2>

<p>Basically, the token (JWT) is the simplest structure
that you will deal with while implementing JOSE in our
architecture; it is a string representation of some data
base64 encoded (other types of encoding might be applied, but
this is not madatory): the JWT differs from raw base64-encoded
data since it also includes informations about the encoding
itself, in the token&rsquo;s header; by concatenating the base64-encoded
version of the token header and payload (the actual data) you
obtain what the specification calls <strong>signature input</strong>, which will
then be used to create the signature (JWS).</p>

<h2>JWS and JWE</h2>

<p>After the JWT comes the JWS, which is a signed representation
of the JWT; it differs from the token just because of the
signature; on an higher step of the ladder comes the JWE instead,
which lets you encrypt the data in order to achieve an higher security
level: the <a href="http://self-issued.info/docs/draft-ietf-jose-json-web-encryption.html#JWEExamples">examples in the ietf draft</a>
show you how to create JWEs with a pair of private /
public keys.</p>

<h2>Use case: how to authenticate stateless AJAX calls?</h2>

<p><img class="left" src="/images/jsw-auth.png"></p>

<p>One of the needs that you might have is to,
from JavaScript, make authenticated HTTP calls to
one of your webservices: since you don&rsquo;t want to
expose the WS credentials on the JS service (the
credentials would be readable by any client) a good
solution might be to generate a JWS with a private
OpenSSL key in your webservice, store it into a cookie
accessible to the JS service, which would execute
those calls including that cookie<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>, which you can then
verify while authenticating the call.</p>

<p>This workflow is pretty easy to understand, but the actual
implementation is more than tricky, since the
specification is quite abundant &ndash; especially about
encryption algorithms.</p>

<p>In PHP we can use at least 3 libraries: one of them,
<a href="https://github.com/ritou/php-Akita_JOSE">Akita_JOSE</a>,
is pretty old (since the last commit was more than
7 months ago) but is very understandable and quite
easy to use; another one, <a href="https://packagist.org/packages/gree/jose">gree/jose</a>,
has itw own package on packagist and can be easily
installed via composer: from a fast look at the
<a href="https://github.com/gree/jose">source code on GitHub</a> it looks good,
even though it needs the <a href="http://phpseclib.sourceforge.net/">phpsec</a>
library to be able to work<sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup>.</p>

<p>The third option, which is the one that <a href="https://github.com/namshi/jose">I built in the last couple of hours</a>,
is <a href="https://packagist.org/packages/namshi/jose">namshi/jose</a>,
which is very, very easy to use<sup id='fnref:3'><a href='#fn:3' rel='footnote'>3</a></sup>: it currently only
supports the <a href="https://github.com/namshi/jose/blob/master/src/Namshi/JOSE/Signer/RS256.php">RSA algorithm</a>
with <code>sha256</code> hashing, but I guess that implementing other
algorithms is less than trivial.</p>

<p>For example, let&rsquo;s see how you would generate the JWS
to be stored in a cookie:</p>

<p>``` php Generating a JWS after authentication and storing it into a cookie
&lt;?php</p>

<p>use Namshi\JOSE\JWS;</p>

<p>if ($username == &lsquo;correctUsername&rsquo; &amp;&amp; $pass = &lsquo;ok&rsquo;) {</p>

<pre><code>$user = Db::loadUserByUsername($username);

$jws  = new JWS('RS256');
$jws-&gt;setPayload(array(
    'uid' =&gt; $user-&gt;getid(),
));

$privateKey = openssl_pkey_get_private("file://path/to/private.key");
$jws-&gt;sign($privateKey);
setcookie('identity', $jws-&gt;getTokenString());
</code></pre>

<p>}
```</p>

<p>and then the apps that want to execute authenticated
calls on behalf of the user by using this cookie just need
to include it in these calls; the server will just need
to verify that the JWS in the cookie is valid:</p>

<p>``` php
&lt;?php</p>

<p>use Namshi\JOSE\JWS;</p>

<p>$jws        = JWS::load($_COOKIE[&lsquo;identity&rsquo;]);
$public_key = openssl_pkey_get_public(&ldquo;/path/to/public.key&rdquo;);</p>

<p>if ($jws->verify($public_key)) {</p>

<pre><code>$paylod = $jws-&gt;getPayload();

echo sprintf("Hey, my JS app just did an action authenticated as user #%s", $payload['id']);
</code></pre>

<p>}
```</p>

<p>That&rsquo;s it: far from being a stable library, this is more a
proof of concept that we, an Namshi, would like to see developing
in the next weeks / months.</p>

<p>As always, comments, rants or &ndash; even better &ndash; pull requests are
<strong>more than welcome</strong>!</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>One of the disadvantages of this approach is that it relies on cookies, only available in the HTTP protocol. If you want to use another protocol for you application - a very rare and extreme use case - this wouldn't work for you. <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>I honestly never heard of this library before, so I can't really say what it does and why it's needed <a href='#fnref:2' rev='footnote'>↩</a></li><li id='fn:3'>Since I'm not an expert in encryption and security, I would suggest to give it a look and come up with feedbacks <a href='#fnref:3' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Optimizing loading times with images' lazy loading]]></title>
    <link href="http://odino.org/optimizing-loading-times-with-images-lazy-loading/"/>
    <updated>2012-09-21T07:45:00+04:00</updated>
    <id>http://odino.org/optimizing-loading-times-with-images-lazy-loading</id>
    <content type="html"><![CDATA[<p>Sometimes I like to forget that I&rsquo;m
mainly involved in other things and
get my hands dirty with low-level
stuff: last week I wanted to improve
some existing lazy loading code we use
with JavaScript.</p>

<!-- more -->


<p>Let&rsquo;s suppose that we have a page
showing almost 100 images, 500kb
per image, 5MB of a webpage.</p>

<p>It&rsquo;s clearly unpractical to load
all the images at once, since you
would force the use to download
stuff that he would only see scrolling
down with the mouse, so the solution
would be to store all the images' path
in an HTML attribute and trigger the load
just for visible images in the current window.</p>

<p>You&rsquo;d have an HTML like this:</p>

<p>``` html
<html>
  <head></p>

<pre><code>...
</code></pre>

<p>  </head>
  <body></p>

<pre><code>...

...

&lt;div class="imgContainer" &gt;
    &lt;img class="lazy-loading" id="http://example.com/img1.jpg" /&gt;
&lt;/div&gt;
&lt;div class="imgContainer" &gt;
    &lt;img class="lazy-loading" id="http://example.com/img2.jpg" /&gt;
&lt;/div&gt;
&lt;div class="imgContainer" &gt;
    &lt;img class="lazy-loading" id="http://example.com/img3.jpg" /&gt;
&lt;/div&gt;
&lt;div class="imgContainer" &gt;
    &lt;img class="lazy-loading" id="http://example.com/img4.jpg" /&gt;
&lt;/div&gt;
&lt;div class="imgContainer" &gt;
    &lt;img class="lazy-loading" id="http://example.com/img5.jpg" /&gt;
&lt;/div&gt;
&lt;div class="imgContainer" &gt;
    &lt;img class="lazy-loading" id="http://example.com/img6.jpg" /&gt;
&lt;/div&gt;
...
...
...
</code></pre>

<p>  </body>
</html>
```</p>

<p>and the lazy laoding function looks like:</p>

<p>``` javascript
var lazyLoading = function(){</p>

<pre><code>$('img.lazy-loading').each(function(){            
    var distanceToTop = $(this).offset().top;
    var scroll        = $(window).scrollTop();
    var windowHeight  = $(window).height();
    var isVisible     = distanceToTop - scroll &lt; windowHeight;

    if (isVisible) {
        $(this).attr('src', $(this).attr('id'));
    }
});
</code></pre>

<p>}
```</p>

<p>As you see, we only trigger lazy loading for <strong>visible</strong>
items, which are appearing in the current window:
given the <code>windowHeight</code>, we calculate visibility
based on the difference between the item and
the mouse scroll, so that we can see whether the
product is comprehended in the current window
or not.</p>

<p>To trigger lazy loading you need to listen for
mouse scroll events <strong>and</strong> <code>domready</code> ( if some
images would be visible without scrolling ):</p>

<p>``` javascript
$(document).ready(function() {</p>

<pre><code>lazyLoading();

$(window).scroll(function() {
    lazyLoading();
});
</code></pre>

<p>});
```</p>

<p>We, at <a href="http://www.namshi.com/">Namshi</a>, use the same approach for
<a href="http://www.namshi.com/women-shoes/">catalog listing pages</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Human-readable user agents for JavaScript error reporting]]></title>
    <link href="http://odino.org/human-readable-user-agents-for-javascript-error-reporting/"/>
    <updated>2012-08-22T09:40:00+04:00</updated>
    <id>http://odino.org/human-readable-user-agents-for-javascript-error-reporting</id>
    <content type="html"><![CDATA[<p>Some time ago I published a few posts
on logging, one on how to <a href="/logging-javascript-errors/">report JavaScript errors</a> and another one
which illustrates how to <a href="/using-monolog-for-php-error-reporting-on-new-relic/">log on New Relic with Monolog</a>.</p>

<p>In this post I&rsquo;d like to go even
further with JavaScript error logging
and tell you how we &ndash; at <a href="http://namshi.com">Namshi</a> &ndash;
are trying to ease frontend debugging
across multiple browsers.</p>

<!-- more -->


<h2>User agents, the gotchas</h2>

<p>With JavaScript, it&rsquo;s pretty easy to detect
the user agent from a client ( you just need
to access <code>navigator.userAgent</code>), the problem
is that user agents are one of the most incredible
<em>gotchas</em> in web development.</p>

<p>For example, how would you guess that</p>

<p><code>
Mozilla/5.0
(Windows; U; Windows NT 6.1; WOW64; en-US; rv:2.0.4)
Gecko/20120718 AskTbAVR-IDW/3.12.5.17700 Firefox/14.0.1
</code></p>

<p>represents Firefox 14 on Windows 7?</p>

<p>Let me tell you, <strong>you wouldn&rsquo;t</strong>, that&rsquo;s why
you should convert user agents in a human-readable
format for the people who are going to debug
the frontend.</p>

<h2>Converting user agents with remote calls</h2>

<p>Luckily, <a href="http://www.useragentstring.com/">UserAgentString</a> is a service which allows
you to query them whenever you need to retrieve useful
and <strong>meaningful</strong> informations from a user agent string;
combined with <a href="http://guzzlephp.org/">Guzzle</a>, you can directly have meaningful
JavaScript errors' reports with a few lines of code.</p>

<p>For example, this is a simple class which retrieves the informations from
the service:</p>

<p>``` php
&lt;?php</p>

<p>namespace Vendor\Service;</p>

<p>use Guzzle\Http\ClientInterface;</p>

<p>class UserAgentConverter
{</p>

<pre><code>const URL_USERAGENT_API = 'http://www.useragentstring.com/';
const BROWSER_INFO      = '%s %s on %s';

protected $client;

/**
 * Instantiates the service and injects the HTTP client that will be used
 * to perform requests.
 * 
 * @param ClientInterface $client 
 */
public function __construct(ClientInterface $client)
{
    $this-&gt;client = $client;
}

/**
 * Retrieves a human-readable string identifying the $userAgent for error
 * reporting (ie Internet Explorer 8 on Windows 7).
 * 
 * @param string $userAgent
 * @return string|null
 */
public function lookup($userAgent)
{
    $request  = $this-&gt;client-&gt;post(self::URL_USERAGENT_API, null, sprintf('uas=%s&amp;getJSON=all', $userAgent));
    $response = $request-&gt;send();

    if ($response-&gt;getStatusCode() === 200) {
        return json_decode($response-&gt;getBody(true), true);
    }

    return null;
}
</code></pre>

<p>}
```</p>

<p>and you can use it like this:</p>

<p>``` php
&lt;?php</p>

<p>$ua         = &lsquo;Mozilla/5.0 (Windows; U; Windows NT 6.1; WOW64; en-US; rv:2.0.4) Gecko/20120718 AskTbAVR-IDW/3.12.5.17700 Firefox/14.0.1&rsquo;;
$uaService  = new Vendor\Service\UserAgentConverter(new Guzzle\Http\Client());
$userAgent  = $uaService->lookup($ua);</p>

<p>if ($userAgent) {</p>

<pre><code>// outputs "Firefox 14.0.1 on Windows 7"
echo sprintf(
    "%s %d on %s", 
    $userAgent['agent_name'],
    $userAgent['agent_version'],
    $userAgent['os_name']
);
</code></pre>

<p>}
```</p>

<p>That&rsquo;s pretty easy, even easier if you use the
<a href="/using-the-symfony2-dependency-injection-container-as-a-standalone-component/">dependency injection container of Symfony2</a>,
where you can just do the instantiation
in a config file:</p>

<p>``` bash container.yml
services:
  http.client:</p>

<pre><code>class: "Guzzle\\Http\\Client"
</code></pre>

<p>  useragent.converter:</p>

<pre><code>class: "Vendor\\Service\\UserAgentConverter"
arguments:
  client: @http.client
</code></pre>

<p>```</p>

<p>``` php The one liner to get the user agent&rsquo;s informations
&lt;?php</p>

<p>$container->get(&lsquo;useragent.converter&rsquo;)&ndash;>lookup($ua);
```</p>

<h2>Caching</h2>

<p>At this point it becomes obvious that you should put
a <strong>caching layer</strong> in front of the <code>UserAgentConverter</code>
since you don&rsquo;t want to always query a remote service
to retrieve informations that you already have:
something like Redis should perfectly do the job,
as a cache &ndash; in this scenario &ndash; is essential, needs
to be as fast as hell and you don&rsquo;t need a SLA with it,
so if the Redis server is down you are gracefully
degradating: at the same time, Memcache can be a good candidate
to substitute Redis, but remember that you will
renounce to persistence, since you won&rsquo;t be able to
store informations on the disk as you would
do with Redis.</p>

<p>The implementations is very trivial:</p>

<p>``` php Adding a caching layer to our code
&lt;?php</p>

<p>$ua         = &lsquo;Mozilla/5.0 (Windows; U; Windows NT 6.1; WOW64; en-US; rv:2.0.4) Gecko/20120718 AskTbAVR-IDW/3.12.5.17700 Firefox/14.0.1&rsquo;;
$cache      = new CacheProvider();
$userAgent  = $cache->lookup($ua)</p>

<p>if (!$userAgent) {</p>

<pre><code>$uaService  = new Vendor\Service\UserAgentConverter(new Guzzle\Http\Client());
$userAgent  = $uaService-&gt;lookup($ua);
</code></pre>

<p>}</p>

<p>if ($userAgent) {</p>

<pre><code>$cache-&gt;store($ua, $userAgent);

// outputs "Firefox 14.0.1 on Windows 7"
echo sprintf(
    "%s %d on %s", 
    $userAgent['agent_name'],
    $userAgent['agent_version'],
    $userAgent['os_name']
);
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Logging JavaScript errors]]></title>
    <link href="http://odino.org/logging-javascript-errors/"/>
    <updated>2012-07-27T09:00:00+04:00</updated>
    <id>http://odino.org/logging-javascript-errors</id>
    <content type="html"><![CDATA[<p>In one of my latest posts I talked about
<a href="/using-monolog-for-php-error-reporting-on-new-relic/">using Monolog to remotely log stuff on New Relic</a>:
getting a bit deeper on log management
systems, here&rsquo;s how we managed to report
JavaScript errors on our logs.</p>

<!-- more -->


<h2>A note on JavaScript errors</h2>

<p>It may not sound obvious, but errors,
in JavaScript, can be pretty nasty, since
it&rsquo;s an &ndash; almost completely<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup> &ndash; client-dependent
technology that can react differently to
your code based on the client&rsquo;s platform.</p>

<p>Cross-browser testing may not always be
performed <em>that</em> accurately, so you should
definitely start tracking JS error that may
happen of different clients.</p>

<h2>The concept</h2>

<p>This is <strong>totally not an idea of mine</strong>: it
comes from a pretty smart <a href="http://devblog.pipelinedeals.com/pipelinedeals-dev-blog/2012/2/12/javascript-error-reporting-for-fun-and-profit-1.html">blog post which illustrates the main concept</a>:
when a JS error is encountered, you trigger an HTTP request
to a URL that collect the data transmitted
within that request and logs it with
server-side code.</p>

<p>``` javascript How to trigger JS error reporting
window.MaximumErrorCount = 5;</p>

<p>window.onerror = function(errorMsg, file, lineNumber) {
  window.errorCount || (window.errorCount = 0);</p>

<p>  if (window.errorCount &lt;= window.MaximumErrorCount) {</p>

<pre><code>jQuery.post('/jsError/', {
    errorMessage:   errorMsg, 
    file:           file, 
    url:            window.location.href, 
    lineNumber:     lineNumber, 
    ua:             navigator.userAgent
});
</code></pre>

<p>  }
}
```</p>

<p>So, at the end, you only need to add some basic
server-side code to handle the reported data:</p>

<p>``` php How to handle reported informations
&lt;?php</p>

<p>class ErrorController extends Controller
{</p>

<pre><code>const MESSAGE_LOG_JAVASCRIPT = 'A javascript error "%s" has been encountered at the URL %s on file %s:%s by an agent of type %s';

public function logJavaScriptAction($postData)
{
    $logMessage = sprintf(
        self::MESSAGE_LOG_JAVASCRIPT,
        $postData['errorMessage'],
        $postData['url'],
        $postData['file'],
        $postData['lineNumber'],
        $postData['ua']
    );

    $this-&gt;getLogger()-&gt;addError($logMessage);
}
</code></pre>

<p>}
```</p>

<p>You may want to write some additional
code to only report errors that you should
really fix: based on the user-agent, for
example, you can ignore errors triggered
on <code>MSIE 7.0</code>/<code>MSIE 6.0</code>.</p>

<h2>All in all&hellip;</h2>

<p>This has been a great solution for us,
since we could easily keep track of JS
code which was causing errors due to:</p>

<ul>
<li>lack of compatibility between developers'/users'
platforms</li>
<li>typos and small errors</li>
<li>tricky situations in which our code depends on
3rd party scripts that would break our functionality
whenever they are not available/cause an error upon
execution</li>
</ul>


<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>NodeJS <a href='#fnref:1' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iMacro: JavaScript loops with variables]]></title>
    <link href="http://odino.org/imacro-javascript-loops-with-variables/"/>
    <updated>2010-12-01T02:03:00+04:00</updated>
    <id>http://odino.org/imacro-javascript-loops-with-variables</id>
    <content type="html"><![CDATA[<p><a href="https://addons.mozilla.org/en-US/firefox/addon/3863/">iMacro</a> is a cool firefox plugin able to record and play macros on the browser.</p>

<!-- more -->


<p><img class="right" src="/images/imacro.png"></p>

<p>It can be used as a <a href="http://c2.com/cgi/wiki?FunctionalTest">functional testing</a> tool, like <a href="http://seleniumhq.org/">Selenium</a> ( although Selenium is really better ), or as a showcase/annoying operation tool.</p>

<p>Today I faced it for the first time with the need to bomb URLs progressively, some bombing kinda like:</p>

<p>GET /news/1
GET /news/2
GET /news/3
for 16K urls¹.</p>

<p>Basically, what I needed was a loop with a variable.</p>

<p>Unfortunately, iMacro doesn&rsquo;t natively support for loops, but has bridges for any kind of language ( VBS, PHP, JavaScript&hellip; ) so I only needed to use a JS script ( which can be direcly run on iMacro&rsquo;s web interface):</p>

<p><code>javascript
for (i = 0; i &lt; N; i++)
{
  iimSet('-var_ID', i);
  iimPlay("/home/odino/iMacros/Macros/BombingIsCool.iim");
}
</code></p>

<p>the <code>BombingIsCoolMacro</code> simply goes to an URL with the imported variable ( ID ):</p>

<p><code>bash
URL GOTO=http://mydomain.com/news/
</code></p>
]]></content>
  </entry>
  
</feed>
