
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Profiling PHP applications from the browser - Alessandro Nadalin</title>
  <meta name="author" content="Alessandro Nadalin">

  
  <meta name="description" content="In my previous post I briefly spoke about
Webgrind,
a web-based profiler for PHP:
now I&rsquo;d like to spend some more time
giving an overview on &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://odino.github.io/profiling-php-applications-from-the-browser/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Alessandro Nadalin" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,400italic' rel='stylesheet' type='text/css'>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-7407627-3']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body    class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <img id="bio-picture" src="https://lh6.googleusercontent.com/-YgvT5_ULkUk/AAAAAAAAAAI/AAAAAAAAAWY/lIfaFw-9ZQo/s120-c/photo.jpg" />
  <h1><a href="/">Alessandro Nadalin</a></h1>
</hgroup>

<ul id="topmenu">
	<li>
		<a href="/about" >
			about
		</a>
	</li>
	<li>
		<a href="/conferences" >
			conferences
		</a>
	</li>
	<li>
		<a href="http://twitter.com/_odino_" >
			twitter
		</a>
	</li>
	<li>
		<a href="/archives" >
			archives
		</a>
	</li>
</ul>

</header>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Profiling PHP Applications From the Browser</h1>
    
  </header>




<span class="categories">
  
    <a class='category' href='/blog/categories/performances/'>performances</a>, <a class='category' href='/blog/categories/php/'>php</a>
  
</span>


<div class="entry-content"><p>In my <a href="/making-the-orientdb-odm-5-times-faster/">previous post</a> I briefly spoke about
<a href="https://github.com/jokkedk/webgrind">Webgrind</a>,
a web-based profiler for PHP:
now I&rsquo;d like to spend some more time
giving an overview on how to install
and use it, as well as <strong>what to look for
when profiling an application</strong>.</p>

<!-- more -->


<p><img class="right" src="/images/webgrind-call-graph-detail.png"></p>

<h2>Profiling in a few words</h2>

<p>As PHP developers, we are rarely used to
profiling: essentially, most of our
applications are not bound to extensive
CPU usage or insanely huge data-processing operations;
the scope of the language is very clear and
even though we <strong>might</strong> need to profile, once
in a while, it&rsquo;s unlikely that we will end up
having problems like
<a href="/book-review-data-intensive-text-processing-with-mapreduce/">optimizing MapReduce algorhitms</a>.</p>

<p>But sometimes we <strong>do</strong> need to profile,
and this will bring on the table bottlenecks of
your applications: within a session of inspection,
you will likely find optimizations that would lead to
a <code>20/30%</code> faster execution time, by just changing
your backend (PHP) code<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>.</p>

<h2>Why Webgrind</h2>

<p>Among all the available profilers for PHP, I
choose to go with Webgrind for a bunch of reasons:</p>

<ul>
<li>nowadays, I am mostly developing on a Mac<sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup>, so
<a href="http://kcachegrind.sourceforge.net/html/Home.html">KCacheGrind</a>
wasn&rsquo;t an option</li>
<li>I didn&rsquo;t want to install <a href="https://github.com/facebook/xhprof">XHPROF</a>
as it usually takes a few minutes,
even though is probably the best profiler for PHP: facebook uses it
<strong>in production</strong>, and it&rsquo;s able to generate a lot of reports that
would make you face performance optimizations from various perspectives</li>
<li>Webgrind offers a zero-setup installation</li>
</ul>


<h2>Installation with XDebug</h2>

<p><a href="http://xdebug.org/">XDebug</a> is a must for profiling, as it&rsquo;s
the tool through which we can generate the
<a href="http://valgrind.org/docs/manual/cg-manual.html">Cachegrind</a> files, that are basically reports
on the costs of your application&rsquo;s calls.</p>

<p>To enable XDebug&rsquo;s profiling you will have to
tweak your <code>php.ini</code>&rsquo;s configuration:</p>

<figure class='code'><figcaption><span>Enabling profiling with XDebug</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>xdebug.profiler_enable <span class="o">=</span> 1
</span></code></pre></td></tr></table></div></figure>


<p>Beware that profiling each request your application
processes can be an expensive job (pages that
would usually load in 2/3 seconds can take up to
10 seconds), so you should &ndash; instead of enabling
the profiler by default &ndash; activate the <code>enable_trigger</code>
directive, which will make XDebug profile your application
only if a specific <code>GET</code> or <code>POST</code> parameter is specified
within the request:</p>

<figure class='code'><figcaption><span>Using the XDebug profiler in enable trigger mode</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>xdebug.profiler_enable <span class="o">=</span> 0
</span><span class='line'>xdebug.profiler_enable_trigger <span class="o">=</span> 1
</span></code></pre></td></tr></table></div></figure>


<p>Dont forget to restart apache once you made the changes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo apachectl restart
</span></code></pre></td></tr></table></div></figure>


<p>By visiting your application and specifying a special
<code>GET</code> parameter in the URL, you will run your first
profiled PHP response: supposing that you want to
profile the code that runs <code>http://dev.project.com</code>,
just visit <code>http://dev.project.com?XDEBUG_PROFILE=true</code></p>

<p>Once you&rsquo;re done with the XDebug configuration, it&rsquo;s
time to install Webgrind:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd</span> /path/to/your/home/projects
</span><span class='line'>
</span><span class='line'>git clone git://github.com/jokkedk/webgrind.git
</span></code></pre></td></tr></table></div></figure>


<p>That&rsquo;s it!</p>

<p>You can now access Webgrind at
<code>127.0.0.1/webgrind</code> or &ndash; if you prefer &ndash;
set up a virtual host for it:</p>

<figure class='code'><figcaption><span>Setting up the virtualhost at</span><a href='http://webgrind/'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;VirtualHost *:80&gt;
</span><span class='line'>    DocumentRoot <span class="s2">&quot;/path/to/your/home/projects/webgrind&quot;</span>
</span><span class='line'>
</span><span class='line'>    ServerName webgrind
</span><span class='line'>
</span><span class='line'>    &lt;Directory <span class="s2">&quot;/path/to/your/home/projects/webgrind&quot;</span>&gt;
</span><span class='line'>        Options Indexes FollowSymLinks MultiViews
</span><span class='line'>        AllowOverride all
</span><span class='line'>        Order allow,deny
</span><span class='line'>        Allow from all
</span><span class='line'>    &lt;/Directory&gt;
</span><span class='line'>&lt;/VirtualHost&gt;
</span></code></pre></td></tr></table></div></figure>


<p>and have Webgrind running at
<code>http://webgrind/</code>.</p>

<h2>Looking at the results</h2>

<p><img class="right" src="/images/webgrind-select-file.png"></p>

<p>Once your application runs, XDebug will generate
the cachegrind files that Webgrind will analyze:
after each PHP response is served from your application,
you can inspect the results from the Webgrind interface,
by just selecting the first file of the list:
it might take some time for Webgrind to generate the
first report, as cachegrind files can easily size up to
100/200 megabytes (files below <code>~50MB</code> will be read in
10 seconds or so).</p>

<p>When the report is generated, you will see the results: I
strongly recommend to generate a report in <strong>milliseconds</strong>, as
it will give you a direct overview on how much time
a function takes rather than having this value as a percentage
compared to the entire application&rsquo;s run.</p>

<p><img class="center" src="/images/webgrind-expensive-call.png"></p>

<p>If you order results by <code>Total inclusive cost</code>, you will
exactly see which ones are the most expensive functions
of your applications: in the example, you will see that the
<code>Doctrine\ODM\OrientDB\Mapper::hydrate</code> method really
kills the performances of my application (<code>10.6</code> seconds).</p>

<p>Having this kind of report is not really useful, as
usually you need to dig deeper to understand which
exact step is making that function taking all that time:
you can investigate further by clicking on a function,
action that will open the call stack after that function
is called:</p>

<p><img class="center" src="/images/webgrind-call-stack.png"></p>

<p>as you see, the problems, here, lies in
<code>Doctrine\ODM\OrientDB\Mapper::createDocument</code> (<code>6.2</code> seconds)
and <code>Doctrine\ODM\OrientDB\Mapper::findClassMappingInDirectories</code>
(<code>4.3</code> seconds), so there you have the explanation why
<code>Doctrine\ODM\OrientDB\Mapper::hydrate</code> takes more than
10 seconds.</p>

<p>Then, take your time to investigate even further and make the
optimal changes in your application, run it with the
profiler enabled once more and have a look at the results:</p>

<p><img class="center" src="/images/webgrind-after-optimization.png"></p>

<p>As you see, after I tweaked my code,
<code>Doctrine\ODM\OrientDB\Mapper::hydrate</code> is not even the
most expensive function at all (<code>Sharah\Controller::getPartial</code> is),
and the previously performance-killer methods, which
would take <code>~6</code> and <code>~4</code> seconds, are now respectively
taking <code>~1</code> and <code>~0.1</code> seconds.</p>

<h2>The call graph</h2>

<p><img class="right" src="/images/webgrind-call-graph.png"></p>

<p>Another interesting feature of Webgrind<sup id='fnref:3'><a href='#fn:3' rel='footnote'>3</a></sup>
is the ability to generate a <strong>call graph</strong> to visualize
bottlenecks in the application: by having a look
at the graph you will have a top-down overview on
how much execution time (expressed in percentage)
a function will take.</p>

<p>When you look at it, you should question
every step of the graph and ask yourself is that
specific function should really take that amount
of time.</p>

<p>For example:</p>

<ul>
<li>if a controller takes <code>20%</code> of the time to run (called <code>TTR</code> from now on),
it might be that you have a design flaw, as it should be
the most expensive part of your application, calling
the models and rendering the view (which are <strong>included</strong> in
the calculated <code>TTR</code>)</li>
<li>if a model&rsquo;s method is taking <code>60% TTR</code>, there is a bad smell:
how come that just retrieving data <strong>once</strong> is taking
more than half of the <code>TTR</code>?</li>
<li>if bootstrapping the application takes <code>15% TTR</code>, then
it&rsquo;s fine, as that is usually the time a well-abstracted
framework needs to provide you a solid foundation to develop
on top of</li>
</ul>


<p>In the image above, you will see that <code>87%</code>
of the execution time is taken by the controller&rsquo;s
action (which is fine) and then equally
distributed (<code>10/20%</code>) across various other
functions that controller calls.</p>

<h2>Conclusions</h2>

<p><span class='pullquote-right' data-pullquote='sometimes the best design
is probably unpractical to perform
really well'>
This is not an extensive guide on profiling,
neither a fair comparison of PHP profilers
(as I said, I picked Webgrind, last night, more
because of the stress-free installation rather than
its actual capabilities<sup id='fnref:4'><a href='#fn:4' rel='footnote'>4</a></sup>), but I
hope it can give you a good quickstart guide
to start optimizing bottlenecks in your
applications.</p>

<p>One thing that I would really like to
point out is to <strong>stop useless optimizations</strong>:
there is no need to &ldquo;drop double quotes
in favour of single quotes&rdquo; because those
are such small optimizations that you
will <strong> never</strong> feel in your application;
create <a href="http://www.slideshare.net/arnoschn/rasmus-think-again-agile-framework-happy-php-developer-presentation-625122/73">useful benchmarks</a>
and always question your choices: running
a solid benchmark and profiling your
application properly will also
tell you that sometimes the best design
is probably unpractical to perform
really well.
</span></p>

<div class="footnotes">
<span>
Notes
</span>
    <ol>
        <li id='fn:1'>Beware that for high-scale applications you should focus on bigger and deeper improvements: see http://odino.org/rest-better-http-cache/ <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>Shame on me, I know <a href='#fnref:2' rev='footnote'>↩</a></li><li id='fn:3'>Which is implemented in every profiler I used so far <a href='#fnref:3' rev='footnote'>↩</a></li><li id='fn:4'>If you want to seriously profile your PHP application, go for XHPROF <a href='#fnref:4' rev='footnote'>↩</a></li>
    </ol>
</div>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Alessandro Nadalin</span></span>

      








  


<time datetime="2013-01-25T22:38:00+04:00" pubdate data-updated="true">Friday, 25 January 2013 at 22:38</time>
    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://odino.github.io/profiling-php-applications-from-the-browser/" data-via="_odino_" data-counturl="http://odino.github.io/profiling-php-applications-from-the-browser/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/making-the-orientdb-odm-5-times-faster/" title="Previous Post: Making the OrientDB ODM 5 times faster">&laquo; Making the OrientDB ODM 5 times faster</a>
      
      
        <a class="basic-alignment right" href="/php-the-script-tried-to-execute-a-method-or-access-a-property-of-an-incomplete-object/" title="Next Post: PHP: 'The script tried to execute a method or access a property of an incomplete object'">PHP: 'The script tried to execute a method or access a property of an incomplete object' &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Alessandro Nadalin -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'odino';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://odino.github.io/profiling-php-applications-from-the-browser/';
        var disqus_url = 'http://odino.github.io/profiling-php-applications-from-the-browser/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>




<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/javascripts/aharris.js"></script>

</body>
</html>
