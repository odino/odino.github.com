
<!doctype html>
<!-- BEGIN _layouts/default.html -->
<html>
	<head>
		<meta charset="utf-8">
		
		<meta content="Blog of Alex, technologist in Dubai: writing about Service Oriented Architectures, web APIs and development teams." name="description">
		<meta content="Alessandro Nadalin" name="author">
		
		<title>REST better: HTTP cache</title>
		<meta name="google-site-verification" content="dSNHLHJFQzKASjN8qHJisk2XLkKqbF_ilGSj9bscwKs" />
		<link href="/favicon.png" rel="icon">
		<link href="/stylesheets/screen.css" rel="stylesheet">
		<link href="/atom.xml" rel="alternate" title="Alessandro Nadalin" type="application/atom+xml">
		<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" type="text/css" href="/MyFontsWebfontsKit.css">

		<meta name="twitter:card" content="summary" />
		<meta name="twitter:creator" content="@_odino_" />
		<meta property="og:url" content="https://odino.org/rest-better-http-cache/" />
		<meta property="og:title" content="REST better: HTTP cache" />
		<meta property="og:description" content="Blog of Alex, technologist in Dubai: writing about Service Oriented Architectures, web APIs and development teams." />
		
	</head>
	<body>
		<div class="wrap">
			<header>
				<div class="navi">
					<ul>
                        <li><a href="/"><i class="icon-home icon-large"></i> Home</a></li>
                        <li><a href="/about"><i class="icon-user icon-large"></i> About</a></li>
                        <li><a href="/conferences"><i class="icon-group icon-large"></i> Conferences</a></li>
                        <li><a href="/archives"><i class="icon-briefcase icon-large"></i> Archives</a></li>
                        <li><a href="/atom.xml"><i class="icon-rss icon-large"></i> RSS</a></li>
					</ul>
				</div>
			</header>
			<!-- BEGIN _layouts/post.html -->

    <header>
        <h1><a href="/rest-better-http-cache/">REST better: HTTP cache</a></h1>
        <time>17 March 2011</time>
        <!-- 
        
        
        
          <br />
          <time>(note: this post was written 10 years ago and might be outdated)</time>
         -->
    </header>
<div class="entry-content "><p>HTTP has a widely-ignored <a href="http://tools.ietf.org/html/rfc2616#section-13">cache specification</a> which helps us implementing fast, scaleable and fault-tolerant services.</p>

<!-- more -->


<p>What does this have in common with REST?</p>

<p>Is that only because HTTP is a <strong>REST-loving protocol</strong>?</p>

<p>No.</p>

<p>Cache is the third constraint of the REST architectural style, and there&rsquo;s a reason behind it:</p>

<blockquote><p>The advantage of adding cache constraints is that they have the potential to partially or completely eliminate some interactions, improving efficiency, scalability, and user-perceived performance by reducing the average latency of a series of interactions.</p><footer><strong>Roy Fielding</strong> <cite><a href='http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_1_4'>Network Cache</a></cite></footer></blockquote>


<h2>Why caching?</h2>

<p>If you aren&rsquo;t convinced by Fielding&rsquo;s words, here are other explanations:</p>

<ul>
<li><strong>improve speed</strong>, because we want to deliver fast content to our consumer</li>
<li><strong>fault tolerance</strong>, because we want our service to deliver content also when it encounters internal failures</li>
<li><strong>scalability</strong>, because the WWW scales to bilions of consumers through hypermedia documents and we just want to do the same thing</li>
<li><strong>reduce server load</strong>, because we don&rsquo;t want our servers to compute without the need of it</li>
</ul>


<h2>Types of cache</h2>

<p>There are a few types of caches, but not all of them fit well in a qualitative architecture:</p>

<h3>Local cache</h3>

<p><img class="right" src="/images/browser-cache.png"></p>

<p>It&rsquo;s a cache a single consumer implements.</p>

<p>When you surf an http-cache-loving service with the browser cache activated, you should be able to experience significant speed improvements when requesting the same page more than once: that&rsquo;s because your browser, according to the response&rsquo;s caching headers, has a local copy of the response on your machine, and when you request the page the second time it uses that local copy instead of making a real request over the network.</p>

<p>Needless to say, improvements on local caches can be obtained by using an <em>in-memory</em> caching strategy rather that a disk-persisting one.</p>

<h2>Proxy cache</h2>

<p>You may confuse proxy cache with gateway one: I&rsquo;m gonna talk about the latter in a few lines.</p>

<p>Proxy caches are shared caches that, for instance, your company can install in front of your firewall in order to store many resources, from many origin servers, on behalf of every agent in your company.</p>

<p>The difference between local and proxy cache is that the former can&rsquo;t serve more than one agent, so 2 identical requests from 2 consumers behind the same network effectively hit the origin server twice: again, needless to say, proxy caches serve cached responses slower than local ones.</p>

<h3>Application cache</h3>

<p><img class="right" src="/images/symfony-cache.png"></p>

<p>Oh, WTF.</p>

<p>This kind of caches are evil: we spent the last 15 years of web development on developing frameworks with their own super-cocky caching layer.</p>

<p>Although they might help reducing the web&rsquo;s inconsistency, they&rsquo;re <strong>a needless way to waste effort</strong>: the HTTP specification and the software implementing it ( some web frameworks, reverse proxies and browsers ) are the standard tools we should use in order to deliver cached content.</p>

<p>If we aren&rsquo;t satisfied by this tools, we can think about implementing a caching layer over our software, but <strong>only in this case</strong>.</p>

<p>You are probably wondering why I hate application caches, and the answer it&rsquo;s easy: you don&rsquo;t need to mantain a browser, nor a proxy, nor a reverse one; that means that without LoCs you have an efficient caching layer upon your architecture, for free. Thanks, HTTP.</p>

<p>Another reason I hate application cache is because it couples a peculiarity of your architecture ( being cacheable ) with the application at the base of it: that means that changing the implementation will change your architecture capabilities.</p>

<p>Are you OK with that? Well, I&rsquo;m not: <strong>loose over strong coupling</strong>, one of our primary goals.</p>

<h3>Gateway cache</h3>

<p><img class="right" src="/images/proxy-cache.jpg"></p>

<p>A gateway cache is a cache served by a proxy installed on the server side, called <em>reverse proxy</em>.</p>

<p>It&rsquo;s different from the proxy cache, in which the proxy stands into the client side: the advantage of implementing a gateway cache is that you can share the cache generated by a client with any other client of the planet doing the same request.</p>

<h2>A few words on WWW&rsquo;s inconsistency</h2>

<p>Cache introduces <strong>inconsistency</strong>, which is the situation that occurs when a resource served to a consumer is different from the one actually held by the server.</p>

<p>Crap, you say, and that&rsquo;s true, but is also the reason behind a system serving bilions of users with an unimaginable amount of data, <strong>the WWW</strong>.</p>

<p>You must be ok with this assumption: if you need consistency we will see later how to couple <strong>caching with high consistency</strong> ( keep in mind the word <a href="http://www.w3.org/TR/esi-lang">ESI</a> ).</p>

<h2>Caching headers</h2>

<p>There are a few HTTP headers you can use to specify caching rules for your resources: here&rsquo;s a recap about them.</p>

<h3>Expires</h3>

<p>Used in HTTP responses, the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21"><code>Expires</code>  header</a> tells the client when the resource is going to expire.</p>

<p>Usually, this headers has a date value that specifies from when the resource will be considered <em>stale</em> ( possibly out-of-date ), and so it needs to be revalidated.</p>

<p>In order to avoid caching of the response, this header can contain other values, like:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Expires:  0</span></code></pre></td></tr></table></div></figure>


<p>or a date that equals the one in the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.18"><code>Date</code> header</a>.</p>

<p>When you want to mark the resource cacheable for long times, you can specify a date up to one year in the future.</p>

<p>The &ldquo;<em>one year</em>&rdquo; time is a constraint, as the HTTP spec says:</p>

<blockquote><p>To mark a response as &#8220;never expires,&#8221; an origin server sends an Expires date approximately one year from the time the response is sent.<br/>HTTP/1.1 servers SHOULD NOT send Expires dates more than one year in the future.</p></blockquote>


<h3>Cache-Control</h3>

<p>CC is a powerful header to manage your caching directives and strategies: is a way of combining different directives about the response&rsquo;s cache.</p>

<p>The cool thing about CC is that <strong>it can be also used in requests</strong>, so, for example, if your consumer wants to be sure that the data he is receiving are consistent, he can specify an header like the following:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Cache-Control:  no-cache</span></code></pre></td></tr></table></div></figure>


<p>which basically tells all the caching layers to revalidate the response with the origin server.</p>

<h3>Etag</h3>

<p>The etag is a unique identifier for your response: it is used on <a href="http://www.odino.org/292/don-t-rape-http-if-none-match-the-412-http-status-code">conditional requests</a>, usually when a clients GETs a resource he also has in cache, sending to the origin server this identifier ( in the <code>If-None-Match</code> header in this case ).</p>

<h3>Last-Modified</h3>

<p>If <code>Date</code> is the header which tells when the resource has been firstly generated, <code>Last-Modified</code> tells us when it has been&hellip;   ..well, you guessed it.</p>

<h2>More about the Cache-Control</h2>

<p>As I said, the CC header combines different directives for specifying a caching strategy, that I briefly explain now.</p>

<p>If you want to specify how long should the response considered valid you use the <code>max-age</code> directive, available for local caches.</p>

<p>The corrisponding for shared caches ( proxies ) is <code>s-maxage</code>: the value of both is expressed in seconds.</p>

<p>If you want to make the response cacheable by both local and shared caches you declare it as <code>public</code>, while if you don&rsquo;t want to make it cacheable by proxies you should declare it <code>private</code>.</p>

<p>Yes, <strong>private doesn&rsquo;t mean not cacheable</strong>: that is achieved by using the <code>no-store</code> directive.</p>

<p>A weird story short, I tend to avoid the no-cache instruction because it&rsquo;s interpreted in different ways by different caches.</p>

<p>If you want to always revalidate your cached copy you should use <code>must-revalidate</code> for local caches, <code>proxy-revalidate</code> for proxy caches: that&rsquo;s useful when you have frequently updates on a resource and its etag is cheap to generate, so you spend some computation for comparing the etag with the <code>If-None-Match</code> header and telling the client the response has, or hasn&rsquo;t, been modified.</p>

<p>A smart instruction, for requests, is the <code>only-if-cached</code> one, when, usually, you deal with slow connectivity:</p>

<blockquote><p>In some cases, such as times of extremely poor network connectivity, a client may want a cache to return only those responses that it currently has stored, and not to reload or revalidate with the origin server.<br/>To do this, the client may include the only-if-cached directive in a request. If it receives this directive, a cache SHOULD either respond using a cached entry that is consistent with the other constraints of the request, or respond with a 504 (Gateway Timeout) status.<br/>However, if a group of caches is being operated as a unified system with good internal connectivity, such a request MAY be forwarded within that group of caches.</p><footer><strong>HTTP specification</strong> <cite><a href='http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.4'>Cache Revalidation and Reload Controls</a></cite></footer></blockquote>


<p><code>stale-while-revalidate</code> has a value, expressed in seconds, which tells that the cache should release a stale response ( out-of-date ) if the request has come during the specified ( as I said, in seconds ) interval, while <code>stale-if-error</code> has an identical behaviour but it deals with errors contanting the origin server: this directives spread <strong>availability over consistency</strong>.</p>

<p>Theory is always annoying, so let&rsquo;s see them in practice.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Cache-Control: public, max-age=600, s-maxage=3600</span></code></pre></td></tr></table></div></figure>


<p>A response with the above CC means that the response:</p>

<ul>
<li>is cacheable by local and shared caches</li>
<li>is cacheable for 10 minutes for local caches</li>
<li>is cacheable for 1 hour for shared caches</li>
</ul>


<p>while</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Cache-Control: no-store</span></code></pre></td></tr></table></div></figure>


<p>tells that the response is <strong>not cacheable at all</strong>.</p>

<p>Talking about availability over consistency, the following</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Cache-Control: stale-while-revalidate=60, stale-if-error=7200, public</span></code></pre></td></tr></table></div></figure>


<p>is really interesting; it basically says that the response:</p>

<ul>
<li>is cacheable by local and shared caches</li>
<li>if it has expired in less that a minute, the cached copy can be released while persisting the original request to the origin server</li>
<li>if the request encounters an error and the cached copy has expired in less than 2 hours, the cached copy can be released to the client</li>
</ul>


<h2>Caching strategies</h2>

<blockquote><p>There are only two hard things in Computer Science: cache invalidation and naming things.<br/>dealing with cache consistency should be pretty hard.</p><footer><strong>Phil Karlton</strong> <cite><a href='http://martinfowler.com/bliki/TwoHardThings.html'>Two Hard Things</a></cite></footer></blockquote>


<p>You have to 2 ways to improve data&rsquo;s consistency: cache validation and expiration: only if you implement a mix between validation ( which basically asks you to specify the <code>Etag</code> and <code>Last-Modified</code> headers ) and expiration ( with the <code>Expires</code> header or some <code>Cache-Control</code> directives ) you&rsquo;re going to increase consistency between cached content and actual data.</p>

<h2>Edge Side Includes</h2>

<p>ESI, or <em>edge side includes</em>, is a specification introduced by Akamai and Oracle in 2001, which tries to solve the problem of composite webpages.</p>

<p>What is a composite? It is a resource which is composed by the aggregation of N resources, through server side includes ( not SSI ).</p>

<p>The typical ESI tag looks like the following one:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;esi:include</span> <span class="na">src=</span><span class="s">&quot;http://www.acme.com/odino&quot;</span> <span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>and basically tells a proxy that, before releasing a response it should make an HTTP request to the specified <code>src</code> and substitute the esi tag with the response.</p>

<p>ESI helps you having a working and effective gateway cache, because it lets you share a cached resource not only between different clients, but also between different requests.</p>

<p>Granularity FTW.</p>

<p>Another advatage, <strong>ESI improves response&rsquo;s consistency</strong>, because it lets you specify caching strategies for single resources that compose another one that you may declare not cacheable: the requested resource isn&rsquo;t cacheable, but some of the data it contains can be retrieved from the cache.</p>

<p>Needless to say, proxies understanding ESI tags are always put in front of our architecture, <strong>on the server side</strong>.</p>

<h2>Pushing ESI to the next level</h2>

<p>The next step in improving the web cache is to move ESI capable proxies to the clients&#8217; side: that would mean that a browser cache or a proxy cache would be able to receive responses with ESI tags and process it.</p>

<p>This would <strong>dramatically improve consistency and performances</strong>, because we would push cached copies more near to the client, but specifying different TTL ( time to live ) for the response fragments.</p>

<p>There&rsquo;s only a minor problem: actually, proxy and local caches don&rsquo;t understand very well ESI tags; for instance, any browser isn&rsquo;t able to process an ESI tag.</p>

<p>But the biggest problem is that <strong>there&rsquo;s no standard media type which embeds ESI tags in the response</strong>, so we would basically send our response, embedding ESI tags, with a custom and widely-unknown media format.</p>

<p>At the <a href="http://www.symfony-live.com/">Symfony Live</a> conference I talked with Symfony creator, <a href="http://fabien.potencier.org/">Fabien Potencier</a>, on the possibility of writing a media format for web responses which need to embed ESI tags: my goal is to start to define a standard for this kind of technology.</p>

<p><strong>Missing a standardized format is evil</strong>: you are basically ignoring the <a href="http://linkednotbound.net/2010/07/19/self-descriptive-hypermedia/">self descriptiveness</a> constraint of REST, making your architecture hard to consume, discover and mantain. And since self descriptiveness is one of the main actors behind REST&rsquo;s WSDL ( yes, <strong>REST has WSDL</strong>, composed by self-descriptiveness, hypermedia formats, media types and DAP<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup> ), you&rsquo;re missing a huge part of the service.</p>

<h2>People started to like HTTP cache</h2>

<blockquote><p>[The goal is to] never generate the same response twice.</p><footer><strong>Ryan Tomayko</strong> <cite><a href='http://tomayko.com/writings/rack-cache-announce'>Introducing Rack Cache</a></cite></footer></blockquote>


<p>People, get over application cache and re-inventing the wheel: popular tools like Ruby&rsquo;s Rack ( well, that&rsquo;s because of the great mind of <a href="http://tomayko.com/writings/rack-cache-announce">Ryan Tomayko</a> ) and PHP&rsquo;s <a href="http://symfony.com/doc/2.0/book/http_cache.html">Symfony2</a> RAD framework are abandoning application caches in favour of the HTTP caching mechanism.</p>

<h2>Resources</h2>

<p>You should really read Subbu Allamaraju&rsquo;s articles about <a href="http://www.subbu.org/blog/2005/01/http-caching">HTTP caching</a>.</p>

<p><a href="http://oreilly.com/catalog/9780596805838">REST in practice</a> has a cool chapter dealing with <strong>scaling through HTTP caching</strong>.</p>

<p>And remember:</p>

<blockquote><p>Make a reasonable guess. Whenever caching is involved, there is a possibility that the content that the end user is receiving is stale. Is this acceptable or not? It depends.</p><footer><strong>Subbu Allamaraju</strong> <cite><a href='http://www.subbu.org/blog/2005/01/more-on-http-caching'>More on HTTP Caching</a></cite></footer></blockquote>




<div class="footnotes">
<span>
Notes
</span>
    <ol>
        <li id='fn:1'>Domain Application Protocols <a href='#fnref:1' rev='footnote'>↩</a></li>
    </ol>
</div>

</div>



<div class="recent entry-content">
  <hr class="divider-cazzuto">
  <h3>
    In the mood for some more reading?
  </h3>
  <ul>
    
      <li><a href="/dell-xps-13-9310-usb-c-port-not-recognizing-external-devices/">Dell XPS 13 9310: USB-C port not recognizing external devices</a> (25 July 2021)</li>
    
      <li><a href="/book-review-working-backwards/">Book review: Working Backwards</a> (24 July 2021)</li>
    
      <li><a href="/fwupd-is-the-best-thing-that-ever-happened-to-linux/">fwupd is the best thing that ever happened to Linux</a> (15 April 2021)</li>
    
      <li><a href="/avoid-battery-draining-on-your-linux-flavored-dell-xps/">Avoid battery draining on your Linux-flavored Dell XPS</a> (31 January 2021)</li>
    
      <li><a href="/combining-two-numbers-into-a-unique-one-pairing-functions/">Combining two numbers into a unique one: pairing functions</a> (05 December 2020)</li>
    
      <li><a href="/running-ci-tests-in-kubernetes-through-github-actions/">Running CI tests in Kubernetes through Github Actions</a> (20 March 2020)</li>
    
      <li><a href="/ive-decided-to-make-the-wasec-ebook-free-during-these-trying-times/">I've decided to make the WASEC ebook free during these trying times</a> (20 March 2020)</li>
    
  </ul>
    <p>
      ...or <a href="/archives/">check the archives</a>.
    </p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/anchor-js/3.2.0/anchor.min.js"></script>
<script type="text/javascript" />
(function () {
  'use strict';

  anchors.options = {
    placement: 'left',
    visible: 'hover',
    icon: '¶'
  };

  anchors.add('h2');
  anchors.add('h3');
  anchors.add('h4');

})();
</script>

			<footer>
				<center>
	Copyleft <!--[if lte IE 8]><span style="filter: FlipH; -ms-filter: "FlipH"; display: inline-block;"><![endif]--><span style="-moz-transform: scaleX(-1); -o-transform: scaleX(-1); -webkit-transform: scaleX(-1); transform: scaleX(-1); display: inline-block;">©</span><!--[if lte IE 8]></span><![endif]--> 2021 — Alessandro Nadalin
	<address>
	</address>
</center>
			</footer>
		</div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-7407627-3', 'auto');
      ga('send', 'pageview');
	</script>
	
	<script type="application/ld+json">
		{
		"@context": "https://schema.org/",
		"@type": "BlogPosting",
		"mainEntityOfPage": {
			"@type": "WebPage",
			"@id": "https://odino.org/rest-better-http-cache/"
		},
		"headline": "REST better: HTTP cache",
		"description": "Blog of Alex, technologist in Dubai: writing about Service Oriented Architectures, web APIs and development teams.",
		
		"author": {
			"@type": "Person",
			"name": "Alessandro Nadalin"
		},
		"datePublished": "2011-03-17 14:12:00 +0000"
		}
	</script>
	
	</body>
</html>
<!-- END _layouts/default.html -->
