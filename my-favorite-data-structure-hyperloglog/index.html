
<!doctype html>
<!-- BEGIN _layouts/default.html -->
<html>
	<head>
		<meta charset="utf-8">
		
		<meta content="One of the most amazing algorithms that were ever invented -- how to efficiently count unique things" name="description">
		<meta content="Alessandro Nadalin" name="author">
		
		<title>My favorite algorithm (and data structure): HyperLogLog</title>
		<meta name="google-site-verification" content="dSNHLHJFQzKASjN8qHJisk2XLkKqbF_ilGSj9bscwKs" />
		<link href="/favicon.png" rel="icon">
		<link href="/stylesheets/screen.css" rel="stylesheet">
		<link href="/atom.xml" rel="alternate" title="Alessandro Nadalin" type="application/atom+xml">
		<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" type="text/css" href="/MyFontsWebfontsKit.css">

		<meta name="twitter:card" content="summary" />
		<meta name="twitter:creator" content="@_odino_" />
		<meta property="og:url" content="https://odino.org/my-favorite-data-structure-hyperloglog/" />
		<meta property="og:title" content="My favorite algorithm (and data structure): HyperLogLog" />
		<meta property="og:description" content="One of the most amazing algorithms that were ever invented -- how to efficiently count unique things" />
		
	</head>
	<body>
		<div class="wrap">
			<header>
				<div class="navi">
					<ul>
                        <li><a href="/"><i class="icon-home icon-large"></i> Home</a></li>
                        <li><a href="/about"><i class="icon-user icon-large"></i> About</a></li>
                        <li><a href="/conferences"><i class="icon-group icon-large"></i> Conferences</a></li>
                        <li><a href="/archives"><i class="icon-briefcase icon-large"></i> Archives</a></li>
                        <li><a href="/atom.xml"><i class="icon-rss icon-large"></i> RSS</a></li>
					</ul>
				</div>
			</header>
			<!-- BEGIN _layouts/post.html -->

    <header>
        <h1><a href="/my-favorite-data-structure-hyperloglog/">My favorite algorithm (and data structure): HyperLogLog</a></h1>
        <time>13 January 2018</time>
        <!-- 
        
        
        
          <br />
          <time>(note: this post was written 3 years ago and might be outdated)</time>
         -->
    </header>
<div class="entry-content "><p>Every now and then I bump into a concept that&rsquo;s so simple and powerful that I want
to stab my brain for missing out on such an incredible and beautiful idea.</p>

<p>I discovered <a href="https://en.wikipedia.org/wiki/HyperLogLog">HyperLogLog</a> (HLL) a
couple years ago and fell in love with it right after reading how
<a href="http://antirez.com/news/75">redis decided to add a HLL data structure</a>:
the idea behind HLL is devastatingly simple but extremely powerful, and it&rsquo;s
what makes it such a widespread algorithm, used by giants of the internet such
as Google and Reddit.</p>

<!-- more -->


<h2>So, what&rsquo;s your phone number?</h2>

<p>My friend Tommy and I planned to go to a conference and, while heading to
its location, decide to wager on who will talk to the most strangers.
So once we reach the place we start conversing around and keep a counter of
how many people we talk to.</p>

<p><img class="center" src="/images/networking-event.png"></p>

<p>At the end of the event Tommy comes to me with his figure (17) and I tell him
that I had a word with 46 people: I clearly am the winner, but Tommy&rsquo;s frustrated
as he thinks I&rsquo;ve counted the same people multiple times, as he only saw me with
15/20 people in total. So, the wager&rsquo;s off and we decide that,
for our next event, we&rsquo;ll be taking down names instead, so that we&rsquo;re sure we&rsquo;re
going to be counting unique people, and not just the total number of conversations.</p>

<p>At the end of the following conference we enthusiastically meet each other with
a very long list of names and, guess what, Tommy had a couple more encounters
than I did! We both laugh it off and while discussing our approach to counting
uniques, Tommy comes up with a great idea:</p>

<blockquote><p>Alex, you know what? We can&#8217;t go around with pen and paper and track down a list of names, it&#8217;s really impractical!<br/>Today I spoke to 65 different people and counting their names on this paper was a real pain in the back&#8230;I lost count 3 times and had to start from scratch!</p></blockquote>




<blockquote><p>Yeah, I know, but do we even have an alternative?</p></blockquote>




<blockquote><p>What if, for our next conference, instead of asking for names, we ask people the last 5 digits of their phone number?</p><p>Now, follow me: instead of winning by counting their names, the winner will be the one who spoke to someone with the longest sequence of leading zeroes in those digits.</p></blockquote>




<blockquote><p>Wait Tommy, you&#8217;re going too fast! Slow down a second and give me an example&#8230;</p></blockquote>




<blockquote><p>Sure, just ask people for those last 5 digits, ok? Let&#8217;s suppose you get 54701.<br/>No leading zero, so the longest sequence of zeroes for you is 0.</p><p>The next person you talk to tells you it&#8217;s 02561 &#8211; that&#8217;s a leading zero! So your longest sequence comes to 1.</p></blockquote>




<blockquote><p>You&#8217;re starting to make sense to me&#8230;</p></blockquote>




<blockquote><p>Yeah, so if we speak to a couple people, chances are that are longest zero-sequence will be 0. But if we talk to ~10 people, we have more chances of it being 1.</p><p>Now, imagine you tell me your longest zero-sequence is 5 &#8211; you must have spoken to thousands of people to find someone with 00000 in their phone number!</p></blockquote>




<blockquote><p>Dude, you&#8217;re a damn genius!</p></blockquote>


<p>And that, my friends, is how HyperLogLog fundamentally works: it allows us to
estimate uniques within a large dataset by recording the longest sequence of
zeroes within that set. This ends up creating an incredible advantage over keeping
track of each and every element in the set, making it an incredibly efficient way
to count unique values with relatively high accuracy:</p>

<blockquote><p>The HyperLogLog algorithm can estimate cardinalities well beyond 10^9 with a relative accuracy (standard error) of 2% while only using 1.5kb of memory.</p><footer><strong>Fangjin Yang</strong> <cite><a href='http://druid.io/blog/2012/05/04/fast-cheap-and-98-right-cardinality-estimation-for-big-data.html'>Fast, Cheap, and 98% Right: Cardinality Estimation for Big Data</a></cite></footer></blockquote>


<p>Since this is the usual me oversimplifying things
that I find hard to understand, let&rsquo;s have a look at some more details of HLL.</p>

<h2>More HLL details</h2>

<p>HLL is part of a family of algorithms that aim to address
<a href="https://en.wikipedia.org/wiki/Count-distinct_problem">cardinality estimation</a>,
otherwise known as <em>count-distinct problem</em>,
which are extremely useful for lots of today&rsquo;s web applications &mdash; for example
when you want to count how many unique views an article on your site has generated.</p>

<p>When HLL runs, it takes your input data and hashes it, turning into a bit
sequence:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>IP address of the viewer: 54.134.45.789
</span><span class='line'>
</span><span class='line'>HLL hash: 010010101010101010111010...</span></code></pre></td></tr></table></div></figure>


<p>Now, an important part of HLL is to make sure that your hashing function
distributes bits as evenly as possible, as you don&rsquo;t want to use a weak function
such as:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">hash</span><span class="p">(</span><span class="nx">ip</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">let</span> <span class="nx">h</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">ip</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/\D/g</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">).</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">h</span> <span class="o">+=</span> <span class="nx">number</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span>
</span><span class='line'>  <span class="p">})</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="nx">h</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>A HLL using this hashing function would return biased results if, for example,
the <a href="https://stackoverflow.com/a/277537/934439">distribution of your visitors is tied to a specific geographic region</a>.</p>

<p>The <a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf">original paper</a>
has a few more details on what a good hashing function means for HLL:</p>

<blockquote><p>All known efficient cardinality estimators rely on randomization, which is ensured by the use of hash functions.</p><p>The elements to be counted belonging to a certain data domain D, we assume given a hash function, h : D → {0, 1}∞; that is, we assimilate hashed values to infinite binary strings of {0, 1}∞, or equivalently to real numbers of the unit interval.</p><p>[&#8230;]</p><p>We postulate that the hash function has been designed in such a way that the hashed values closely resemble a uniform model of randomness, namely, bits of hashed values are assumed to be independent and to have each probability [0.5] of occurring.</p><footer><strong>Philippe Flajolet</strong> <cite><a href='http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf'>HyperLogLog: The Analysis of a Near-optimal Cardinality Estimation Algorithm</a></cite></footer></blockquote>


<p>Now, after we&rsquo;ve picked a suitable hash function we need to address another pitfall:
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>.</p>

<p>Going back to our example, imagine that the first person you talk to at the conference
tells you their number ends with <code>00004</code> &mdash; jackpot! You might have won a wager
against Tommy, but if you use this method in real life chances are that specific
data in your set will negatively influence the estimation.</p>

<p>Fear no more, as this is <strong>a problem HLL was born to solve</strong>: not many are aware that <a href="https://en.wikipedia.org/wiki/Philippe_Flajolet">Philippe
Flajolet</a>, one of the brains behind HLL, was quite involved in cardinality-estimation
problems for a long time, long enough to have come up with the <a href="https://en.wikipedia.org/wiki/Flajolet%E2%80%93Martin_algorithm#Improving_accuracy">Flajolet-Martin
algorithm in 1984</a> and
<a href="http://algo.inria.fr/flajolet/Publications/DuFl03-LNCS.pdf">(super-)LogLog in 2003</a>,
which already addressed some of the problems with outlying hashed values by dividing
measurements into buckets, and (somewhat) averaging values across buckets.</p>

<p>If you got lost here, let me go back to our original example: instead of just
taking the last 5 digits of a phone number, we take 6 of them and store the longest
sequence of leading zeroes together with the first digit (the bucket). This means
that our data will look like:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">Input</span><span class="o">:</span>
</span><span class='line'><span class="mi">708942</span> <span class="o">--&gt;</span> <span class="k">in</span> <span class="nx">the</span> <span class="mi">7</span><span class="nx">th</span> <span class="nx">bucket</span><span class="p">,</span> <span class="nx">the</span> <span class="nx">longest</span> <span class="nx">sequence</span> <span class="nx">of</span> <span class="nx">zeroes</span> <span class="nx">is</span> <span class="mi">1</span>
</span><span class='line'><span class="mi">518942</span> <span class="o">--&gt;</span> <span class="k">in</span> <span class="nx">the</span> <span class="mi">5</span><span class="nx">th</span> <span class="nx">bucket</span><span class="p">,</span> <span class="nx">the</span> <span class="nx">longest</span> <span class="nx">sequence</span> <span class="nx">of</span> <span class="nx">zeroes</span> <span class="nx">is</span> <span class="mi">0</span>
</span><span class='line'><span class="mi">500973</span> <span class="o">--&gt;</span> <span class="k">in</span> <span class="nx">the</span> <span class="mi">5</span><span class="nx">th</span> <span class="nx">bucket</span><span class="p">,</span> <span class="nx">the</span> <span class="nx">longest</span> <span class="nx">sequence</span> <span class="nx">of</span> <span class="nx">zeroes</span> <span class="nx">is</span> <span class="nx">now</span> <span class="mi">2</span>
</span><span class='line'><span class="mi">900000</span> <span class="o">--&gt;</span> <span class="k">in</span> <span class="nx">the</span> <span class="mi">9</span><span class="nx">th</span> <span class="nx">bucket</span><span class="p">,</span> <span class="nx">the</span> <span class="nx">longest</span> <span class="nx">sequence</span> <span class="nx">of</span> <span class="nx">zeroes</span> <span class="nx">is</span> <span class="mi">5</span>
</span><span class='line'><span class="mi">900672</span> <span class="o">--&gt;</span> <span class="k">in</span> <span class="nx">the</span> <span class="mi">9</span><span class="nx">th</span> <span class="nx">bucket</span><span class="p">,</span> <span class="nx">the</span> <span class="nx">longest</span> <span class="nx">sequence</span> <span class="nx">of</span> <span class="nx">zeroes</span> <span class="nx">stays</span> <span class="mi">5</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Buckets</span><span class="o">:</span>
</span><span class='line'><span class="mi">0</span><span class="o">:</span> <span class="mi">0</span>
</span><span class='line'><span class="mi">1</span><span class="o">:</span> <span class="mi">0</span>
</span><span class='line'><span class="mi">2</span><span class="o">:</span> <span class="mi">0</span>
</span><span class='line'><span class="mi">3</span><span class="o">:</span> <span class="mi">0</span>
</span><span class='line'><span class="mi">4</span><span class="o">:</span> <span class="mi">0</span>
</span><span class='line'><span class="mi">5</span><span class="o">:</span> <span class="mi">2</span>
</span><span class='line'><span class="mi">6</span><span class="o">:</span> <span class="mi">0</span>
</span><span class='line'><span class="mi">7</span><span class="o">:</span> <span class="mi">1</span>
</span><span class='line'><span class="mi">8</span><span class="o">:</span> <span class="mi">0</span>
</span><span class='line'><span class="mi">9</span><span class="o">:</span> <span class="mi">5</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Output</span><span class="o">:</span>
</span><span class='line'><span class="nx">avg</span><span class="p">(</span><span class="nx">buckets</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.8</span>
</span></code></pre></td></tr></table></div></figure>


<p>As you see, if we weren&rsquo;t employing buckets we would instead use 5 as the longest
sequence of zeroes, which would negatively impact our estimation: even though I
simplified the math behind buckets (it&rsquo;s not just a simple average), you can
totally see how this approach makes sense.</p>

<p>It&rsquo;s interesting to see how Flajolet addresses variance throughout his
works:</p>

<blockquote><p>While we&#8217;ve got an estimate that&#8217;s already pretty good, it&#8217;s possible to get a lot better. Durand and Flajolet make the observation that outlying values do a lot to decrease the accuracy of the estimate; by throwing out the largest values before averaging, accuracy can be improved.</p><p>Specifically, by throwing out the 30% of buckets with the largest values, and averaging only 70% of buckets with the smaller values, accuracy can be improved from 1.30/sqrt(m) to only 1.05/sqrt(m)! That means that our earlier example, with 640 bytes of state and an average error of 4% now has an average error of about 3.2%, with no additional increase in space required.</p><p>Finally, the major contribution of Flajolet et al in the HyperLogLog paper is to use a different type of averaging, taking the harmonic mean instead of the geometric mean we just applied. By doing this, they&#8217;re able to edge down the error to  1.04/sqrt(m), again with no increase in state required.</p><footer><strong>Nick Johnson</strong> <cite><a href='http://blog.notdot.net/2012/09/Dam-Cool-Algorithms-Cardinality-Estimation'>Improving Accuracy: SuperLogLog and HyperLogLog</a></cite></footer></blockquote>


<h2>HLL in the wild</h2>

<p>So, where can we find HLLs? Two great web-scale examples are:</p>

<ul>
<li><a href="https://cloud.google.com/blog/big-data/2017/07/counting-uniques-faster-in-bigquery-with-hyperloglog">BigQuery</a>,
to efficiently count uniques in a table (<code>APPROX_COUNT_DISTINCT()</code>)</li>
<li><a href="https://redditblog.com/2017/05/24/view-counting-at-reddit/">Reddit</a>, where it&rsquo;s used to calculate how many unique views a post has gathered</li>
</ul>


<p>In particular, see how HLL impacts queries on BigQuery:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>SELECT COUNT<span class="o">(</span>DISTINCT actor.login<span class="o">)</span> exact_cnt
</span><span class='line'>FROM <span class="sb">`</span>githubarchive.year.2016<span class="sb">`</span>
</span><span class='line'>&gt; 6,610,026 <span class="o">(</span>4.1s elapsed, 3.39 GB processed, 320,825,029 rows scanned<span class="o">)</span>
</span><span class='line'>
</span><span class='line'>SELECT APPROX_COUNT_DISTINCT<span class="o">(</span>actor.login<span class="o">)</span> approx_cnt
</span><span class='line'>FROM <span class="sb">`</span>githubarchive.year.2016<span class="sb">`</span>
</span><span class='line'>&gt; 6,643,627 <span class="o">(</span>2.6s elapsed, 3.39 GB processed, 320,825,029 rows scanned<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The second result is an approximation (with an error rate of ~0.5%), but takes
a fraction of the time.</p>

<p>Long story short: <strong>HyperLogLog is amazing!</strong> You now know what it is and when it can be
used, so go out and do incredible stuff with it!</p>

<h2>Just before you leave&hellip;</h2>

<p>One thing I&rsquo;d like to clarify is that even though I&rsquo;ve referred to HLL as a data structure before, it
should be noted that it is an algorithm first, while some databases (eg. Redis, Riak, BigQuery)
have implemented their own data structures based on HLL (so while saying HLL is a data structure is technically incorrect, it&rsquo;s also not
entirely wrong).</p>

<h2>Further readings</h2>

<ul>
<li><a href="https://en.wikipedia.org/wiki/HyperLogLog">HyperLogLog on Wikipedia</a></li>
<li>the <a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf">original paper</a></li>
<li><a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/40671.pdf">HyperLogLog++, Google&rsquo;s improved implementation of HLL</a></li>
<li><a href="http://antirez.com/news/75">Redis new data structure: the HyperLogLog</a></li>
<li><a href="http://blog.notdot.net/2012/09/Dam-Cool-Algorithms-Cardinality-Estimation">Damn Cool Algorithms: Cardinality Estimation</a></li>
<li><a href="https://github.com/basho/riak_kv/blob/develop/docs/hll/hll.pdf">HLL data types in Riak</a></li>
<li><a href="http://tech.adroll.com/blog/data/2013/07/10/hll-minhash.html">HyperLogLog and MinHash</a></li>
</ul>

</div>



<div class="recent entry-content">
  <hr class="divider-cazzuto">
  <h3>
    In the mood for some more reading?
  </h3>
  <ul>
    
      <li><a href="/dell-xps-13-9310-usb-c-port-not-recognizing-external-devices/">Dell XPS 13 9310: USB-C port not recognizing external devices</a> (25 July 2021)</li>
    
      <li><a href="/book-review-working-backwards/">Book review: Working Backwards</a> (24 July 2021)</li>
    
      <li><a href="/fwupd-is-the-best-thing-that-ever-happened-to-linux/">fwupd is the best thing that ever happened to Linux</a> (15 April 2021)</li>
    
      <li><a href="/avoid-battery-draining-on-your-linux-flavored-dell-xps/">Avoid battery draining on your Linux-flavored Dell XPS</a> (31 January 2021)</li>
    
      <li><a href="/combining-two-numbers-into-a-unique-one-pairing-functions/">Combining two numbers into a unique one: pairing functions</a> (05 December 2020)</li>
    
      <li><a href="/running-ci-tests-in-kubernetes-through-github-actions/">Running CI tests in Kubernetes through Github Actions</a> (20 March 2020)</li>
    
      <li><a href="/ive-decided-to-make-the-wasec-ebook-free-during-these-trying-times/">I've decided to make the WASEC ebook free during these trying times</a> (20 March 2020)</li>
    
  </ul>
    <p>
      ...or <a href="/archives/">check the archives</a>.
    </p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/anchor-js/3.2.0/anchor.min.js"></script>
<script type="text/javascript" />
(function () {
  'use strict';

  anchors.options = {
    placement: 'left',
    visible: 'hover',
    icon: '¶'
  };

  anchors.add('h2');
  anchors.add('h3');
  anchors.add('h4');

})();
</script>

			<footer>
				<center>
	Copyleft <!--[if lte IE 8]><span style="filter: FlipH; -ms-filter: "FlipH"; display: inline-block;"><![endif]--><span style="-moz-transform: scaleX(-1); -o-transform: scaleX(-1); -webkit-transform: scaleX(-1); transform: scaleX(-1); display: inline-block;">©</span><!--[if lte IE 8]></span><![endif]--> 2021 — Alessandro Nadalin
	<address>
	</address>
</center>
			</footer>
		</div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-7407627-3', 'auto');
      ga('send', 'pageview');
	</script>
	
	<script type="application/ld+json">
		{
		"@context": "https://schema.org/",
		"@type": "BlogPosting",
		"mainEntityOfPage": {
			"@type": "WebPage",
			"@id": "https://odino.org/my-favorite-data-structure-hyperloglog/"
		},
		"headline": "My favorite algorithm (and data structure): HyperLogLog",
		"description": "One of the most amazing algorithms that were ever invented -- how to efficiently count unique things",
		
		"author": {
			"@type": "Person",
			"name": "Alessandro Nadalin"
		},
		"datePublished": "2018-01-13 21:09:00 +0000"
		}
	</script>
	
	</body>
</html>
<!-- END _layouts/default.html -->
