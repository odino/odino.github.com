<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: log management | Alessandro Nadalin]]></title>
  <link href="http://odino.org/blog/categories/log-management/atom.xml" rel="self"/>
  <link href="http://odino.org/"/>
  <updated>2014-02-27T16:20:07-05:00</updated>
  <id>http://odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Human-readable user agents for JavaScript error reporting]]></title>
    <link href="http://odino.org/human-readable-user-agents-for-javascript-error-reporting/"/>
    <updated>2012-08-22T09:40:00-04:00</updated>
    <id>http://odino.org/human-readable-user-agents-for-javascript-error-reporting</id>
    <content type="html"><![CDATA[<p>Some time ago I published a few posts
on logging, one on how to <a href="/logging-javascript-errors/">report JavaScript errors</a> and another one
which illustrates how to <a href="/using-monolog-for-php-error-reporting-on-new-relic/">log on New Relic with Monolog</a>.</p>

<p>In this post I&rsquo;d like to go even
further with JavaScript error logging
and tell you how we &ndash; at <a href="http://namshi.com">Namshi</a> &ndash;
are trying to ease frontend debugging
across multiple browsers.</p>

<!-- more -->


<h2>User agents, the gotchas</h2>

<p>With JavaScript, it&rsquo;s pretty easy to detect
the user agent from a client ( you just need
to access <code>navigator.userAgent</code>), the problem
is that user agents are one of the most incredible
<em>gotchas</em> in web development.</p>

<p>For example, how would you guess that</p>

<p><code>
Mozilla/5.0
(Windows; U; Windows NT 6.1; WOW64; en-US; rv:2.0.4)
Gecko/20120718 AskTbAVR-IDW/3.12.5.17700 Firefox/14.0.1
</code></p>

<p>represents Firefox 14 on Windows 7?</p>

<p>Let me tell you, <strong>you wouldn&rsquo;t</strong>, that&rsquo;s why
you should convert user agents in a human-readable
format for the people who are going to debug
the frontend.</p>

<h2>Converting user agents with remote calls</h2>

<p>Luckily, <a href="http://www.useragentstring.com/">UserAgentString</a> is a service which allows
you to query them whenever you need to retrieve useful
and <strong>meaningful</strong> informations from a user agent string;
combined with <a href="http://guzzlephp.org/">Guzzle</a>, you can directly have meaningful
JavaScript errors' reports with a few lines of code.</p>

<p>For example, this is a simple class which retrieves the informations from
the service:</p>

<p>``` php
&lt;?php</p>

<p>namespace Vendor\Service;</p>

<p>use Guzzle\Http\ClientInterface;</p>

<p>class UserAgentConverter
{</p>

<pre><code>const URL_USERAGENT_API = 'http://www.useragentstring.com/';
const BROWSER_INFO      = '%s %s on %s';

protected $client;

/**
 * Instantiates the service and injects the HTTP client that will be used
 * to perform requests.
 * 
 * @param ClientInterface $client 
 */
public function __construct(ClientInterface $client)
{
    $this-&gt;client = $client;
}

/**
 * Retrieves a human-readable string identifying the $userAgent for error
 * reporting (ie Internet Explorer 8 on Windows 7).
 * 
 * @param string $userAgent
 * @return string|null
 */
public function lookup($userAgent)
{
    $request  = $this-&gt;client-&gt;post(self::URL_USERAGENT_API, null, sprintf('uas=%s&amp;getJSON=all', $userAgent));
    $response = $request-&gt;send();

    if ($response-&gt;getStatusCode() === 200) {
        return json_decode($response-&gt;getBody(true), true);
    }

    return null;
}
</code></pre>

<p>}
```</p>

<p>and you can use it like this:</p>

<p>``` php
&lt;?php</p>

<p>$ua         = &lsquo;Mozilla/5.0 (Windows; U; Windows NT 6.1; WOW64; en-US; rv:2.0.4) Gecko/20120718 AskTbAVR-IDW/3.12.5.17700 Firefox/14.0.1&rsquo;;
$uaService  = new Vendor\Service\UserAgentConverter(new Guzzle\Http\Client());
$userAgent  = $uaService->lookup($ua);</p>

<p>if ($userAgent) {</p>

<pre><code>// outputs "Firefox 14.0.1 on Windows 7"
echo sprintf(
    "%s %d on %s", 
    $userAgent['agent_name'],
    $userAgent['agent_version'],
    $userAgent['os_name']
);
</code></pre>

<p>}
```</p>

<p>That&rsquo;s pretty easy, even easier if you use the
<a href="/using-the-symfony2-dependency-injection-container-as-a-standalone-component/">dependency injection container of Symfony2</a>,
where you can just do the instantiation
in a config file:</p>

<p>``` bash container.yml
services:
  http.client:</p>

<pre><code>class: "Guzzle\\Http\\Client"
</code></pre>

<p>  useragent.converter:</p>

<pre><code>class: "Vendor\\Service\\UserAgentConverter"
arguments:
  client: @http.client
</code></pre>

<p>```</p>

<p>``` php The one liner to get the user agent&rsquo;s informations
&lt;?php</p>

<p>$container->get(&lsquo;useragent.converter&rsquo;)&ndash;>lookup($ua);
```</p>

<h2>Caching</h2>

<p>At this point it becomes obvious that you should put
a <strong>caching layer</strong> in front of the <code>UserAgentConverter</code>
since you don&rsquo;t want to always query a remote service
to retrieve informations that you already have:
something like Redis should perfectly do the job,
as a cache &ndash; in this scenario &ndash; is essential, needs
to be as fast as hell and you don&rsquo;t need a SLA with it,
so if the Redis server is down you are gracefully
degradating: at the same time, Memcache can be a good candidate
to substitute Redis, but remember that you will
renounce to persistence, since you won&rsquo;t be able to
store informations on the disk as you would
do with Redis.</p>

<p>The implementations is very trivial:</p>

<p>``` php Adding a caching layer to our code
&lt;?php</p>

<p>$ua         = &lsquo;Mozilla/5.0 (Windows; U; Windows NT 6.1; WOW64; en-US; rv:2.0.4) Gecko/20120718 AskTbAVR-IDW/3.12.5.17700 Firefox/14.0.1&rsquo;;
$cache      = new CacheProvider();
$userAgent  = $cache->lookup($ua)</p>

<p>if (!$userAgent) {</p>

<pre><code>$uaService  = new Vendor\Service\UserAgentConverter(new Guzzle\Http\Client());
$userAgent  = $uaService-&gt;lookup($ua);
</code></pre>

<p>}</p>

<p>if ($userAgent) {</p>

<pre><code>$cache-&gt;store($ua, $userAgent);

// outputs "Firefox 14.0.1 on Windows 7"
echo sprintf(
    "%s %d on %s", 
    $userAgent['agent_name'],
    $userAgent['agent_version'],
    $userAgent['os_name']
);
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Logging JavaScript errors]]></title>
    <link href="http://odino.org/logging-javascript-errors/"/>
    <updated>2012-07-27T09:00:00-04:00</updated>
    <id>http://odino.org/logging-javascript-errors</id>
    <content type="html"><![CDATA[<p>In one of my latest posts I talked about
<a href="/using-monolog-for-php-error-reporting-on-new-relic/">using Monolog to remotely log stuff on New Relic</a>:
getting a bit deeper on log management
systems, here&rsquo;s how we managed to report
JavaScript errors on our logs.</p>

<!-- more -->


<h2>A note on JavaScript errors</h2>

<p>It may not sound obvious, but errors,
in JavaScript, can be pretty nasty, since
it&rsquo;s an &ndash; almost completely<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup> &ndash; client-dependent
technology that can react differently to
your code based on the client&rsquo;s platform.</p>

<p>Cross-browser testing may not always be
performed <em>that</em> accurately, so you should
definitely start tracking JS error that may
happen of different clients.</p>

<h2>The concept</h2>

<p>This is <strong>totally not an idea of mine</strong>: it
comes from a pretty smart <a href="http://devblog.pipelinedeals.com/pipelinedeals-dev-blog/2012/2/12/javascript-error-reporting-for-fun-and-profit-1.html">blog post which illustrates the main concept</a>:
when a JS error is encountered, you trigger an HTTP request
to a URL that collect the data transmitted
within that request and logs it with
server-side code.</p>

<p>``` javascript How to trigger JS error reporting
window.MaximumErrorCount = 5;</p>

<p>window.onerror = function(errorMsg, file, lineNumber) {
  window.errorCount || (window.errorCount = 0);</p>

<p>  if (window.errorCount &lt;= window.MaximumErrorCount) {</p>

<pre><code>jQuery.post('/jsError/', {
    errorMessage:   errorMsg, 
    file:           file, 
    url:            window.location.href, 
    lineNumber:     lineNumber, 
    ua:             navigator.userAgent
});
</code></pre>

<p>  }
}
```</p>

<p>So, at the end, you only need to add some basic
server-side code to handle the reported data:</p>

<p>``` php How to handle reported informations
&lt;?php</p>

<p>class ErrorController extends Controller
{</p>

<pre><code>const MESSAGE_LOG_JAVASCRIPT = 'A javascript error "%s" has been encountered at the URL %s on file %s:%s by an agent of type %s';

public function logJavaScriptAction($postData)
{
    $logMessage = sprintf(
        self::MESSAGE_LOG_JAVASCRIPT,
        $postData['errorMessage'],
        $postData['url'],
        $postData['file'],
        $postData['lineNumber'],
        $postData['ua']
    );

    $this-&gt;getLogger()-&gt;addError($logMessage);
}
</code></pre>

<p>}
```</p>

<p>You may want to write some additional
code to only report errors that you should
really fix: based on the user-agent, for
example, you can ignore errors triggered
on <code>MSIE 7.0</code>/<code>MSIE 6.0</code>.</p>

<h2>All in all&hellip;</h2>

<p>This has been a great solution for us,
since we could easily keep track of JS
code which was causing errors due to:</p>

<ul>
<li>lack of compatibility between developers'/users'
platforms</li>
<li>typos and small errors</li>
<li>tricky situations in which our code depends on
3rd party scripts that would break our functionality
whenever they are not available/cause an error upon
execution</li>
</ul>


<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>NodeJS <a href='#fnref:1' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Monolog for PHP error reporting on New Relic]]></title>
    <link href="http://odino.org/using-monolog-for-php-error-reporting-on-new-relic/"/>
    <updated>2012-07-27T08:00:00-04:00</updated>
    <id>http://odino.org/using-monolog-for-php-error-reporting-on-new-relic</id>
    <content type="html"><![CDATA[<p>I <strong>do</strong> really like <a href="http://newrelic.com/">New Relic</a>, a real-time
error reporting solution available for many
platforms, so a few days ago I decided to
integrate it with <a href="https://github.com/Seldaek/monolog/">Monolog</a>, the other
main logging tool that we use here at
Rocket.</p>

<!-- more -->


<p>The idea behind it is very simple: since
New Relic is not always available on
development platforms, you first verify
that the PHP extension is loaded, then,
if it is, log a report on New Relic:
if the extension is not available, another
logging handler will act as a fallback.</p>

<p>To reach our goal we will simply need the
New Relic PHP extension, Monolog and the
Symfony2 <a href="http://symfony.com/doc/current/book/service_container.html">dependency injection container</a>.</p>

<h2>Catching the error and reporting it</h2>

<p>Let&rsquo;s start with a real world example, you
have a controller action that receives some
<code>POST</code> data and throws an exception whenever
the input data is missing some values<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>.</p>

<p>``` php A simple action
&lt;?php</p>

<p>namespace Application\Webservice;</p>

<p>use Application\MVC\Controller as BaseController;
use Application\Webservice\Exception;</p>

<p>class Controller extends BaseController
{</p>

<pre><code>public function updateDatabaseData(array $data)
{
    try {
        $this-&gt;validateData($data);

        // ...
    } catch (Exception $e) {
        $this-&gt;container-&gt;get('logger.new-relic')-&gt;error($e-&gt;getMessage(), $data);
    }
}
</code></pre>

<p>}
```</p>

<p>So, at this point, we just need to define the <code>logger.new-relic</code>
service in the DIC configuration file:</p>

<p>``` yml The DIC configuration file
services:
  logger.new-relic:</p>

<pre><code>class: "Monolog\\Logger"
arguments:
  name: "new-relic"
calls:
  - [ pushHandler, [@log.handler.new-relic] ]
</code></pre>

<p>  log.handler.new-relic:</p>

<pre><code>class:  "\\Application\\Log\\Handler\\NewRelic"
calls:
  - [ setFallbackHandler, [@log.handler.standard] ]
</code></pre>

<p>  log.handler.standard:</p>

<pre><code>class:  "Monolog\\Handler\\StreamHandler"
arguments:
  stream: "/tmp/error-log.txt"
</code></pre>

<p>```</p>

<p>As you see we define a Monolog logger designed
specifically for New Relic (<code>logger.new-relic</code>)
and an handler that will try to log everything
on the remote NR server: this handler also has a
fallback handler, if the New Relic PHP extension is
not available, which is configurable directly
within the YAML file (<code>log.handler.error</code>).</p>

<h2>The log handler</h2>

<p>The New Relic handler is <strong>really</strong>
straightforward:</p>

<p>``` php The New Relic log handler
&lt;?php</p>

<p>/<em>*
 * Class used to log on New Relic.
 </em>/</p>

<p>namespace Application\Log\Handler;</p>

<p>use Monolog\Handler\AbstractProcessingHandler;
use Monolog\Handler;</p>

<p>class NewRelic extends AbstractProcessingHandler
{</p>

<pre><code>protected $fallbackHandler;

/**
 * Logs a $record on New Relic, providing additional parameters from the
 * record's context.
 * If the New Relic extension is not available and a fallback handler is
 * provided, it will simply log the error with a fallback.
 * 
 * @param array $record 
 */
protected function write(array $record)
{
    if (extension_loaded('newrelic')) {
        newrelic_notice_error($record['message']);

        foreach ($record['context'] as $key =&gt; $parameter) {
            newrelic_add_custom_parameter($key, $parameter);
        }
    } elseif ($this-&gt;fallbackHandler instanceOf AbstractProcessingHandler) {
        $this-&gt;fallbackHandler-&gt;write($record);
    }
}

/**
 * Sets the fallback handler to be used to log informations if the New Relic
 * extension is not available.
 *
 * @param Monolog\Handler\AbstractProcessingHandler $handler 
 */
public function setFallbackHandler(AbstractProcessingHandler $handler)
{
    $this-&gt;fallbackHandler = $handler;
}
</code></pre>

<p>}
```</p>

<p>So, the code is pretty simple: we implement the <code>write</code> method
of <code>AbstractProcessingHandler</code> in our <code>New Relic</code> class,
using New Relic&rsquo;s low level functions to notice the
error and add some more informations about the
context surrounding the exception: the fallback
handler will take stage only if the New Relic
extension isn&rsquo;t loaded.</p>

<h2>Log systems and analysis</h2>

<p>Simple but pretty useful: if you use either
New Relic or Monolog I strongly recommend you
to integrate into your log management system
the missing tool since:</p>

<ul>
<li>New Relic serves as a nice reporting tool,
giving you an overview of the amount of
errors logged over some time, letting you
define tresholds for error reporting and
grouping errors to measure the impact a code
change can have on your applications<sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup></li>
<li>Monolog gives you a great abstraction and
log handlers, which can very easily ease
your job in taking the right action for
different types of errors<sup id='fnref:3'><a href='#fn:3' rel='footnote'>3</a></sup>
(as you saw, with the DIC it&rsquo;s pure joy to
instantiate and use different handlers based
on a configuration file)</li>
</ul>


<p>At Rocket Turkey &amp; MENA we really care about logs:
being a product-based company, <strong>a bug in our
system is a bug on our core business</strong>, so we need
to easily be able to spot problems.</p>

<p>So far, using Monolog and New Relic as both standalone and combined
products has been a very good choice, since with
New Relic with have a pretty overview about
error reporting, while Monolog gives us the
ability to easily debug problems in our
integrations, since solving problems with all
the data we track with it it&rsquo;s really easier,
and if we need to change logs' format or add new data
to the logs because we notice that it would speed
up troubleshooting and log analysis, making
the change is relatively easy, since it&rsquo;s a
really well OOP-written library.</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>Bare in mind that I will be very brief in my examples, so you won&rsquo;t learn how to bootstrap the DIC here, for example <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>I say applications since, as you may know, in New Relic you can handle multiple machines to be registered as different applications (like frontend/backend/mail server/cron slave/gateway) <a href='#fnref:2' rev='footnote'>↩</a></li><li id='fn:3'>In fact,whenever an email is not delivered by your email sever, it&rsquo;s not a problem, but when you start seeing that the amount of mails that are not delivered are too much, you may consider to use a critical handler, specifically designed to send an SMS/email to some contacts <a href='#fnref:3' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
</feed>
