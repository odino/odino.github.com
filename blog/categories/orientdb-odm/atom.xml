<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Category: Orientdb-odm | Alessandro Nadalin]]></title>
  <link href="http://odino.org/blog/categories/orientdb-odm/atom.xml" rel="self"/>
  <link href="http://odino.org/"/>
  <updated>2014-03-04T06:33:24-05:00</updated>
  <id>http://odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Making the OrientDB ODM 5 Times Faster]]></title>
    <link href="http://odino.org/making-the-orientdb-odm-5-times-faster/"/>
    <updated>2013-01-25T17:39:00-05:00</updated>
    <id>http://odino.org/making-the-orientdb-odm-5-times-faster</id>
    <content type="html"><![CDATA[<p>Today, after heavily testing performances
on a project, I pushed some small but
precious changes to the
<a href="https://github.com/doctrine/orientdb-odm">orientdb-odm</a>.</p>

<!-- more -->


<h2>Prelude</h2>

<p><blockquote><p>Premature optimization is the root of all evil</p><footer><strong>Donald Knuth <a href="http://c2.com/cgi/wiki?PrematureOptimization">http://c2.com/cgi/wiki?PrematureOptimization</a> C2 wiki</strong></footer></blockquote></p>

<p>In these days I was testing performances of a
service I am building with
<a href="https://github.com/nuvolabase/orientdb">OrientDB</a>
and the doctrine ODM that
<a href="/please-welcome-the-doctrine-orientdb-odm/">we built so far</a>.</p>

<p>Following one of the golden rules for software
architects, we didn&rsquo;t paid attention to performances &ndash; at first &ndash;
but rather went for a design which would allow us
to inject behaviours and easily change portions of code
(also thanks to the <a href="https://travis-ci.org/doctrine/orientdb-odm">test suite</a>),
I knew that I would have noticed huge flaws at
performance level when testing it with
<strong>production data</strong>.</p>

<p>A few days ago we committed fetchplans for repository
classes, but it wasnt enough: rather then concentrating
on which data we should fetch, I realized one major
improvement could be applied on how we <strong>map</strong> data.</p>

<h2>The golden rule</h2>

<p>Surround your pullquote like this {" text to be quoted "}</p>

<h2>How we did it</h2>

<p>With a <a href="https://github.com/doctrine/orientdb-odm/commit/df875c946e02a9c84eee22f0c86e0a3b06bd70ec">single commit</a>
&ndash; there&rsquo;s always room for improvements &ndash; the ODM is now able
to hydrate objects <strong>5 times faster</strong>: when you hydrate similar
objects from OrientDB (for example, 2 records that share the same
attributes' values, like <code>is_published</code> or <code>country</code>), there is
no need to duplicate operations, so we added a <a href="https://github.com/doctrine/orientdb-odm/blob/df875c946e02a9c84eee22f0c86e0a3b06bd70ec/src/Doctrine/OrientDB/Util/Inflector/Cached.php">cached inflector</a>
(with an in-memory / single request cache) and did some other
improvements to the <code>Mapper</code>:</p>

<ul>
<li>cached the relations between <a href="https://github.com/doctrine/orientdb-odm/commit/df875c946e02a9c84eee22f0c86e0a3b06bd70ec#L0L297">PHP classes and OrientDB classes</a> (if 2 records of the same OrientDB class are hydrated, there is only one single <em>search</em> operation to find the PHP class that should map them)</li>
<li>cached the <a href="https://github.com/doctrine/orientdb-odm/commit/df875c946e02a9c84eee22f0c86e0a3b06bd70ec#L0L223">casting of properties</a> (if 2 objects have the same value for the <code>is_published</code> attribute, casting is done once)</li>
<li>cached <a href="https://github.com/doctrine/orientdb-odm/commit/df875c946e02a9c84eee22f0c86e0a3b06bd70ec#L0L466">properties' annotations</a> (property-level annotations are inspected once per class)</li>
</ul>


<p>There is no rocket science in what we did, but benchmarks ensure that
it&rsquo;s a <strong>huge performance improvement</strong>.</p>

<h2>By the way, we used Webgrind</h2>

<p><img class="right" src="/images/webgrind.png"></p>

<p>Doing almost all of my work from a Mac, I kind of
missed <a href="http://kcachegrind.sourceforge.net/html/Home.html">KCacheGrind</a>
for profiling, so I was looking for an
alternative (no, installing
<a href="https://github.com/facebook/xhprof">XHPROF</a> isn&rsquo;t an alternative at 2 in the morning)
and I found Webgrind (which is cross-platform), a web profiler
that requires zero setup:
you basically just need to provide it access from the webserver
and, by opening it with a browser, the application automatically
launches and parses the cachegrind files generated by XDebug.</p>

<p>Webgrind&rsquo;s code is a bit of a mess, but then, the
result is still pretty good &ndash; you get a good overview
of the expensiveness of your calls as well as a
call graph compiled in <a href="http://en.wikipedia.org/wiki/DOT_language">DOT</a>,
which is a de-facto standard for graph generation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Starting to Play With the Doctrine OrientDB ODM]]></title>
    <link href="http://odino.org/starting-to-play-with-the-doctrine-orientdb-odm/"/>
    <updated>2013-01-20T23:00:00-05:00</updated>
    <id>http://odino.org/starting-to-play-with-the-doctrine-orientdb-odm</id>
    <content type="html"><![CDATA[<p>Since I am actively playing around with it, I
wanted to share some snippets to use the
<a href="https://github.com/doctrine/orientdb-odm">Doctrine OrientDB ODM</a>
in your PHP applications.</p>

<!-- more -->


<h2>Prelude</h2>

<p>In the last few weeks I&rsquo;ve started working,
for fun <strong>and</strong> profit, to a personal project,
nothing really exciting as of now.</p>

<p>The thing is, since I wanted to get back on some
cool piece of software, I decided to go for
OrientDB for the persistence and a
mini-framework <em>a-la</em> Symfony2 as foundation for the
PHP application &ndash; I actually considered NodeJS first,
but I need a prototype in 2 months so&hellip;</p>

<p>Point being, I&rsquo;d like to share with you my basic
approach to the OrientDB ODM.</p>

<h2>The container</h2>

<p>Given I&rsquo;ve been inspired to Symfony2,
instantiating the main ODM classes
happens in the DIC:</p>

<p>``` yml container.yml
services:
  orientdb.binding.parameters:</p>

<pre><code>class: Doctrine\OrientDB\Binding\BindingParameters
arguments:
  host:     127.0.0.1
  port:     2480
  username: admin
  password: admin
  database: DBNAME
</code></pre>

<p>  orientdb.binding:</p>

<pre><code>class: Doctrine\OrientDB\Binding\HttpBinding
arguments:
  parameters: @orientdb.binding.parameters
</code></pre>

<p>  odm:</p>

<pre><code>class: Doctrine\ODM\OrientDB\Manager
arguments:
  mapper: @odm.mapper
  binding: @orientdb.binding
</code></pre>

<p>  odm.mapper:</p>

<pre><code>class: Doctrine\ODM\OrientDB\Mapper
arguments:
  documentProxyDirectory: %base-dir%/tmp/
  annotationReader: @odm.annotation-reader
calls:
  - [setDocumentDirectories, [ %base-dir%/src/PROJECT/Entity/ : "PROJECT\Entity" ] ]
</code></pre>

<p>  odm.annotation-reader:</p>

<pre><code>class: Doctrine\ODM\OrientDB\Mapper\Annotations\Reader
arguments:
  cacheReader: @cache.array
</code></pre>

<p>  cache.array:</p>

<pre><code>class: Doctrine\Common\Cache\ArrayCache    
</code></pre>

<p>parameters:
  base-dir: /Users/odino/Sites/PROJECT
```</p>

<p>As you see, you need:</p>

<ul>
<li>the <code>Manager</code>, which requires a <code>Mapper</code> and a connection to
OrientDB through a binding class implementing the
<code>Doctrine\OrientDB\Binding\BindingInterface</code></li>
<li>the <code>Mapper</code>, which requires a directory where it can write
proxy classes (for lazy loading), and an annotation reader
(this is not required, I&rsquo;ll explain it later), plus a source
directory to locate entities</li>
<li>the <code>HttpBinding</code>, used by the <code>Manager</code>, that does raw
queries to the OrientDB server</li>
<li>the <code>Annotations\Reader</code></li>
<li>a cache implementing the interface <code>Doctrine\Common\Cache\Cache</code>:
in dev environments it is needed since <code>ApcCache</code> is the default
one, and you would need to flush APC every time you change an
annotation in your entities (we will probably change it and put
<code>ArrayCache</code> by default, so that you will need to tweak the live
environment, not the dev one)</li>
</ul>


<h2>Autoloading</h2>

<p>The autoloading is straightforward, thanks to the <code>PSR-0</code>; the
only thing that you should keep in mind is that you will need
to specify a separate autoloader for proxy classes, since they can
be generated wherever you want (ideally, in a temporary folder,
since they should be removed every time you deploy):</p>

<p>```php autoload.php
&lt;?php</p>

<p>require_once <strong>DIR</strong>.&lsquo;/../vendor/symfony/symfony/src/Symfony/Component/ClassLoader/UniversalClassLoader.php&rsquo;;</p>

<p>use Symfony\Component\ClassLoader\UniversalClassLoader;</p>

<p>$loader = new UniversalClassLoader();</p>

<p>$loader->registerNamespaces(array(</p>

<pre><code>'Symfony'                       =&gt; __DIR__.'/../vendor/symfony/symfony/src',
'Doctrine\Common'               =&gt; __DIR__.'/../vendor/doctrine/common/lib',
'Doctrine\OrientDB'             =&gt; __DIR__.'/../vendor/doctrine/orientdb-odm/src',
'Doctrine\ODM\OrientDB'         =&gt; __DIR__.'/../vendor/doctrine/orientdb-odm/src',
'Doctrine\OrientDB\Proxy'       =&gt; __DIR__.'/../tmp',
</code></pre>

<p>));</p>

<p>$loader->register();
```</p>

<p>You should set the autoloader for <code>Doctrine\OrientDB\Proxy</code>
accordingly to the argument <code>documentProxyDirectory</code> of the
<code>odm.mapper</code> service.</p>

<h2>Entities</h2>

<p>Following what we specified in the <code>container.yml</code>,
entities should be located in
<code>%base-dir%/src/PROJECT/Entity/</code> and follow the namespace
<code>PROJECT\Entity</code>:</p>

<p>```php
&lt;?php</p>

<p>namespace PROJECT\Entity;</p>

<p>use Doctrine\ODM\OrientDB\Mapper\Annotations as ODM;</p>

<p>/<em>*
* @ODM\Document(class=&ldquo;user&rdquo;)
</em>/
class User
{</p>

<pre><code>/**
 * @ODM\Property(name="@rid", type="string")
 */
protected $rid;

/**
 * @ODM\Property(type="string")
 */
protected $email;

/**
 * @ODM\Property(type="string", notnull="false")
 */
protected $nick;

/**
 * @ODM\Property(type="linklist")
 */
protected $addresses;

/**
 * Returns the nickname of the user, or his email if he has no nick set.
 * 
 * @return string
 */
public function getNick()
{
    return $this-&gt;nick ?: $this-&gt;getEmail();
}

public function setNick($nick)
{
    $this-&gt;nick = $nick;
}

public function getEmail()
{
    return $this-&gt;email;
}

public function setEmail($email)
{
    $this-&gt;email = $email;
}

public function getAddresses()
{
    return $this-&gt;addresses;
}

public function setAddresses($adresses)
{
    $this-&gt;addresses = $addresses;
}

public function getRid()
{
    return $this-&gt;rid;
}

public function setRid($rid)
{
    $this-&gt;rid = $rid;
}
</code></pre>

<p>}
```</p>

<p>As you see, mapping an entity is pretty easy:
the first annotation is at class level, to define
which OrientDB classes are mapped by the entity,
then for every property that you want to be
persisted / hydrated, you define another annotation and
public getters / setters; if you want the property to be
public, you dont need getters / setters.</p>

<p>The property-level annotation has 3 parameters:</p>

<ul>
<li><strong>type</strong>: defines the type of the property in OrientDB
( <code>boolean</code>, <code>link</code>, <code>linklist</code>, <code>string</code>, <code>integer</code>, etc )</li>
<li><strong>name</strong>: the name of the attribute in the OrientDB class
(you might have a PHP property called <code>$createdAt</code> and in OrientDB
you call it <code>created_at</code>)</li>
<li><strong>notnull</strong>: defines whether the property can be <code>null</code> or not<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup></li>
</ul>


<h2>What about controllers?</h2>

<p>You can access the ODM from within
controllers of your application by
just using the container:</p>

<p>``` php PROJECT/Controller/User.php
&lt;?php</p>

<p>namespace PROJECT\Controller;</p>

<p>use Project\Entity\User;</p>

<p>class UserController
{</p>

<pre><code>public function somethingAction()
{
    $user       = new User();
    $manager    = $this-&gt;getService('odm');

    $manager-&gt;...
}
</code></pre>

<p>}
```</p>

<h2>Repositories</h2>

<p>At this point, after boostrapping the environment and creating your first entity,
you might want to play with the repository in your controllers, to
manipulate and retrieve collections:</p>

<p>``` php PROJECT/Controller/User.php
&lt;?php</p>

<p>$manager        = $this->getService(&lsquo;odm&rsquo;);
$userRepository = $manager->getRepository(&lsquo;PROJECT\Entity\User&rsquo;)
```</p>

<p>then, with the repository, you can start retrieving objects:</p>

<p>``` php Using the repository
&lt;?php</p>

<p>// find all users
$userRepository->findAll();</p>

<p>// find one user given its RID
$userRepository->find($rid);</p>

<p>// find all users with the nick &ldquo;overlord&rdquo;
$userRepository->findByNick(&ldquo;overlord&rdquo;);</p>

<p>// find the user with the nick &ldquo;TheOnlyOverlord&rdquo;
$userRepository->findOneByNick(&ldquo;TheOnlyOverlord&rdquo;);</p>

<p>// find jack&rsquo;s wife
$jack  = $userRepository->findOneByName(&ldquo;Jack&rdquo;);
$wifey = $userRepository->findOneBySpouse($jack); // spouse is an attribute of type &ldquo;link&rdquo;
```</p>

<p>and it&rsquo;s not over, since you can, of course, add
<strong>custom repository classes</strong>.</p>

<p>Custom repositories must be located in the entity&rsquo;s folder
and follow the naming convention <code>EntitytheymapRepository</code>:
for our <code>User</code> entity, we would need to create a <code>UserRepository</code>
class in <code>%base-dir%/src/PROJECT/Entity/</code>:</p>

<p>``` php PROJECT\Entity\UserRepository
&lt;?php</p>

<p>namespace PROJECT\Entity;</p>

<p>use Doctrine\ODM\OrientDB\Repository;</p>

<p>class UserRepository extends Repository
{</p>

<pre><code>/**
 * Retrieves a random user.
 * 
 * @return \PROJECT\Entity\User
 */
public function findRandomUser()
{
    return array_rand($this-&gt;findAll());
}
</code></pre>

<p>}
```</p>

<p>so then you can call your new methods over repositories:</p>

<p>``` php Using custom repositories
&lt;?php</p>

<p>$manager->getRepository(&lsquo;PROJECT\Entity\User&rsquo;)&ndash;>findRandomUser();
```</p>

<h2>Can I haz raw queries?</h2>

<p>Entities and repositories are good, but what about
adding some <code>SQL+</code><sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup> to the mix?</p>

<p>That&rsquo;s very easy, thanks to the <strong>query builder</strong>
that&rsquo;s packed with the ODM:</p>

<p>``` php Example queries
&lt;?php</p>

<p>use Doctrine\OrientDB\Query\Query;</p>

<p>// instantiate a query object
$query = new Query();</p>

<p>// simple SELECT
$query->from(array(&lsquo;user&rsquo;))&ndash;>where(&lsquo;nick = ?&rsquo;, $nick);</p>

<p>// throwing some spice into the mix
$query->orWhere(&lsquo;attribute = ?&rsquo;, $attribute)</p>

<pre><code>  -&gt;orWhere('(this IS NULL OR that IS NOT NULL)')
  -&gt;limit(10)
  -&gt;orderBy(...);
</code></pre>

<p>// SELECTing a single record
$query->from(array($rid));</p>

<p>// SELECTing two records
$query->from(array($rid1, $rid2));
```</p>

<p>When you manipulate the <code>$query</code> object you are basically
creating an SQL query with an object-oriented fluent interface;
to eventually execute the query, just pass the object to
the <code>Manager</code>:</p>

<p>``` php Executing a query
&lt;?php</p>

<p>$query = new Query();
$query->from(array(&lsquo;user&rsquo;))&ndash;>where(&lsquo;gender = ?&rsquo;, &ldquo;male&rdquo;);</p>

<p>$males = $manager->execute($query);
```</p>

<h2>Point being, how do you save data?</h2>

<p>Since persistence is not already handled by the <code>Manager</code>,
you will need to use raw queries for now:</p>

<p>``` php Saving data
&lt;?php</p>

<p>$user = array(
  &lsquo;name&rsquo; => &lsquo;Jack&rsquo;
);</p>

<p>$query = new Query();
$query->insert()&ndash;>into(&lsquo;user&rsquo;)&ndash;>fields(array_keys($user))&ndash;>values($user);</p>

<p>$manager->execute($query);
```</p>

<h2>From the trenches</h2>

<p>We&rsquo;ve been very active since a couple months,
and we&rsquo;ve actually been able to roll out some major
bugfixes and improvements (more than 10 in the last
few weeks):</p>

<ul>
<li>repositories <a href="https://github.com/doctrine/orientdb-odm/issues/138">filtering by multiple criterias</a></li>
<li><a href="https://github.com/doctrine/orientdb-odm/issues/139">custom repository</a> classes</li>
<li>added ability to <a href="https://github.com/doctrine/orientdb-odm/issues/141">map timestamps</a> as DateTime objects</li>
<li>unable to <a href="https://github.com/doctrine/orientdb-odm/issues/144">update attributes if they are a collection</a></li>
<li>support for <a href="https://github.com/doctrine/orientdb-odm/commit/cbd9c3250d1fd6fc7ec1f39566b91d1f0e1531f2">INSERTing collections</a></li>
<li>proxy classes dont <a href="https://github.com/doctrine/orientdb-odm/issues/147">import signatures</a></li>
<li><code>findBy*</code> and <code>findOneBy*</code> <a href="https://github.com/doctrine/orientdb-odm/issues/149">&ldquo;magic&rdquo; methods</a></li>
<li><a href="https://github.com/doctrine/orientdb-odm/issues/150">fetchplans in <code>find*</code></a> methods of repositories</li>
<li>following <code>SQL+</code>, added <a href="https://github.com/doctrine/orientdb-odm/issues/99"><code>REBUILD INDEX</code> command</a></li>
</ul>


<p>I would not advise you to install one of the old tags,
or even the last one, which brings the namespace
changes for the incubation in the Doctrine
organization, but to install it directly from master
via composer:</p>

<p><code>json
"doctrine/orientdb-odm": "dev-master",
</code></p>

<p>as we are constantly doing bugfixes and so on
(I would day you would get an update &ndash; at least &ndash;
every week).</p>

<p>That is it, now <strong>start playing around!</strong></p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>Be aware that if you are retrieving a property which is NULL in the DB and you don't declare it as NULLable, an exception will be thrown (and there is an issue to improve the exception message https://github.com/doctrine/orientdb-odm/issues/152) <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>OrientDB's QL is called SQL+, as it looks like SQL but has some major improvements, as it's very developer-friendly <a href='#fnref:2' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Please Welcome the Doctrine2 OrientDB ODM]]></title>
    <link href="http://odino.org/please-welcome-the-doctrine-orientdb-odm/"/>
    <updated>2012-12-28T23:12:00-05:00</updated>
    <id>http://odino.org/please-welcome-the-doctrine-orientdb-odm</id>
    <content type="html"><![CDATA[<p>It took almost 2 years from the
<a href="https://github.com/doctrine/orientdb-odm/commit/65929ec57a2e2cb1f4af034d722e17b5339b9d48">first commit</a>,
but <a href="http://www.orientdb.org/">OrientDB</a>&rsquo;s <a href="https://github.com/doctrine/orientdb-odm">PHP ODM</a>
has been finally moved to the
<a href="https://github.com/doctrine/">Doctrine</a>
organization.</p>

<!-- more -->


<h2>New daddy</h2>

<p>I&rsquo;ve blogged <a href="/blog/categories/orientdb/">so many times</a>
about an imminent
integration into the Doctrine ecosystem, but
due to the workload of our contributors and
some major issues we wanted to solve before this,
we were only able to seriously approach the
Doctrine team today.</p>

<p>This is a very good news, as we will be able
to take advantage of the experience of all the
doctrine contributors as well as have a bigger stage
where we can show the ODM: the biggest part of the
ODM is still pending (persistence), but
HTTP binding, query builder and object
hydration are working like a charm, and the few
bugs that we face in <a href="https://github.com/odino/sharah">real-world scenarios</a>
are solved in a matter of minutes.</p>

<h2>And now?</h2>

<p>All the namespaces have been changed, so the old
<code>Congow\Orient</code> has been replaced by
<code>Doctrine\ODM\OrientDB</code> and <code>Doctrine\OrientDB</code>:
if you were already using the library, you will need
to work on the migration a bit.</p>

<p>You may also want to have a look at the new
<a href="https://packagist.org/packages/doctrine/orientdb-odm">Packagist page</a>,
as it contains the references to the new repository.</p>
]]></content>
  </entry>
  
</feed>