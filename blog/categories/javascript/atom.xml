<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Category: JavaScript | Alessandro Nadalin]]></title>
  <link href="http://odino.org/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://odino.org/"/>
  <updated>2014-07-08T22:06:26+04:00</updated>
  <id>http://odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Nikki 0.19.1: Awesomeness Won't Stop]]></title>
    <link href="http://odino.org/nikki-0-dot-19-dot-1-awesomeness-wont-stop/"/>
    <updated>2014-07-07T17:30:00+04:00</updated>
    <id>http://odino.org/nikki-0-dot-19-dot-1-awesomeness-wont-stop</id>
    <content type="html"><![CDATA[<p>Given it&rsquo;s Ramadan and we have some spare time at the
end of the day, I&rsquo;m getting the chance to be
<a href="https://github.com/odino/nikki/commits/master">quite active</a>
with the development of <a href="https://github.com/odino/nikki">Nikki</a>.</p>

<!-- more -->


<blockquote><p>If you are new to nikki, you might want to read
<a href="/last-weekend-i-wrote-an-ide-in-javascript/">this introductory post</a> I wrote a while ago.</p></blockquote>

<p>I figured out the best way to document these changes, besides
writing a blog post, would be to document them with
<a href="https://github.com/odino/nikki/issues?direction=desc&amp;page=1&amp;sort=updated&amp;state=closed">Github issues</a>
and by beefing up the <a href="https://github.com/odino/nikki/">README</a> &mdash; so
you should definitely have a look there.</p>

<h2>What&rsquo;s new?</h2>

<p><img class="center" src="/images/nikki-0.19.1.png"></p>

<p>The biggest change is that you are now gonna be running nikki
as a <a href="https://github.com/odino/nikki/commit/efecd05ab8a02406d63011e465850f2931ecef07">detached process</a>:
once you start nikki you will see it running on port <code>9123</code> (by default)
and you will be able to stop it with a simple <code>nikki --stop</code>; to
check whether nikki is running simply run a <code>nikki --status</code>.</p>

<p>This change was made possible using node&rsquo;s spawning capabilities
and <a href="https://github.com/substack/dnode">dnode</a>, which lets you
implement <a href="http://en.wikipedia.org/wiki/Remote_procedure_call">RPC</a>
in NodeJS: once you start nikki the main process spawns itself,
the spawned one listens on <code>9124</code> for signals and the main process
ends; when we issue <code>nikki --stop</code> we will just be sending a
<code>shutdown</code> signal to the spawned nikki
process through an RPC call.</p>

<p>Other changes?</p>

<ul>
<li>added the <code>ctrl + shift + l</code> shortcut to <a href="https://github.com/odino/nikki/commit/40899aaeecb70c02c1c1a00e566335d190508c2f">close editor tabs</a></li>
<li>once you re-open nikki, tabs that were open at the time you closed <a href="https://github.com/odino/nikki/commit/daa95c0efd3022b744016830e2f7995cea138a52">will be open again</a></li>
<li>using <a href="https://github.com/odino/nikki/commit/7e2f2baec4eb2aec7ba2980de2a82d8ab2b1bff5">jQuery 2.X</a></li>
<li>&ldquo;<a href="https://github.com/odino/nikki/commit/1a3fd2605ed6f325409fd8d489bd624a72d8a7af">open in github</a>&rdquo; you can now configure nikki so that
once you use the <code>ctrl + g</code> shortcut in a file it will open it, in github, in a new broser tab</li>
<li>added <a href="https://github.com/odino/nikki/commit/46e5c1881b6ca331b64cc470086f7af7936af69e">filesystem icons from fontawesome</a></li>
<li>when you search for files, now, the <a href="https://github.com/odino/nikki/commit/649106f5d491165b3e1c982cbb76e9967cb81c0d">file path will be shown next to the filename</a> (so if you have 3 <code>index.js</code> in your codebase&hellip;   &hellip;no worries anymore!)</li>
<li><a href="https://github.com/odino/nikki/commit/7db31f927b3027dfa1408e2af84b6806a6b91d12">debug mode</a>, so that you can troubleshoot problems in an easier way</li>
</ul>


<h2>What&rsquo;s fixed?</h2>

<ul>
<li>navigation used to show <a href="https://github.com/odino/nikki/commit/d829129992e5e42eed54f7f13492254f3b3df08d">incorrect</a> <a href="https://github.com/odino/nikki/commit/b463eab67816c8fa1c02d30af019e2a9628be458">paths</a></li>
<li>inconsistencies with the <a href="https://github.com/odino/nikki/commit/4450b27ea477f119b3d7a32a27a37606687ccae0">file search</a></li>
<li><a href="https://github.com/odino/nikki/commit/041397e71198599cc6c4a2ec06a706aff0c72623">shortcuts conflicts</a> with the ACE editor</li>
</ul>


<h2>How to get all these changes?</h2>

<p>As simple as running an <code>npm install -g nikki</code> if this is the first time
you hear about it: for the ones who already have it installed on their
systems simply run a <code>npm update -g nikki</code>.</p>

<p>Then open a terminal, type <code>nikki</code> and let the show begin!</p>

<h2>What&rsquo;s next?</h2>

<p>I will be implementing filesystem operations in these days (delete / create
files and folders) and probably refactor some of the key frontend components, like
the keyboard shortcuts.</p>

<p>Keep an eye on the <a href="https://github.com/odino/nikki">github project</a> and let me know your feedback!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nikki v0.16.5: First Issues Ahead]]></title>
    <link href="http://odino.org/nikki-v0-dot-16-dot-5-first-issues-ahead/"/>
    <updated>2014-07-02T22:47:00+04:00</updated>
    <id>http://odino.org/nikki-v0-dot-16-dot-5-first-issues-ahead</id>
    <content type="html"><![CDATA[<p>Today I migrated all the possible issues I knew
from <a href="https://github.com/odino/nikki">nikki</a>&rsquo;s
README to <a href="https://github.com/odino/nikki/issues">github&rsquo;s issues</a>, and started
addressing the first few of them.</p>

<!-- more -->


<blockquote><p>If you are new to nikki, you might want to read
<a href="/last-weekend-i-wrote-an-ide-in-javascript/">this introductory post</a> I wrote a while ago.</p></blockquote>

<p>Among the things I&rsquo;ve been hacking on today:</p>

<ul>
<li>if you tried to open a non-existing directory the server
would crash, now it&rsquo;s simply telling you you&rsquo;re trying to do
something nasty</li>
<li>I added <a href="https://github.com/odino/nikki/blob/master/client/images/favicon.png">this awesome favicon</a> :)</li>
<li>I ported the keyboard shortcuts to the Mac:
whatever you were able to do with <code>ctrl</code> now is also available
with <code>âŒ˜</code></li>
<li>when you boot nikki, now, you will be able to see it running
under the name <code>nikki</code> in the process' list (try a <code>ps -ef | grep nikki</code>)</li>
<li>you can customize the <a href="https://github.com/odino/nikki/blob/master/.nikki.yml#L9-L25">mappings for syntax highlighting</a> by adding
them in your <code>.nikki.yml</code></li>
</ul>


<p>Contextually, I released <code>v0.16.5</code>, so simply run an
<code>npm update -g nikki</code> and enjoy this bunch of new things!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Last Weekend I Wrote an IDE. In JavaScript.]]></title>
    <link href="http://odino.org/last-weekend-i-wrote-an-ide-in-javascript/"/>
    <updated>2014-06-29T23:32:00+04:00</updated>
    <id>http://odino.org/last-weekend-i-wrote-an-ide-in-javascript</id>
    <content type="html"><![CDATA[<p>In the past days I&rsquo;ve been spending some hours on a project
I had in mind since a while, and finally got to roll out
something I am already using on a daily basis: a fast IDE
that runs within a browser.</p>

<!-- more -->


<h2>Nikki</h2>

<p>The idea is very simple: why booting a Java monster like
WebStorm / Eclipse / Netbeans when you can satisfy all
of your basic needs with a simple <code>&lt;div contenteditable /&gt;</code>?</p>

<p>Well, because a browser editor would still need to be able
to talk with your filesystem, and that&rsquo;s something a completely
&ldquo;frontend&rdquo; JS app wouldn&rsquo;t be able to do
(<a href="https://hacks.mozilla.org/2014/06/webide-lands-in-nightly/">but might be able to do soon</a>).</p>

<p>So, take JavaScript, put it on the frontend (browser), put
it on the backend (NodeJS), get them to talk (socket.io) and
use a pretty good web editor (ACE), add <code>ctrl + f</code> and <code>ctrl + s</code>
and we&rsquo;re done:</p>

<p><img class="center <a" src="href="https://raw.githubusercontent.com/odino/nikki/master/bin/images/nikki-ss.png?token=328420__eyJzY29wZSI6IlJhd0Jsb2I6b2Rpbm8vbmlra2kvbWFzdGVyL2Jpbi9pbWFnZXMvbmlra2kuZ2lmIiwiZXhwaXJlcyI6MTQwMzk4MDA4N30%3D--df43445fcfba173ae878bc6447c1169b61bc59cf">https://raw.githubusercontent.com/odino/nikki/master/bin/images/nikki-ss.png?token=328420__eyJzY29wZSI6IlJhd0Jsb2I6b2Rpbm8vbmlra2kvbWFzdGVyL2Jpbi9pbWFnZXMvbmlra2kuZ2lmIiwiZXhwaXJlcyI6MTQwMzk4MDA4N30%3D--df43445fcfba173ae878bc6447c1169b61bc59cf</a>"></p>

<h2>How to get started</h2>

<p>Simply install nikki with an <code>npm install -g nikki</code>, <code>cd</code>
into a project&rsquo;s directory and launch the editor with the <code>nikki</code>
command: the editor will launch a new browser window to let
you have fun with your project.</p>

<p>A <code>nikki --help</code> might get the confusion away, but if you
really want to give the project a closer look simply check
the <a href="https://github.com/odino/nikki">README on github</a>.</p>

<p>Of course, of course, of course, I need to clarify a few points:
first of all, nikki is not a &ldquo;real&rdquo; IDE, it&rsquo;s  more a text editor
(the marketer in me!), and it didn&rsquo;t really come out in a single weekend
(even though  the basics were setup last WE); last but not least,
I&rsquo;m not a javascripter (<a href="http://osrc.dfm.io/odino/">I guess</a>), so most of the credit goes
to <a href="http://socket.io/">socket.io</a>, the <a href="http://ace.c9.io/#nav=about">ACE editor</a>
and <a href="https://it.linkedin.com/in/davidfunaro">David</a>, who made me write my
very first lines of JS back in 2011 (I know, so late!)</p>

<h2>Considerations</h2>

<p>I&rsquo;ve started writing this thing 2 weeks ago and I&rsquo;m very happy
with where I&rsquo;ve got so far; in fact, I am writing
this post from &ldquo;my&rdquo; nikki, here&rsquo;s the proof:</p>

<p><img class="center" src="/images/nikki-proof.png"></p>

<p>I plan on fixing a few more bugs I have in my todo list
(because they&rsquo;re &ldquo;bugging&rdquo; me) and would be extremely happy
to fix anything you find while playing with nikki: I must admit
that, by using the latest version of Chrome on Linux, I might
have broken a few things on other browsers, so I&rsquo;d be very
happy to fix anything that comes up (ofc don&rsquo;t mention IE).</p>

<h2>One more thing</h2>

<p>As per the README:</p>

<blockquote><p>Hey, couldn&rsquo;t you simply use TextMate or LightTable?</p>

<p>Yes, but then, where&rsquo;s the fun?</p></blockquote>

<p>Remember, this is a pet project and I firstly did it for
fun, learning and to practice a bit over my spare time:
it is nothing groundbreaking or rocket-science, and I
don&rsquo;t see this going anywhere but my laptop (in terms of
userbase). If you wish to use (or at least try) nikki
I would be very happy though :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS Is the Future. Maybe.]]></title>
    <link href="http://odino.org/angularjs-is-the-future-maybe/"/>
    <updated>2014-02-27T11:54:00+04:00</updated>
    <id>http://odino.org/angularjs-is-the-future-maybe</id>
    <content type="html"><![CDATA[<p>Today I gave my 2nd talk here at the ConFoo in Montreal,
an overview of why Angular could fit your <em>future</em> requirements
quite well.</p>

<!-- more -->


<p>Enjoy!</p>

<p><div class="slideshare" id="__ss_31723051"><iframe src="http://www.slideshare.net/slideshow/embed_code/31723051 " width="850" height="650" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Make Your JavaScript Apps SEO-friendly]]></title>
    <link href="http://odino.org/how-to-make-your-javascript-apps-seo-friendly/"/>
    <updated>2014-01-17T14:15:00+04:00</updated>
    <id>http://odino.org/how-to-make-your-javascript-apps-seo-friendly</id>
    <content type="html"><![CDATA[<p>One of the challenges in moving your application logic
from the backend (Rails, Django or whatsoever) to the
new frontier of JS web frameworks like AngularJS and
EmberJS is how you can make them SEO-friendly, as these
JavaScript applications get sent to the browser by your
webserver as a <code>200 OK</code>, no matter if, once the app boots,
the page that its being represented is not found, or has
some specific metatags, like title and description.</p>

<!-- more -->


<p>This is, for example, how a tipical angular app&rsquo;s <code>HEAD</code>
section of the HTML looks like:</p>

<p>
``` html
<head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;title&gt;
    {{ pageTitle }}
&lt;/title&gt;
&lt;meta name="keywords" content="{{ metaKeywords }}"&gt;
&lt;meta name="description" content="{{ metaDescription }}"&gt;
&lt;link type="image/x-icon" data-ng-href="https://example.org/favicon.ico" rel="shortcut icon"&gt;
&lt;link rel="stylesheet" href="https://example.org/screen.css"&gt;
</code></pre>

<p></head>
```
</p>

<p>As you see, the page title, which is what SE like Google use
as main text in your indexed pages, is a mere placeholder for
a variable that come after the JS framework has booted and
executed its own logic, eventually leading to SERP results
like this:</p>

<p><img class="center" src="/images/google-result-placeholders.png"></p>

<p>So, how will you make sure that search engines will actually
see the post-processed HTML and not the very first one that
gets sent from your server?</p>

<p>You have at least a couple different solutions that use the
same underlying tecnique.</p>

<h2>Once feared, Cloaking is your only way</h2>

<p>The practice of <a href="http://en.wikipedia.org/wiki/Cloaking">cloaking</a>
has been penalized by search engines for years but turned out to
be <a href="https://developers.google.com/webmasters/ajax-crawling/docs/html-snapshot">endorsed by Google</a>
when you have JS-based apps.</p>

<p>It basically consist in serving to the search engine a different
version of the webpage, already rendered, instead of the one
that you would serve to a normal visitor, which has to run
the JS framework on the browser.</p>

<p>The workflow is very simple: instead of serving, from the webserver,
your traditional app that you would serve to a normal user, in case
of a bot you simply <strong>forward the request to another application</strong>,
which will request the original page, wait for it to render through
an headless browser like <a href="http://phantomjs.org/">PhantomJS</a> and then
<strong>serve back the fully rendered content</strong> to the bot:</p>

<p><img class="center" src="/images/prerender-seo.svg"></p>

<p>This is a very straightforward way to effectively implement SEO in
JS apps, and it can be achieved with a couple tools instead of
having to write the whole thing on your own.</p>

<h2>BromBone</h2>

<p><a href="http://www.brombone.com/">BromBone</a> is a service that crawls your
sitemap, generates a snapshot of the rendered HTML, stores it on
Amazon (presumably <a href="http://aws.amazon.com/s3/">S3</a>) and relieves you
from the pain of setting up the middleware SEO app on your own.</p>

<p>It basically acts as the SEO app seen in the picture, but instead of
rendering pages on the fly it does it by looking at your sitemap: once
the bot hits the webserver, you can then proxy it to the BromBone page
so that it gets the actual response from the server.</p>

<p>Even though the service is <a href="http://www.brombone.com/#pricing">very affordable</a>
relying on the sitemap it&rsquo;s a bit tricky, because, well&hellip;what happens
if you have new pages that are not included in the sitemap?</p>

<p>After bumping into this requirement we, at Namshi, decided to opt for
something else.</p>

<h2>Prerender</h2>

<p><a href="https://prerender.io/">Prerender</a> is both a SaaS and an
<a href="https://github.com/collectiveip/prerender">open source library</a>
that prerendrs pages on the fly using PhantomJS and some other
nice tricks to <a href="https://prerender.io/server#http-headers">serve the correct status codes and HTTP headers</a>.</p>

<p>The only disadvantage with rendering on the fly is that the bot will
have to wait a bit longer in order to get the response, and this might
result in a penalization from search engines: the solution is very simple,
as you can simply warm up prerender&rsquo;s cache on your own by hitting the URLs
that you want to cache.
In order to refresh the cache, Prerender lets you do <code>POST</code> requests, so
that:</p>

<ul>
<li>a <code>GET</code> request to <code>http://prerender.example.org/http://example.org/foo.html</code>
will prerender the page on the fly, so that you can cache for future requests
by real bots</li>
<li>a <code>POST</code> request to <code>http://prerender.example.org/http://example.org/foo.html</code>
will refresh the prerendered content</li>
</ul>


<p>Prerender gives you a bit more freedom compared to Brombone but it requires you
to do some manual work, at least if you want to run it on your own servers
without using their solution as a SaaS; in any case, their pricing modes
is <a href="https://prerender.io/pricing">very affordable</a> as well.</p>

<h2>What shall I use?</h2>

<p>Surround your pullquote like this {" text to be quoted "}</p>
]]></content>
  </entry>
  
</feed>