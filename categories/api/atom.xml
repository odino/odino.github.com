<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Category: Api | Alessandro Nadalin]]></title>
  <link href="https://odino.org/categories/api/atom.xml" rel="self"/>
  <link href="https://odino.org/"/>
  <updated>2021-05-20T10:16:37+00:00</updated>
  <id>https://odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Web APIs of the Future]]></title>
    <link href="https://odino.org/web-apis-of-the-future/"/>
    <updated>2017-04-15T12:47:00+00:00</updated>
    <id>https://odino.org/web-apis-of-the-future</id>
    <content type="html"><![CDATA[<p>I generally like to think of myself as a server-side guy but, since a few
years, I&rsquo;ve been more and more involved with the frontend &mdash; especially
since logic, and not just UI, started to become a hot-topic for the client as
well (this is all thanks to Angular, y'all remember that thingy?).</p>

<p>So, more often than I admit, I keep an eye on the upcoming features of various
browsers through their <em>platform status</em> pages, and I&rsquo;ve decided to start sharing
a bunch of the stuff you should probably be excited as well. I plan of writing
a couple articles like this one on a yearly basis, as browsers evolve quickly and
there&rsquo;s always lots of stuff to be looking forward to.</p>

<!-- more -->


<h2>First things first: sources</h2>

<ul>
<li><a href="https://www.chromestatus.com/features">Chrome</a></li>
<li><a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/">Edge</a></li>
<li><a href="https://platform-status.mozilla.org/">Firefox</a></li>
<li><a href="https://webkit.org/status/">Webkit</a></li>
</ul>


<p>These browsers provide different functionalities on their status pages, so I
generally tend to spend more time on Chrome &amp; Edge&rsquo;s since they let me filter
stuff out with ease. Webkit allows the same but, hell let&rsquo;s be honest, I&rsquo;m not
very interested in their roadmap, as I think they&rsquo;re being
<a href="https://arstechnica.com/information-technology/2015/06/op-ed-safari-is-the-new-internet-explorer/">strangely slow to adopt</a>.</p>

<h2>Notable highlights</h2>

<p>The past few days were a boom for MS Edge, which rolled out some <a href="https://blogs.windows.com/msedgedev/2017/04/11/introducing-edgehtml-15/?utm_content=buffer9f1e8&amp;utm_medium=social&amp;utm_source=twitter.com&amp;utm_campaign=buffer#JYTlGJyKDuRVomoG.97">major updates</a>
including:</p>

<ul>
<li><a href="https://developers.google.com/web/fundamentals/discovery-and-monetization/payment-request/">PaymentRequest API</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async/await</a></li>
<li><a href="https://github.com/google/brotli">Brotli</a></li>
<li><a href="https://www.w3.org/TR/CSP2/">CSP level 2</a></li>
</ul>


<p>This was personally very surprising for me, as I always considered Edge an
afterthought &mdash; how naive of me. These guys are here to push forward, and
quickly buying into the PaymentRequest API is a huge sign for online payments. Love it!</p>

<h2>Upcoming stuff</h2>

<p><img class="right" src="/images/chrome.jpg"></p>

<p>In Chrome canary:</p>

<ul>
<li><a href="https://www.chromestatus.com/features/5694225681219584">Feature Policy</a>, a way to <a href="https://wicg.github.io/feature-policy/">selectively disable browser features</a></li>
<li><a href="https://www.chromestatus.com/features/5695378309513216">Get Installed Related Apps API</a>,
which will let website owners figure out <a href="https://github.com/WICG/get-installed-related-apps/blob/master/EXPLAINER.md">if the user has a (related) native app installed</a></li>
<li><a href="https://www.chromestatus.com/features/6443143280984064">Temporarily stop permission requests after 3 dismissals</a>,
so that annoying websites won&rsquo;t screw around as much</li>
</ul>


<p>Under development:</p>

<ul>
<li><a href="https://www.chromestatus.com/features/5861289330999296">Asynchronous Clipboard API</a>,
a modern clipboard API</li>
<li><a href="https://www.chromestatus.com/features/5684934484164608">Dynamc imports (from ESNext)</a>,
to dynamically load modules at runtime</li>
<li><a href="https://www.chromestatus.com/features/5365692190687232">ES6 modules</a></li>
<li><a href="https://www.chromestatus.com/features/5669923372138496">Web Authentication</a>,
to support serious <a href="https://w3c.github.io/webauthn/">authentication on the client</a></li>
<li><a href="https://www.chromestatus.com/features/5662315307335680">Web Share Target</a>, a consequence of the <a href="https://developers.google.com/web/updates/2016/10/navigator-share">Web Share API</a>,
so that websites can register themselves as &ldquo;targets&rdquo; of a share action (check this <a href="https://blog.hospodarets.com/demos/web-share-api/">demo of Web Share on Chrome for Android</a>)</li>
<li><a href="https://www.chromestatus.com/features/4532810371039232">WebVR</a>, which integrates
VR gears such as the Oculus with your browser (fun times ahead!)</li>
</ul>


<p><img class="right" src="/images/edge.png"></p>

<p>MS Edge has previews of <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/?q=edge%3A%27Preview%20Release%27">Web Assembly and ES6 modules</a>
as well, but what&rsquo;s under development is even more exciting:</p>

<ul>
<li><a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/backgroundsyncapi/?q=edge%3A%27In%20Development%27">Background Sync API</a>,
to let Service Workers know when the user&rsquo;s back online</li>
<li><a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/serviceworker/?q=edge%3A%27In%20Development%27">Service Workers</a> of course :)</li>
<li><a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/pushapi/?q=edge%3A%27In%20Development%27">Web Push notifications</a></li>
<li><a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/urlapi/?q=edge%3A%27In%20Development%27">URL API</a>, to manipulate URLs, a feature that&rsquo;s there in all of the other major browsers</li>
</ul>


<p>Looks like Edge is gaining momentum and closing the gap, which is definitely the
right direction for them. Of course, as you might notice, the road ahead is <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/consoletable/?q=edge%3A%27Under%20Consideration%27">still
long</a> ;&ndash;)</p>

<p><img class="right" src="/images/firefox.png"></p>

<p>Firefox&rsquo;s <a href="https://platform-status.mozilla.org/">focusing</a> on:</p>

<ul>
<li>Background Sync</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM">Shadow DOM</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Manifest">Web Manifest</a></li>
<li>PaymentRequest</li>
</ul>


<p><img class="right" src="/images/safari.gif"></p>

<p>whereas <a href="https://webkit.org/status/">Safari is probably at its lamest</a> with:</p>

<ul>
<li><a href="http://asmjs.org/">ASM.js</a></li>
<li><a href="https://www.w3.org/TR/WebCryptoAPI/">Web Cryptography API</a></li>
<li><a href="http://webassembly.org/">WebAssembly</a></li>
</ul>


<p>currently being developed &mdash; or, at least, those are the features that I think
are going to impact us, common mortals, the most.</p>

<p>Service Workers, Web Authentication, Web App Manifest and <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity">Subresource Integrity</a>
are all under consideration though.</p>

<h2>Conclusion</h2>

<p>As usual, I think Chrome is pushing ahead, even though sometimes their ideas are
quite weird &mdash; but that&rsquo;s part of trying to innovate. I&rsquo;m very happy to see
Firefox working on solid stuff and Edge catching up with the biggest themes of
2016 (<em>aka Service Workers</em>).</p>

<p>I see the <strong>PaymentRequest API as the clear winner of the past 6 months</strong>, and I&rsquo;m
really excited as this will mean a lot for online payments and e-commerce as well.
Browsers are becoming more of a platform rather than just a rendering engine, and
that makes it possible to create app-like experiences for your users<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>.</p>

<p>Last but not least, time has come to <strong>start shipping <a href="https://github.com/google/brotli">Brotli</a> to your users</strong>:
<a href="https://community.akamai.com/thread/2956#comment-15758">Akamai supports it since few weeks</a>
and <a href="https://caniuse.com/#search=brotli">browser support is kind of complete</a> (again, Safari&hellip;)
&mdash; time to knock on your CDN provider&rsquo;s door!</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>And that&rsquo;s why, in my opinion, Safari is pushing back big time <a href='#fnref:1' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2 Web APIs I'm Particularly Excited About]]></title>
    <link href="https://odino.org/2-web-apis-im-particularly-excited-about/"/>
    <updated>2016-10-25T01:02:00+00:00</updated>
    <id>https://odino.org/2-web-apis-im-particularly-excited-about</id>
    <content type="html"><![CDATA[<p>In the past few months we have seen Google and Apple push in 2
very different directions &mdash; as much as Apple has been steady
pushing publishers to embrace their app market, Google has been
working on a bunch of initiatives to improve the &ldquo;web platform&rdquo;,
rolling out projects like <a href="http://tech.namshi.com/blog/2016/09/20/embracing-amp-for-the-speed-and-profit/">AMP</a> and giving a lot of coverage to
technologies like <a href="https://developers.google.com/web/progressive-web-apps/">PWAs</a>.</p>

<p>I&rsquo;m particularly excited about the work that Google is putting
on the web as they&rsquo;re slowly bridging the gap with the native experience,
and there are 2 Web APIs I can&rsquo;t really wait to use in
production to give <a href="https://www.namshi.com/">our users</a> an enhanced
experience on the web.</p>

<!--  more -->


<p>As much as these aren&rsquo;t coming just from Google, I need to tribute them
to big G as they&rsquo;re the ones who are throwing them onto the mainstream:
I&rsquo;m talking about <a href="https://www.w3.org/TR/payment-request/">Web Payments</a> and
<a href="https://developers.google.com/web/fundamentals/engage-and-retain/push-notifications/">Web Push Notifications</a>.</p>

<h2>Web Push Notifications</h2>

<p>You can start adding push notifications to your web app today: they involve
installing a <a href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers">service worker</a>
which &ldquo;lives&rdquo; in background and is capable of listening for push events.</p>

<p><img class="center <a" src="href="https://blog.kissmetrics.com/wp-content/uploads/2015/11/push-notifications-desktop-mobile.png">https://blog.kissmetrics.com/wp-content/uploads/2015/11/push-notifications-desktop-mobile.png</a>"></p>

<p>Let&rsquo;s test it out real quick on Chrome:</p>

<ul>
<li>if you&rsquo;re reading this article from a <strong>desktop machine</strong>:

<ul>
<li>head <a href="https://gauntface.github.io/simple-push-demo/">here</a></li>
<li>accept permissions</li>
<li>copy the curl command</li>
<li>close that webpage</li>
<li>open a terminal and run that curl</li>
<li>be amazed</li>
</ul>
</li>
<li>if you&rsquo;re reading this article from a <strong>mobile device</strong>:

<ul>
<li>head <a href="https://gauntface.github.io/simple-push-demo/">here</a></li>
<li>accept permissions</li>
<li>copy that curl command and send it to a friend</li>
<li>close the browser</li>
<li>ask your friend to run it</li>
<li>be amazed</li>
</ul>
</li>
</ul>


<p>If you close your browser (at least on android) the service worker
keeps living, making it possible to reach your users until the SW dies,
which generally happens when the app (chrome) crashes or the phone
is rebooted, which are unlikely to happen on a frequent basis<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>.</p>

<p>You will need a good understanding of service workers but the code
to implement push notifications is <a href="https://github.com/GoogleChrome/samples/blob/gh-pages/push-messaging-and-notifications/service-worker.js">really trivial</a>
and the &ldquo;backend&rdquo; implementation is very well explained by &ndash; again &ndash; the <a href="https://developers.google.com/web/fundamentals/getting-started/codelabs/push-notifications/">Google guys</a>, which use
Firebase Cloud Messaging (formerly known as GCM) to deliver pushes
to the subscribed clients.</p>

<p>Web Push requires <a href="http://caniuse.com/#feat=serviceworkers">service workers</a>, and support
is currently limited to <a href="http://caniuse.com/#feat=push-api">Chrome / Firefox / Opera</a>.</p>

<h2>Payment Request API</h2>

<p>This one isn&rsquo;t as immediate as Web Pushes, especially since it <a href="https://9to5google.com/2016/08/08/chrome-53-beta-features/">landed in Chrome just a few weeks back</a>, so support is
pretty experimental &mdash; but have a look at the following video to get an idea
of how checkouts could be much simpler through a native way of collecting payment
details:</p>

<iframe width="760" height="415" src="https://www.youtube.com/embed/hmqZxP6iTpo" frameborder="0" allowfullscreen></iframe>


<p>This API isn&rsquo;t a payment solution but rather a sophisticated way to collect payment
data from your users, without needing to implement payment forms on your own &mdash; you
simply create a payment request and the browser does the rest:</p>

<p>``` js
// is this real?
if (window.PaymentRequest) {
  // what kind of payments are we accepting?
  let methodData = [</p>

<pre><code>{
  supportedMethods: ['visa', 'mastercard']
}
</code></pre>

<p>  ];</p>

<p>  // what is the user purchasing?
  let details = {</p>

<pre><code>displayItems: [
  {
    label: 'Argo, Blue-Ray movie',
    amount: { currency: 'USD', value : '15.00' }
  },
  {
    label: 'Power customer discount',
    amount: { currency: 'USD', value : '-10.00' }
  }
],
total:  {
  label: 'Total',
  amount: { currency: 'USD', value : '5.00' }
}
</code></pre>

<p>  };</p>

<p>  let request = new window.PaymentRequest(methodData, details, {});</p>

<p>  // start the fun!
  request.show().then(function(result) {</p>

<pre><code>result.complete('success');
// example of result.details:
//  - cardNumber
//  - cardSecurityCode
//  - expiryMonth
//  - expiryYear

return apiCallToThePaymentGateway(result.details).then(res =&gt; {
  return result.complete('success');
}).catch(result =&gt; {
  return result.complete('fail');
})
</code></pre>

<p>  });
}
```</p>

<p>You simply need to create a <code>PaymentRequest</code> and <code>.show()</code> it &mdash; the browser
will then show the native UI and you&rsquo;ll eventually receive the details once
the user is done entering his / her details: it&rsquo;s pretty neat since it&rsquo;s a very
simple yet powerful way of offloading this kind of annoying &ldquo;feature&rdquo; to the
browser (who&rsquo;s really happy to write a new credit card form in 2016? anyone who actually likes <a href="https://en.wikipedia.org/wiki/Luhn_algorithm">luhn</a>?).</p>

<p>As I said, this is pretty experimental, meaning that support is&hellip; &hellip;well,
you&rsquo;re <a href="http://caniuse.com/#feat=payment-request">on your own for now</a>, as
the <strong>only</strong> browser that supports it is chrome for mobile<sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup>.</p>

<h2>So?</h2>

<p>Who could have though things like these could actually happen in a browser
3 years ago?</p>

<p>I bet most of us didn&rsquo;t, which is why I&rsquo;m excited to see the
web growing and adding capabilities that make the browsing experience
better day after day.</p>

<p>And with things like <a href="https://www.chromestatus.com/feature/5298357018820608">Ambient Light Sensor API</a>,
<a href="https://www.chromestatus.com/feature/5762982487261184">CompositorWorkers</a> (worker threads that can respond to input and update visuals)
and <a href="https://www.chromestatus.com/feature/4532810371039232">WebVR</a> in the pipeline,
the future of browsers looks yummier than ever!</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>How many times do you reboot your phone daily? Sorry, what? You have a Samsung? Oh&hellip; <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>What&rsquo;s  scary, though, is that &ldquo;Apple provides an equivalent proprietary API called Apple Pay JS&rdquo; (<a href="http://caniuse.com/#feat=payment-request">http://caniuse.com/#feat=payment-request</a>) <a href='#fnref:2' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Planning to Write Long-term APIs? @cirpo and Me Shared Our Experience]]></title>
    <link href="https://odino.org/planning-to-write-long-term-apis-at-cirpo-and-me-shared-our-experience/"/>
    <updated>2014-07-05T23:34:00+00:00</updated>
    <id>https://odino.org/planning-to-write-long-term-apis-at-cirpo-and-me-shared-our-experience</id>
    <content type="html"><![CDATA[<p>A few weeks ago <a href="https://twitter.com/cirpo">@cirpo</a> and me
flew back to Italy to partecipate to the 2014 edition of the
<a href="http://2014.phpday.it/">PHPDay</a> in Verona, sharing our
experience building APIs.</p>

<!-- more -->


<p>It was really a great time, especially since I missed the
event in the past couple of years, so it was a blast to see
those good'old tech-friends again.</p>

<p>Our presentation, titled &ldquo;<a href="http://www.slideshare.net/odino/dont-screw-it-up-how-to-build-durable-web-apis-phpday-2014-in-verona-ita">Don&rsquo;t screw it up: how to build durable
web APIs</a>&rdquo;, went <a href="https://joind.in/talk/view/11310">pretty well</a>: have a look below and let me know
if you have any feedback!</p>

<p><div class="slideshare" id="__ss_34940481"><iframe src="https://www.slideshare.net/slideshow/embed_code/34940481 " width="100%" height="550" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Securing Your HTTP API With JavaScript Object Signing and Encryption]]></title>
    <link href="https://odino.org/securing-your-http-api-with-javascript-object-signing-and-encryption/"/>
    <updated>2013-06-04T00:31:00+00:00</updated>
    <id>https://odino.org/securing-your-http-api-with-javascript-object-signing-and-encryption</id>
    <content type="html"><![CDATA[<p>One thing that is always difficult, enough to
deserve <a href="http://www.amazon.com/Ajax-Security-Billy-Hoffman/dp/0321491939">its own book</a>,
is to <strong>secure HTTP API</strong> that interact with client-side
applications: today, after a discussion about how to face
the problem in our company, we bumped into the
<a href="http://datatracker.ietf.org/doc/draft-ietf-jose-json-web-signature/?include_text=1">JOSE</a>
&ndash; JavaScript Object Signing and Encryption &ndash;
specification.</p>

<!-- more -->


<p>Basically, the specification defines 4 entities:</p>

<ul>
<li>JWS, <a href="http://tools.ietf.org/html/draft-jones-json-web-signature-04">JSON Web Signature</a>,
a signed representation of data</li>
<li>JWT, <a href="http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html">JSON Web Token</a>,
a representation of data
(it differs from JWS as JWT is not signed)</li>
<li>JWE, <a href="http://self-issued.info/docs/draft-ietf-jose-json-web-encryption.html">JSON Web Encryption</a>,
an encrypted JSON representation of data</li>
<li>JWA, <a href="http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-00">JSON Web Algorithms</a>,
a list of safe algorithms to be used with JWS and JWE</li>
</ul>


<p>For the sake of basic knowledge, we will only have a look
at JWS and JWT / JWE now: the specifications about these
entities are quite extensive and not very straightforward,
so for further details you should <strong>really</strong> give them
a look.</p>

<p><img class="right" src="/images/jws.png"></p>

<h2>JWT</h2>

<p>Basically, the token (JWT) is the simplest structure
that you will deal with while implementing JOSE in our
architecture; it is a string representation of some data
base64 encoded (other types of encoding might be applied, but
this is not madatory): the JWT differs from raw base64-encoded
data since it also includes informations about the encoding
itself, in the token&rsquo;s header; by concatenating the base64-encoded
version of the token header and payload (the actual data) you
obtain what the specification calls <strong>signature input</strong>, which will
then be used to create the signature (JWS).</p>

<h2>JWS and JWE</h2>

<p>After the JWT comes the JWS, which is a signed representation
of the JWT; it differs from the token just because of the
signature; on an higher step of the ladder comes the JWE instead,
which lets you encrypt the data in order to achieve an higher security
level: the <a href="http://self-issued.info/docs/draft-ietf-jose-json-web-encryption.html#JWEExamples">examples in the ietf draft</a>
show you how to create JWEs with a pair of private /
public keys.</p>

<h2>Use case: how to authenticate stateless AJAX calls?</h2>

<p><img class="left" src="/images/jsw-auth.png"></p>

<p>One of the needs that you might have is to,
from JavaScript, make authenticated HTTP calls to
one of your webservices: since you don&rsquo;t want to
expose the WS credentials on the JS service (the
credentials would be readable by any client) a good
solution might be to generate a JWS with a private
OpenSSL key in your webservice, store it into a cookie
accessible to the JS service, which would execute
those calls including that cookie<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>, which you can then
verify while authenticating the call.</p>

<p>This workflow is pretty easy to understand, but the actual
implementation is more than tricky, since the
specification is quite abundant &ndash; especially about
encryption algorithms.</p>

<p>In PHP we can use at least 3 libraries: one of them,
<a href="https://github.com/ritou/php-Akita_JOSE">Akita_JOSE</a>,
is pretty old (since the last commit was more than
7 months ago) but is very understandable and quite
easy to use; another one, <a href="https://packagist.org/packages/gree/jose">gree/jose</a>,
has itw own package on packagist and can be easily
installed via composer: from a fast look at the
<a href="https://github.com/gree/jose">source code on GitHub</a> it looks good,
even though it needs the <a href="http://phpseclib.sourceforge.net/">phpsec</a>
library to be able to work<sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup>.</p>

<p>The third option, which is the one that <a href="https://github.com/namshi/jose">I built in the last couple of hours</a>,
is <a href="https://packagist.org/packages/namshi/jose">namshi/jose</a>,
which is very, very easy to use<sup id='fnref:3'><a href='#fn:3' rel='footnote'>3</a></sup>: it currently only
supports the <a href="https://github.com/namshi/jose/blob/master/src/Namshi/JOSE/Signer/RS256.php">RSA algorithm</a>
with <code>sha256</code> hashing, but I guess that implementing other
algorithms is less than trivial.</p>

<p>For example, let&rsquo;s see how you would generate the JWS
to be stored in a cookie:</p>

<p>``` php Generating a JWS after authentication and storing it into a cookie
&lt;?php</p>

<p>use Namshi\JOSE\JWS;</p>

<p>if ($username == &lsquo;correctUsername&rsquo; &amp;&amp; $pass = &lsquo;ok&rsquo;) {</p>

<pre><code>$user = Db::loadUserByUsername($username);

$jws  = new JWS('RS256');
$jws-&gt;setPayload(array(
    'uid' =&gt; $user-&gt;getid(),
));

$privateKey = openssl_pkey_get_private("file://path/to/private.key");
$jws-&gt;sign($privateKey);
setcookie('identity', $jws-&gt;getTokenString());
</code></pre>

<p>}
```</p>

<p>and then the apps that want to execute authenticated
calls on behalf of the user by using this cookie just need
to include it in these calls; the server will just need
to verify that the JWS in the cookie is valid:</p>

<p>``` php
&lt;?php</p>

<p>use Namshi\JOSE\JWS;</p>

<p>$jws        = JWS::load($_COOKIE[&lsquo;identity&rsquo;]);
$public_key = openssl_pkey_get_public(&ldquo;/path/to/public.key&rdquo;);</p>

<p>if ($jws->verify($public_key)) {</p>

<pre><code>$paylod = $jws-&gt;getPayload();

echo sprintf("Hey, my JS app just did an action authenticated as user #%s", $payload['id']);
</code></pre>

<p>}
```</p>

<p>That&rsquo;s it: far from being a stable library, this is more a
proof of concept that we, an Namshi, would like to see developing
in the next weeks / months.</p>

<p>As always, comments, rants or &ndash; even better &ndash; pull requests are
<strong>more than welcome</strong>!</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>One of the disadvantages of this approach is that it relies on cookies, only available in the HTTP protocol. If you want to use another protocol for you application - a very rare and extreme use case - this wouldn't work for you. <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>I honestly never heard of this library before, so I can't really say what it does and why it's needed <a href='#fnref:2' rev='footnote'>↩</a></li><li id='fn:3'>Since I'm not an expert in encryption and security, I would suggest to give it a look and come up with feedbacks <a href='#fnref:3' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
</feed>