<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Category: Browser | Alessandro Nadalin]]></title>
  <link href="https://odino.org/categories/browser/atom.xml" rel="self"/>
  <link href="https://odino.org/"/>
  <updated>2021-07-24T08:15:36+00:00</updated>
  <id>https://odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Web Application Security: What to Do When...]]></title>
    <link href="https://odino.org/wasec-web-application-security-what-to-do-when-dot-dot-dot/"/>
    <updated>2019-10-28T14:43:00+00:00</updated>
    <id>https://odino.org/wasec-web-application-security-what-to-do-when-dot-dot-dot</id>
    <content type="html"><![CDATA[<p><ol class="aseries">
	<p>This post is part of the "<strong><a href="/categories/wasec/">WASEC: Web Application SECurity</a></strong>" series, which is a portion of the content of <a href="https://leanpub.com/wasec">WASEC</a>, an e-book on web application security I've written.</p>
	<p>Here is a list of all the articles in this series:</p>
	<li>
		<a href="/web-security-demistified/">Web security demystified: WASEC</a>
	</li>
	<li>
		<a href="/introduction-to-web-application-security/">Introduction</a>
	</li>
	<li>
		<a href="/wasec-understanding-the-browser/">Understanding the browser</a>
	</li>
	<li>
		<a href="/security-https-perspective/">Security at the HTTP level</a>
	</li>
	<li>
		<a href="/secure-your-web-application-with-these-http-headers/">HTTP headers to secure your application</a>
	</li>
	<li>
		<a href="/security-hardening-http-cookies/">Hardening HTTP cookies</a>
	</li>
	<li>
		<a href="/wasec-web-application-security-what-to-do-when-dot-dot-dot/">Situationals</a>
	</li>
	</br>
	<p>
		If you've enjoyed the content of this article, consider buying the complete ebook on either the <a href="https://www.amazon.com/WASEC-Application-Everything-developer-application-ebook/dp/B081Z7SD48">Kindle store</a> or <a href="https://leanpub.com/wasec">Leanpub</a>.
	</p>
</ol>
</p>

<p>Often times, we&rsquo;re challenged with decisions that have a direct impact on the security of our applications, and the consequences of those decisions could potentially be disastrous. This article aims to present a few scenarios you might be faced with, and offer advice on how to handle each and every single of them.</p>

<p>This is by no means an exhaustive list of security considerations you will have to make in your day to day as a software engineer, but rather an inspiration to keep security at the centre of your attention by offering a few examples.</p>

<!-- more -->


<h2>Blacklisting versus whitelisting</h2>

<p>When implementing systems that require discarding elements based on an input (eg. rejecting requests based on an IP address or a comment based on certain words) you might be tempted to use a blacklist in order to filter elements out.</p>

<p>The inherent problem with blacklist is the approach we&rsquo;re taking: it allows us to specify which elements we think are unsafe, making the strong assumption of knowing everything that might hurt us. From a security perspective, that&rsquo;s the equivalent of us wearing summer clothes because we&rsquo;re well into June, without looking out the window in order to make sure today&rsquo;s actually sunny: we make assumptions without having the whole picture, and it could hurt us.</p>

<p>If you were, for example, thinking of filtering out comments based on a blacklist of words, you would probably start by describing a blacklist of 5 to 10 words: when coming up with the list you might be forgetting words such a <em>j3rk</em>, or reject genuine comments mentioning &ldquo;<a href="https://en.wikipedia.org/wiki/Dick_Bavetta">Dick Bavetta</a>&rdquo;, a retired NBA referee.</p>

<p>Now, comments aren&rsquo;t always the most appropriate example in terms of security, but you get the gist of what we&rsquo;re talking about: it&rsquo;s hard to know everything that&rsquo;s going to hurt us well in advance, so whitelisting is generally a more cautious approach, allowing us to specify what input we trust.</p>

<p>A more practical example would be logging: you will definitely want to whitelist what can be logged rather than the opposite. Take an example object such as:</p>

<p>```js
{</p>

<pre><code>email: "lebron@james.com",
password: "King_James",
credit_card: "1111 2222 3333 4444",
birthday: "1984-12-30",
</code></pre>

<p>}
```</p>

<p>You could possibly create a blacklist that includes <code>password</code> and <code>credit_card</code>, but what would happen when another engineer in the team changes fields from snake_case to camelCase?</p>

<p>Our object would become:</p>

<p>```js
{</p>

<pre><code>email: "lebron@james.com",
password: "King_James",
creditCard: "1111 2222 3333 4444",
birthday: "1984-12-30",
</code></pre>

<p>}
```</p>

<p>You might end up forgetting to update your blacklist, leading to the credit card number of your customers being leaked all over your logs.</p>

<p>As you&rsquo;ve probably realized, the choice of utilizing a blacklist or a whitelist highly depends on the context you&rsquo;re operating in: if you&rsquo;re exposing a service on the internet (such as facebook.com), then blacklisting is definitely not going to work, as that would mean knowing the IP address of every genuine visitor, which is practically impossible.</p>

<p>From a security perspective, whitelisting is definitely a better approach, but is often impactical. Choose your strategy carefully after reviewing both options: none of the above is suitable without prior knowledge of your system, constraints and requirements.</p>

<h2>Logging secrets</h2>

<p>If you develop systems that have to deal with secrets such as passwords, credit card numbers, security tokens or personally identifiable information (abbr. PII), you need to be very careful about how you deal with these data within your application, as a simple mistake can lead to data leaks in your infrastructure.</p>

<p>Take a look at this example, where our app fetches user details based on a header:</p>

<p>```js
app.get(&lsquo;/users/me&rsquo;, function(req, res){</p>

<pre><code>try {
    user = db.getUserByToken(req.headers.token)
    res.send(user)
} catch(err) {
    log("Error in request: ", req)
}
</code></pre>

<p>})
```</p>

<p>Now, this innocuous piece of code is actually dangerous: if an error occurs, the entire request gets logged.</p>

<p>Having the whole request logged is going to be extremely helpful when debugging, but will also lead to storing auth tokens (available in the request&rsquo;s headers) in our logs: anyone who has access to those logs will be able to steal the tokens and impersonate your users.</p>

<p>You might think that, since you have tight restrictions on who has access to your logs, you would still be &ldquo;safe&rdquo;: chances are that your logs are ingested into a cloud service such as <a href="https://cloud.google.com/stackdriver/">GCP&rsquo;s StackDriver</a> or <a href="https://aws.amazon.com/cloudwatch/features/">AWS' CloudWatch</a>, meaning that there are more attack vectors, such as the cloud provider&rsquo;s infrastructure itself, the communication between your systems and the provider to transmit logs and so on.</p>

<p>The solution is to simply avoid logging sensitive information: whitelist what you log (as we&rsquo;ve seen in the previous paragraph) and be wary of logging nested entities (such as objects), as there might be sensitive information hiding somewhere inside them, such as our <code>req.headers.token</code>.</p>

<p>Another solution would be to mask fields, for example turning a credit card number such as <code>1111 2222 3333 4444</code> into <code>**** **** **** 4444</code> before logging it.</p>

<p>That&rsquo;s sometimes a dangerous approach: an erroneous deployment or a bug in your software might prevent your code from masking the right fields, leading to leaking the sensitive information. As I like to say: <strong>use it with caution</strong>.</p>

<p>Last but not least, I want to mention one particular scenario in which any effort we make not to log sensitive information goes in vain: when users input sensitive information in the wrong place.</p>

<p>You might have a login form with username and password, and users might actually input their password in the username field (this can generally happen when you &ldquo;autoremember&rdquo; their username, so that the input field is not available the next time they log in). Your logs would then look like this:</p>

<p><code>text
user e0u9f8f484hf94 attempted to login: failure
user lebron@james.com attempted to login: success
...
</code></p>

<p>Anyone with access to those logs can figure an interesting pattern out: if a username doesn&rsquo;t follow an email pattern (<em>email@domain.tld</em>), chances are the string is actually a password the user had wrongly typed in the username field. Then you would need to look at the successful login attempts been made shortly after, and try to login with the submitted password against a short list of usernames.</p>

<p>What is the point here? Security is hard and, most often, things will work against you: in this context, being paranoid is a virtue.</p>

<p><blockquote><p></p></p><p><h3>Who is silly enough to log a password?</h3></p><p><br/><p>You might think logging sensitive information is an amateur&rsquo;s mistake, but I argue that even experienced programmers and organizations fall fall under this trap. Facebook, in early 2019, suffered a <a href="https://newsroom.fb.com/news/2019/03/keeping-passwords-secure/">security incident</a> directly related to this problem. As <a href="https://krebsonsecurity.com/2019/03/facebook-stored-hundreds-of-millions-of-user-passwords-in-plain-text-for-years/">Brian Krebs</a> put it:</p></p><p><p>&ldquo;Facebook is probing a series of security failures in which employees built applications that logged unencrypted password data for Facebook users and stored it in plain text on internal company servers.&rdquo;</p></p><p><p>This is not to say that Facebook should not be held accountable for the incident, but rather that we can probably sympathize with the engineers who forgot the console.log somewhere in the code. Security is hard, and so making sure we pay extra-attention to what we log is an extremely important matter.</p></blockquote></p>

<h2>Never trust the client</h2>

<p>As we&rsquo;ve seen before, cookies that are issued by our servers can be tampered with, especially if they&rsquo;re not <code>HttpOnly</code> and are accesible by JS code on your page.</p>

<p>At the same time, even if your cookies are <code>HttpOnly</code>, storing plaintext data in them is not secure, as any client (even <code>curl</code>), could get a hold of those cookie, modify them and re-issue a request with a modified version of the original cookie.</p>

<p>Suppose your session cookie contains this information:</p>

<p><code>text
profile=dXNlcm5hbWU9TGVCcm9uLHJvbGU9dXNlcg==;
</code></p>

<p>The string is base64-encoded, and anyone could reverse it to get to its actual value, <code>username=LeBron,role=user</code>. Anyone could, at that point, replace <code>user</code> with <code>admin</code> and re-encode the string, altering the value of the cookie.</p>

<p>If your system trusts this cookie without any additional check, you&rsquo;re in for trouble. You should instead <strong>never trust the client</strong>, and prevent it from being able to easily tamper with the data you&rsquo;ve handed off. A popular workaround to this issue is to encrypt or sign this data, like <a href="https://tools.ietf.org/html/rfc7519">JSON Web Tokens</a> do.</p>

<p>Let&rsquo;s drift for a second and dive into JWT, as their simplicity lets us understand the security mechanism behind them extremely well. A JWT is made of 3 parts: headers, claims and signature, separated by a dot:</p>

<p><code>text
JWT = "$HEADER.$CLAIMS.$SIGNATURE"
</code></p>

<p>Each value is base64-encoded, with header and claims being nothing but an encoded JSON object:</p>

<p>```text
$HEADER = BASE64({
  &ldquo;alg&rdquo;: &ldquo;HS256&rdquo;,  # HMAC SHA 256
  &ldquo;typ&rdquo;: &ldquo;JWT&rdquo;     # type of the token
})</p>

<p>$CLAIMS = BASE64({
  &ldquo;sub&rdquo;: &ldquo;1234567890&rdquo;, # ID of the user
  &ldquo;name&rdquo;: &ldquo;John Doe&rdquo;,  # Other attributes&hellip;
  &ldquo;iat&rdquo;: 1516239022    # issued at
})</p>

<p>JWT = &ldquo;$HEADER.$CLAIMS.$SIGNATURE&rdquo;
```</p>

<p>The last part, the signature, is the Message Authentication Code (abbr. MAC) of the combined <code>$HEADER.$CLAIM</code>, calculated through the algorithm specified in the header itself (<code>HMAC SHA-256</code> in our case). Once the MAC is calculated, it is base64-encoded as well:</p>

<p>```text
$HEADER = BASE64({
  &ldquo;alg&rdquo;: &ldquo;HS256&rdquo;,
  &ldquo;typ&rdquo;: &ldquo;JWT&rdquo;
})</p>

<p>$CLAIMS = BASE64({
  &ldquo;sub&rdquo;: &ldquo;1234567890&rdquo;,
  &ldquo;name&rdquo;: &ldquo;John Doe&rdquo;,
  &ldquo;iat&rdquo;: 1516239022
})</p>

<p>$SIGNATURE = BASE64(HS256(&ldquo;$HEADER.$CLAIMS&rdquo;, $PRIVATE_KEY))</p>

<p>JWT = &ldquo;$HEADER.$CLAIMS.$SIGNATURE&rdquo;
```</p>

<p>E-voila, our JWT is here!</p>

<p>If you followed this far, you might have understood that JWT is simply composed of 3 parts: 2 insecure set of strings and a signed one, which is what is used to  verify the authenticy of the token. Without the signature, JWTs would be insecure and (arguably) useless, as the information they contain is simply base64-encoded.</p>

<p>As a practical example, let&rsquo;s have a look at this token:</p>

<p><code>text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
</code></p>

<p>As you can see, we have 3 base64-encoded strings, separated by dots. Reversing them in bash is straightforward:</p>

<p><code>console
$ cut -d'.' -f1 &lt;&lt;&lt; $TOKEN | base64 -d
{"alg":"HS256","typ":"JWT"}
$ cut -d'.' -f2 &lt;&lt;&lt; $TOKEN | base64 -d
{"sub":"1234567890","name":"John Doe","iat":1516239022}
</code></p>

<p>As you would expect, the signature produces garbage instead:</p>

<p><code>console
$ cut -d'.' -f3 &lt;&lt;&lt; $TOKEN | base64 -d
I�J�IHǊ(]�O���ǉ~N�%base64: invalid input
</code></p>

<p>That&rsquo;s the mechanism JWTs use to prevent clients from tampering with the tokens themselves: when a server validates a token, it will first verify its signature (through the public key associated by the private one used to generate the signature), then access the token&rsquo;s data. If you&rsquo;re planning to hand over critical information to the client, signing or encrypting it is the only way forward.</p>

<p><blockquote><p></p></p><p><h3>Are JWTs safe?</h3></p><p><br/><p>JWTs have been under a lot of scrutiny in recent years, partly because of some design flaws that had to be course-corrected, such as the <a href="https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/">support of a &lsquo;None&rsquo; algorithm</a> which would effectively allow forging tokens without any prior knowledge of secrets and keys used to sign them. Luciano Mammino, a researcher from Italy, even managed to publish a <a href="https://github.com/lmammino/jwt-cracker">JWT cracker</a> to illustrate how easy it could be to crack JWTs through brute-forcing, granted the algorithm and secrets used are weak.</p></p><p><p>In all honesty, JWTs are very useful when you want to exchange data between two parties. For example, you could send a client the URL <a href="https://example.com/check-this-message?token=$JWT">https://example.com/check-this-message?token=$JWT</a> so that they could access the data within the token and know it comes from a trusted source. As session IDs, often times there are simpler mechanism you should rely on, as you only really need to issue a cryptographically random ID that identifies a client.</p></p><p><p>Does this mean JWTs are not safe? Not really, as it depends on how you use them: Google, for example, allows <a href="https://developers.google.com/identity/protocols/OAuth2ServiceAccount#jwt-auth">authentication to their APIs through JWTs</a>, like many others; the trick is to use safe, long secrets or a cryptographically secure signing algorithm, and understand the use-case you&rsquo;re presented with. JWTs also don&rsquo;t make any effort to encrypt the data they hold, and they&rsquo;re only concerned with validating its authenticity: understand these trade-offs and make your own educated choice.</p></p><p><p>In addition, you might want to consider <a href="https://github.com/paragonie/paseto">PASETO</a>, &ldquo;Platform Agnostic SEcurity TOkens&rdquo;: they were designed with the explicit goal to provide the flexibility and feature-set of JWTs without some of the design flaws that have been highlighted earlier on.</p></p><p><p>Further readings:</p></p><p><ul><br/>    <li><a href="https://paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid">paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid</a></li><br/>    <li><a href="https://kevin.burke.dev/kevin/things-to-use-instead-of-jwt/">kevin.burke.dev/kevin/things-to-use-instead-of-jwt</a></li><br/>    <li><a href="https://www.pingidentity.com/en/company/blog/posts/2019/jwt-security-nobody-talks-about.html">www.pingidentity.com/en/company/blog/posts/2019/jwt-security-nobody-talks-about.html</a></li><br/></ul></p><p><br/><p></p></blockquote></p>

<h2>Generating session IDs</h2>

<p>It should go without saying, but your session IDs (often stored in cookies) should not resemble a know pattern, or be generally guessable. Using an auto-icrementing sequence of integers as IDs would be a terrible choice, as any attacker could just log in, receive session id <code>X</code> and then replace it with <code>X ± N</code>, where <code>N</code> is a small number to increase chances of that being an identifier of a recent, thus valid, session.</p>

<p>The simplest choice would be to use a cryptographically secure function that generates a random string, and usually that&rsquo;s not a hard task to accomplish. Let&rsquo;s, for example, take the <a href="https://github.com/astaxie/beego">Beego</a> framework, very popular among Golang developers, as an example: the function that generates session IDs is</p>

<p>```go
package session</p>

<p>import (</p>

<pre><code>"crypto/rand"
</code></pre>

<p>)</p>

<p>// &hellip;
// &hellip;
// &hellip;</p>

<p>func (manager *Manager) sessionID() (string, error) {</p>

<pre><code>b := make([]byte, manager.config.SessionIDLength)
n, err := rand.Read(b)
if n != len(b) || err != nil {
    return "", fmt.Errorf("Could not successfully read from the system CSPRNG")
}
return manager.config.SessionIDPrefix + hex.EncodeToString(b), nil
</code></pre>

<p>}
```</p>

<p>6 lines of code, secure session IDs. As we mentioned earlier, no magic needs to be involved. In general, in most cases you won&rsquo;t need to write this code yourself, as frameworks would provide the basic building blocks to secure your application out of the box: if you&rsquo;re in doubt, though, you can review the framework&rsquo;s code, or open an issue on GitHub to clarify your security concern.</p>

<h2>Querying your database while avoiding SQL injections</h2>

<p>Right off the bat, you&rsquo;re probably thinking: &ldquo;<em>I&rsquo;ve heard about injections!</em>&rdquo;, and that&rsquo;s probably because was the #1 vulnerability in the &ldquo;<a href="https://www.owasp.org/images/7/72/OWASP_Top_10-2017_%28en%29.pdf.pdf">2017 OWASP Top 10: The Ten Most Critical Web Application Security Risks</a>&rdquo;.</p>

<p><img class="center" src="/images/wasec/owasp_2017_injection.png"></p>

<p>But guess what, injections made the #1 spot in the 2010 and 2013 version of the same list as well, and so there&rsquo;s a strong chance you might be familiar with any type of injection risk. To quote what we discussed earlier in this chapter, the only thing you need to remember to fight injection is to <strong>never trust the client</strong>: if you receive data from a client, make sure it&rsquo;s validated, filtered and innocuous, then pass it to your database.</p>

<p>A typical example of an injection vulnerability is the following SQL query:</p>

<p><code>sql
SELECT * FROM db.users WHERE name = "$name"
</code></p>

<p>Suppose <code>$name</code> comes from an external input, like the URL
<code>https://example.com/users/search?name=LeBron</code>: an attacker can then craft a specific value for the variable that will significantly alter the SQL query being executed. For example, the URL <code>https://example.com/users/search?name=anyone%22%3B%20TRUNCATE%20TABLE%20users%3B%20--</code> would result in this query being executed:</p>

<p><code>sql
SELECT * FROM db.users WHERE name = "anyone"; TRUNCATE TABLE users; --"
</code></p>

<p>This query would return the right search result, but also destroy the users' table, with catastrophic consequences.</p>

<p>Most frameworks and libraries provide you with the tools needed to sanitize data before feeding it to, for example, a database. The simplest solution, though, is to use prepared statements, a mechanism offered by most databases that prevents SQL injections altogether.</p>

<p><blockquote><p></p></p><p><h3>Prepared statements: behind the scenes</h3></p><p><br/><p>Wondering how prepared statements work? They&rsquo;re very straightforward, but often misunderstood. The typical API of a prepared statement looks like:</p></p><p><p>query = <code>SELECT * FROM users WHERE id = ?</code><br/>db.execute(query, id)</p></p><p><p>As you can see, the &ldquo;base&rdquo; query itself is separated from the external variables that need to be embedded in the query: what most database drivers will eventually do is to first send the query to the database, so that it can prepare an execution plan for the query itself (that execution plan can also be reused for the same query using different parameters, so prepared statements have performance benefits as well). Separately, the driver will also send the parameters to be used in the query.</p></p><p><p>At that point the database will sanitize them, and execute the query together with the sanitized parameters.</p></p><p><p>There are 2 key takeaways in this process:</p></p><p><ul><br/>    <li>the query and parameters are never joined before being sent to the database, as it's the database itself that performs this operation</li><br/>    <li>you delegate sanitization to a built-in database mechanism, and that is likely to be more effective than any sanitization mechanism we could have come up by ourselves</li><br/></ul></p><p><br/><p></p></blockquote></p>

<h2>Dependencies with known vulnerabilities</h2>

<p>Chances are that the application you&rsquo;re working on <em>right now</em> depends on a plethora of open-source libraries: ExpressJS, a popular web framework for NodeJS, depends on 30 external libraries, and those libraries depend on&hellip;we could go on forever. As a simple exercise, I tried to install a brand new version of ExpressJS in my system, with interesting results:</p>

<p><code>console
$ npm install express
+ express@4.17.1
added 50 packages from 37 contributors and audited 127 packages in 9.072s
found 0 vulnerabilities
</code></p>

<p>Just by installing the latest version of ExpressJS, I&rsquo;ve included 50 libraries in my codebase. Is that inherently bad? Not at all, but it presents a security risk: the more code we write (or use), the larger the attack surface for malicious users.</p>

<p>One of the biggest risks when using a plethora of external libraries is not following up on updates when they are released: it isn&rsquo;t so bad to use open-source libraries (after all, they probably are safer than most of the code we write ourselves), but forgetting to update them, especially when a security fix gets released, is a genuine problem we face every day.</p>

<p>Luckily, programs such as npm provide tools to identify outdated packages with known vulnerabilities: we can simply try to install a dependency with a known vulnerability and run <code>npm audit fix</code>, and npm will do th job for us.</p>

<p><code>``console
$ npm install lodash@4.17.11
+ lodash@4.17.11
added 1 package from 2 contributors and audited 288 packages in 1.793s
found 1 high severity vulnerability
  run</code>npm audit fix<code>to fix them, or</code>npm audit` for details
$ npm audit</p>

<pre><code>                   === npm audit security report ===                        
</code></pre>

<h1>Run  npm update lodash &mdash;depth 1  to resolve 1 vulnerability</h1>

<p>┌───────────────┬──────────────────────────────────────────────────────────────┐
│ High          │ Prototype Pollution                                          │
├───────────────┼──────────────────────────────────────────────────────────────┤
│ Package       │ lodash                                                       │
├───────────────┼──────────────────────────────────────────────────────────────┤
│ Dependency of │ lodash                                                       │
├───────────────┼──────────────────────────────────────────────────────────────┤
│ Path          │ lodash                                                       │
├───────────────┼──────────────────────────────────────────────────────────────┤
│ More info     │ <a href="https://npmjs.com/advisories/1065">https://npmjs.com/advisories/1065</a>                            │
└───────────────┴──────────────────────────────────────────────────────────────┘</p>

<p>found 1 high severity vulnerability in 1 scanned package
  run <code>npm audit fix</code> to fix 1 of them.
$ npm audit fix
+ <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#x6c;&#111;&#x64;&#97;&#115;&#104;&#64;&#52;&#46;&#x31;&#x37;&#46;&#49;&#53;">&#108;&#111;&#x64;&#97;&#x73;&#x68;&#x40;&#52;&#x2e;&#x31;&#55;&#x2e;&#x31;&#x35;</a>
updated 1 package in 0.421s
fixed 1 of 1 vulnerability in 1 scanned package
```</p>

<p>If you&rsquo;re not using JavaScript and npm, you can always rely on external services to scan your software and let you know if any library with known vulnerabilities is found: GitHub offers this service for all their repositories, and you might find it convenient when your codebase is already hosted there.</p>

<p><img class="center" src="/images/wasec/github_alerts.png"></p>

<p>GitHub will also send you an email every time a dependency with a known vulnerability is detected, so you can head over to the repository and have a look at the problem in detail.</p>

<p><img class="center" src="/images/wasec/github_alerts_detail.png"></p>

<p>If you prefer using a different platform, you could try <a href="https://gitlab.com">gitlab.com</a>: it acquired Gemnasium, a product that offered vulnerability scanning, in early 2018 in order to compete with GitHub&rsquo;s offering. If you prefer to use a tool that does not require code hosting instead, <a href="https://snyk.io">snyk.io</a> would probably be your best bet: it&rsquo;s trusted by massive companies such as Google, Microsoft and SalesForce, and offers different tools for your applications, not just dependency scanning.</p>

<h2>Have I been pwned?</h2>

<p>Remember when you were a teenager, and signed up for your first online service ever? Do you remember the password you used? You probably don&rsquo;t, but the internet might.</p>

<p>Chances are that, throughout your life, you&rsquo;ve used an online service that has been subject to attacks, with malicious users being able to obtain confidential information, such as your your password. I&rsquo;m going to make it personal here: my email address has been seen in at least 10 public security breaches, including incidents involving trustworthy companies such as LinkedIn and Dropbox.</p>

<p>How do I know?</p>

<p>I use a very interesting service called <a href="https://haveibeenpwned.com">haveibeenpwned.com</a> (abbr. HIBP), created by Troy Hunt, an Australian web security expert. The site collects information about public data breaches and allows you to understand whether your personal information was seen in any of these breaches. There&rsquo;s no shame in being involved in one of these data breaches, as it&rsquo;s not really your fault. This is, for example, the result of looking up the email address of Larry Page, one of Google&rsquo;s co-founders:</p>

<p><img class="center" src="/images/wasec/larry_page.png"></p>

<p><em>Larry&rsquo;s email address has been masked, but it&rsquo;s pretty public information</em></p>

<p>By knowing when and where an incident happened, you can take a few actions to improve your personal security posture, such as activating two-factor authentication (abbr. 2FA) and being notified of a breach as soon as HIBP is.</p>

<p>One of the interesting side-effects of HIBP is, though, the ability to use it to improve your business' security, as the site offers an API that you can use to verify whether users within your organization were involved in a data breach. This is extremely important as, too often, users consider security an afterthought, and opt out of mechanisms such as 2-factor authentication. This quickly becomes disastrous when you put in context of password re-use, a practice that is still way too common: a user signing up to multiple services using the same exact password. When one of those services is breached, the accounts on all the other ones might be breached as well.</p>

<p><blockquote><p></p></p><p><h3>Re-using credentials: a real-world story</h3></p><p><br/><p>I&rsquo;ve been directly hit by a password re-use attack during my career, and it wasn&rsquo;t a fun experience.</p></p><p><p>While I was heading technology at an online company, our security team received a message from a (questionable) researcher claiming he could login into many of our user accounts, sending across plaintext passwords to prove the fact. Baffled, we quickly realized we either got compromised, or someone else had been: when the attacker revealed <em>how</em> he got those credentials, we quickly realized they were available to the public through some hardcore googling.</p></p><p><p>After obtaining a full list of emails included in the breach, we then had to join it with the list of our customers, ending with forcefully resetting the password of the ones found both in the breach and our own database.</p></blockquote></p>

<h2>Session invalidation in a stateless architecture</h2>

<p>If you&rsquo;ve ever built a web architecture, chances are that you&rsquo;ve heard how stateless ones scale better due to the fact that they do not have to keep track of state. That is true, and it represents a security risk, especially in the context of authentication state.</p>

<p>In a typical stateful architecture, a client gets issued a session ID, which is stored on the server as well, usually linked to the user ID. When the client requests information from the server, it includes its session ID, so that the server knows that a particular request is made on behalf of a user with a particular ID, thanks to the mapping between session and user IDs. This requires the server store a list of all the session IDs it generated with a link to the user ID, and it can be a costly operation.</p>

<p>JWTs, which we spoke about earlier on in this chapter, rose to prominence due to the fact that they easily allow stateless authentication between the client and the server, so that the server would not have to store additional information about the session. A JWT can include a user id, and the server can simply verify its signature on-the-fly, without having to store a mapping between a session ID and a user ID.</p>

<p>The issue with stateless authentication tokens (and not just JWTs) lies in a simple security aspect: it is supposedly hard to invalidate tokens, as the server has no knowledge of each one it generated since they&rsquo;re not stored anywhere. If I logged in on a service yesterday, and my laptop gets stolen, an attacker could simply use my browser and would still be logged in on the stateless service, as there is no way for me to invalidate the previously-issued token.</p>

<p>This can be easily circumvented, but it requires us to drop the notion of running a completely stateless architecture, as there will be some state-tracking required if we want to be able to invalidate JWTs. The key here is to find a sweet spot between stateful and stateless, taking advantage of both the pros of statelessness (performance) and statefulness (security).</p>

<p>Let&rsquo;s suppose we want to use JWTs for authentication: we could issue a token containing a few information fo the user:</p>

<p><code>text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkxlYnJvbiBKYW1lcyIsImlhdCI6MTUxNjIzOTAyMn0.UJNHBHIBipS_agfTfTpqBmyOFaAR4mNz7eOwLOKUdLk
</code></p>

<p>```console
$ cut -d'.&lsquo; -f1 &lt;&lt;&lt; $TOKEN | base64 -d
{&ldquo;alg&rdquo;:&ldquo;HS256&rdquo;,&ldquo;typ&rdquo;:&ldquo;JWT&rdquo;}%</p>

<p>$ cut -d'.&lsquo; -f2 &lt;&lt;&lt; $TOKEN | base64 -d
{&ldquo;sub&rdquo;:&ldquo;1234567890&rdquo;,&ldquo;name&rdquo;:&ldquo;Lebron James&rdquo;,&ldquo;iat&rdquo;:1516239022}
```</p>

<p>As you can see, we included a the <em>issued at</em> (<code>iat</code>) field in the token, which can help us invalidating &ldquo;expired&rdquo; tokens. You could then implement a mechanism whereby the user can revoke all previously issued tokens by simply by clicking a button that saves a timestamp in a, for example, <code>last_valid_token_date</code> field in the database.</p>

<p>The authentication logic you would then need to implement for verifying the validity of the token would look like this:</p>

<p>```go
function authenticate(token):
  if !validate(token):</p>

<pre><code>return false
</code></pre>

<p>  payload = get_payload(token)
  user_data = get_user_from_db(payload.name)</p>

<p>  if payload.iat &lt; user_data.last_valid_token_date:</p>

<pre><code>return false
</code></pre>

<p>  return true
```</p>

<p>Easy-peasy! Unfortunately, this requires you to hit the database everytime the user logs in, which might go against your goal of scaling more easily through being state-less. An ideal solution to this problem would be to use 2 tokens: a long-lived one and a short-lived one (eg. 1 to 5 minutes).</p>

<p>When your servers receive a request:</p>

<ul>
<li>if it only has the long-lived one only, validate it and do a database check as well. If the process is successful, issue a new short-lived one to go with the long-lived one</li>
<li>if it carries both tokens, simply validate the short-lived one. If it&rsquo;s expired, repeat the process on the previous point. If it&rsquo;s valid instead, there&rsquo;s no need to check the long-lived one as well</li>
</ul>


<p>This allows you to keep a session active for a very long time (the validity of the long-lived token) but only check for its validity on the database every N minutes, depending on the validity of the short-lived token. Every time the short-lived token expires, you can go ahead and re-validate the long-lived one, hitting the database.</p>

<p>Other major companies, such as Facebook, keep track of all of your sessions in order to offer an increased level of security:</p>

<p><img class="center" src="/images/wasec/facebook-sessions.png"></p>

<p>This approach definitly &ldquo;costs&rdquo; them more, but I&rsquo;d argue it&rsquo;s essential for such a service, where the safety of its user&rsquo;s information is extremely important. As we stated multiple times before, choose your approach after carefully reviewing your priorities, as well as your goals.</p>

<h2>My CDN was compromised!</h2>

<p>Often times, web applications serve part of their content through a CDN, typically in the form of static assets like Javascript or CSS files, while the &ldquo;main&rdquo; document is rendered by a webserver. This gives developers very limited control over the static assets themselves, as they&rsquo;re usually uploaded to a 3rd-party CDN (eg. CoudFront, Google Cloud CDN, Akamai).</p>

<p>Now, suppose an attacker gained access to your login credentials on the CDN provider&rsquo;s portal and uploaded a modified version of your static assets, injecting malicious code. How could you prevent such a risk for your users?</p>

<p>Browser vendors have a solution for you, called <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity">sub-resource integrity</a> (abbr. SRI). Long-story short, SRI allows your main application to generate cryptographic hashes of your static files and tell the browser which file is mapped to what hash. When the browser downloads the static asset from the CDN, it will calculate the asset&rsquo;s hash on-the-fly, and make sure that it matches the one provided in the main document. If the hashes don&rsquo;t match the browser will simply refuse to execute or render the asset.</p>

<p>This is how you can include an asset with an <em>integrity hash</em> in your document:</p>

<p>```html
&hellip;</p>

<script 
  src="https://my.cdn.com/asset.js" 
  integrity="sha256-Y34u3VVVcO2pZtmdTnfZ+7OquEpJj/VawhuWPB4Fwq3ftcFc0gceft1HNZ14eUHT"
></script>


<p>&hellip;
```</p>

<p>The <em>integrity hash</em> can be computed with a simple:</p>

<p><code>console
cat $ASSET_FILE_NAME | openssl dgst -sha384 -binary | openssl base64 -A
</code></p>

<p>A working example can be found at <a href="https://github.com/odino/wasec/tree/master/sub-resource-integrity">github.com/odino/wasec/tree/master/sub-resource-integrity</a>: after you&rsquo;ve ran the webserver with a simple <code>node index.js</code> you can visit <a href="http://wasec.local:7888">http://wasec.local:7888</a> to see SRI in action.</p>

<p>Two scripts are included in the page you&rsquo;re opening, one that&rsquo;s <em>legitimate</em> and one that&rsquo;s supposed to simulate an attacker&rsquo;s attempt to inject malicious code in one of your assets. As you can see, the attacker&rsquo;s attempt proceeds without any issue when SRI is turned off:</p>

<p><img class="center" src="/images/wasec/sri_off.png"></p>

<p>By visiting <a href="http://wasec.local:7888/?sri=on">http://wasec.local:7888/?sri=on</a> we get a completely different outcome, as the browser realizes that there&rsquo;s a script that doesn&rsquo;t seem to be genuine, and doesn&rsquo;t let it execute:</p>

<p><img class="center" src="/images/wasec/sri_on.png"></p>

<p>Here is what our HTML looks like when SRI is turned on:</p>

<p>```html
<html>
<body></p>

<pre><code>&lt;script src="https://odino.org/asset.js" integrity="sha256-Z67eKNNu3z1gzgMcRCqRQo4f4gtT6pM0y6BHe/r5OGY="&gt;&lt;/script&gt;
&lt;script src="https://odino.org/attack.js" integrity="sha256-AN_INTEGRITY_THAT_DOESNT_MATCH"&gt;&lt;/script&gt;
</code></pre>

<p></body>
</html>
```</p>

<p>A very clever trick from browser vendors, and your users are secured should anything happen to the files hosted on a separate CDN. Clearly this doesn&rsquo;t prevent an attacker from attacking your &ldquo;main&rdquo; resource (ie. the main HTML document), but it&rsquo;s an additional layer of security you couldn&rsquo;t count on until a few years ago.</p>

<h2>The slow death of EV certificates</h2>

<p>More than once in my career I&rsquo;ve been asked to provision an EV certificate for web applications I was managing, and every single time I managed my way out of it &mdash; not because of lazyness, but rather due to the security implications of these certificates. In short? They don&rsquo;t have any influence on security, and cost a whole lot of money: let&rsquo;s try to understand what EV certificates are and why you don&rsquo;t really need to use one.</p>

<p>Extended Validation certificates (abbr. EV) are a type of SSL certificates that aims to increase the users' security by performing additional verification before the issuance of the certificate. This additional level of scrutiny would, on paper, allow CAs to prevent bad actors from obtaining SSL certificates to be used for malicious purposes &mdash; a truly remarkable feat if it would actually work that way: there were some egregious cases instead, like the one where <a href="https://arstechnica.com/information-technology/2017/12/nope-this-isnt-the-https-validated-stripe-website-you-think-it-is/">a researcher named Ian Carrol was able to obtain an EV certificate for an entity named &ldquo;Stripe, inc&rdquo; from a CA</a>. Long story short, CAs are not able to guarantee an increased level of security for EV certificates.</p>

<p>If you&rsquo;re wondering why are EV certificates still a thing to this day, let me give you a quick answer: under the false assumption of &ldquo;added security&rdquo;, EV certificates used to have a special UI in browsers, sort of a &ldquo;vanity&rdquo; feature CAs would charge exorbitant amount of money for (in some cases more than $1000 for a single-domain EV certificate). This is how an EV certificate would show up in the user&rsquo;s browser:</p>

<p><img class="center" src="/images/wasec/ev-cert.png"></p>

<p>As you can see, there is a &ldquo;nice&rdquo; UI pattern here, with the problem being that it is of no use from a security perspective. As soon as research after research started to point out how ineffective EV certificates are, in terms of security, browsers started to adapt, discouraging websites from purchasing EV certificates. This is how the browser bar looks like when you access stripe.com from Chrome 77 onwards:</p>

<p><img class="center" src="/images/wasec/non-ev-cert.png"></p>

<p>The additional information (such as the organization&rsquo;s name) has been moved to the &ldquo;Page Info&rdquo; section, which is accessible by clicking on the lock icon on the address bar:</p>

<p><img class="center" src="/images/wasec/ev-chrome-77.png"></p>

<p>Mozilla has implemented a similar pattern starting with Firefox 70, so it&rsquo;s safe to safe you shouldn&rsquo;t bother with EV certificates anymore:</p>

<ul>
<li>they do not offer any increased level of security for your users</li>
<li>they do not get a &ldquo;preferential&rdquo; UI at the browser-level, making it a very inefficient expense compared to regular SSL certificates you can obtain (<a href="https://letsencrypt.org">Let&rsquo;s Encrypt</a> certificates are free, for example)</li>
</ul>


<p>Troy Hunt summed the EV experience quite well:</p>

<p><blockquote><p>EV is now really, really dead. The claims that were made about it have been thoroughly debunked and the entire premise on which it was sold is about to disappear. So what does it mean for people who paid good money for EV certs that now won&rsquo;t look any different to DV? I know precisely what I&rsquo;d do if I was sold something that didn&rsquo;t perform as advertised and became indistinguishable from free alternatives&hellip;</p><footer><strong>Troy Hunt <a href="https://www.troyhunt.com/extended-validation-certificates-are-really-really-dead/">https://www.troyhunt.com/extended-validation-certificates-are-really-really-dead/</a> Extended Validation Certificates are (Really</strong> <cite>Really) Dead</cite></footer></blockquote></p>

<h2>Paranoid mode: on</h2>

<p>Remember: being paranoid might sometime cause a scoff from one of your colleagues or trigger their eye roll, but don&rsquo;t let that deter you from doing your job and making sure the right precautions are being taken.</p>

<p>Some users, for example, do not appreciate enforcing 2FA on their account, or might not like to have to CC their manager in an email to get an approval, but your job is to make sure the ship is tight and secure, even if it means having to implement some annoying checks or processes along the way. This doesn&rsquo;t mean you should ask your colleagues to get a notary public to attest their printed request for a replacement laptop, so always try to be reasonable.</p>

<p>I still remember being locked out of an AWS account (I stupidly let my password expire) and having to ask our Lead System Administrator for a password reset with an email along the lines of &ldquo;<em>Hi X, I&rsquo;m locked out of my AWS account, can you reset my password and share a new, temporary one here?</em>&rdquo;.</p>

<p>The response? A message on WhatsApp:</p>

<p><img class="center" src="/images/wasec/oba-paranoid.png"></p>

<p>This was the right thing to do, as a person with malicious intentions could have just gotten a hold of my email account and try to steal credentials by posing as me. Again, being paranoid is often times a virtue.</p>

<h2>Low-priority and delegated domains</h2>

<p>What is Google?</p>

<p>A search engine you might say, but then you&rsquo;d find yourself thinking about the vast amount of products that they offer and quickly realize Google is a conglomerate that offers a growing number of products, starting with household names such as <a href="https://maps.google.com">Maps</a> to little-known services like <a href="https://keep.google.com">Keep</a> or <a href="https://play.google.com/store/apps/details?id=com.google.chromeremotedesktop&amp;hl=en">Chrome Remote Desktop</a>.</p>

<p>You might be wondering where we&rsquo;re headed, so let me clarify that right now: the organization you work for probably has more than one service it offers to customers, and those services might not really be related to each other. Some of them, for example, could be low-priority ones the company works on, such as a corporate or engineering blog, or a URL shortener your customers can use alongside other, far bigger services you offer. Often, these servics, sit on a domain such as <code>blog.example.com</code>.</p>

<p>&ldquo;What&rsquo;s the harm?&rdquo;, you say. I would counter that using your main domain to store low-priority services can harm your main business, and you could be in for a lot of trouble. Even though there&rsquo;s nothing inherently wrong with using subdomains to serve different services, you might want to think about offloading low-priority services to a different domain: the reasoning behind this choice is that, if the service running on the subdomain gets compromised, it will be much harder for attackers to escalate the exploit to your main service(s).</p>

<p>As we&rsquo;ve seen, cookies are often shared across multiple subdomains (by setting the <em>domain</em> attribute to something such as <code>*.example.com</code>, <code>.example.com</code> or simply <code>example.com</code>), so a scenario could play out where you install a popular blogging software such as WordPress on <code>engineering-blog.example.com</code> and run with it for a few months, forgetting to upgrade the software and install security patches as they get published. Later, an XSS in the blogging platform allows an attacker to dump all cookies present on your blog somewhere in his control, meaning that users who are logged onto your main service (<code>example.com</code>) who visit your engineering blog could have their credentials stolen. If you had kept the engineering blog on a separate domain, such as <code>engineering-blog.example.io</code>, that would not have been possible.</p>

<p>In a similar fashion, you might sometime need to delegate domain to external entities, such as email providers &mdash; this is a crucial step as it allows them to do their job properly. Sometimes, though, these providers might have security flaws on their interfaces as well, meaning that your users, on your domains, are going to be at risk. Evaluate if you could move these providers to a separate domain, as it could be helpful from a security perspective. Assess risks and goals and make a decision accordingly: as always, there&rsquo;s no silver bullet.</p>

<h2>OWASP</h2>

<p>Truth to be told, I would strongly recommend you to visit the OWASP website
and find out what they have to say:</p>

<ul>
<li>OWASP Cheat Sheet Series (<a href="https://cheatsheetseries.owasp.org">https://cheatsheetseries.owasp.org</a>): a collection of brief, practical information. You can find inspiring articles such as how to harden Docker containers or in what form should passwords be stored. It is a very technical and comprehensive list of guides that inspired the practical approach used in this chapter of WASEC</li>
<li>OWASP Developer Guide (<a href="https://github.com/OWASP/DevGuide">https://github.com/OWASP/DevGuide</a>): a guide on how to build secure applications. It is slowly being rewritten (the original version was pubished in 2005) but most of the content is still very useful</li>
<li>OWASP Testing Guide (<a href="https://www.owasp.org/index.php/OWASP_Testing_Guide_v4_Table_of_Contents">https://www.owasp.org/index.php/OWASP_Testing_Guide_v4_Table_of_Contents</a>): on how to test for security holes</li>
</ul>


<p>These are 3 very informative guides that should help you infusing resistance against attacks across your architecture, so I&rsquo;d strongly suggest going through them at som point in time. The Cheat Sheet Series, in particular, is extremely recommended.</p>

<h2>Hold the door</h2>

<p>Now that we went through a few common scenarios you might be faced with in your career, it&rsquo;s time to look at the type of attack that has garnered the most attention in recent years due to the widespread adoption of both cloud computing and IoT devices, allowing attackers to create armies of loyal soldiers ready to wreck havoc with our networks.</p>

<p>They are distributed, they are many, they grow in intensity each and every year and represent a constant treat to public-facing companies on the internet: it&rsquo;s time to look a DDOS attacks.</p>

<p>

<div class="series_nav">
  
  
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WASEC: Understanding the Browser]]></title>
    <link href="https://odino.org/wasec-understanding-the-browser/"/>
    <updated>2018-07-29T13:54:00+00:00</updated>
    <id>https://odino.org/wasec-understanding-the-browser</id>
    <content type="html"><![CDATA[<p><ol class="aseries">
	<p>This post is part of the "<strong><a href="/categories/wasec/">WASEC: Web Application SECurity</a></strong>" series, which is a portion of the content of <a href="https://leanpub.com/wasec">WASEC</a>, an e-book on web application security I've written.</p>
	<p>Here is a list of all the articles in this series:</p>
	<li>
		<a href="/web-security-demistified/">Web security demystified: WASEC</a>
	</li>
	<li>
		<a href="/introduction-to-web-application-security/">Introduction</a>
	</li>
	<li>
		<a href="/wasec-understanding-the-browser/">Understanding the browser</a>
	</li>
	<li>
		<a href="/security-https-perspective/">Security at the HTTP level</a>
	</li>
	<li>
		<a href="/secure-your-web-application-with-these-http-headers/">HTTP headers to secure your application</a>
	</li>
	<li>
		<a href="/security-hardening-http-cookies/">Hardening HTTP cookies</a>
	</li>
	<li>
		<a href="/wasec-web-application-security-what-to-do-when-dot-dot-dot/">Situationals</a>
	</li>
	</br>
	<p>
		If you've enjoyed the content of this article, consider buying the complete ebook on either the <a href="https://www.amazon.com/WASEC-Application-Everything-developer-application-ebook/dp/B081Z7SD48">Kindle store</a> or <a href="https://leanpub.com/wasec">Leanpub</a>.
	</p>
</ol>
</p>

<p>I want to open this series with an article aimed at understanding what browsers do,
and a brief explanation on how they do so. It is important since most of your
customers will interact with your web application through a browser, so it&rsquo;s
imperative to understand the basics of these wonderful programs.</p>

<!-- more -->


<p><strong>The browser is a rendering engine</strong>: its job is to download a
web page and render it in a way that&rsquo;s understandable by a
human being.</p>

<p>Even though this is an almost-criminal oversimplification,
it&rsquo;s all we need to know for now: the user enters
an address in the browser bar, the browser downloads the &ldquo;document&rdquo;
at that URL and renders it.</p>

<p><img class="center" src="/images/wasec/browser.png"></p>

<p>You might be used to work with one of the most popular browsers such
as Chrome, Firefox, Edge or Safari, but that does not mean that
there aren&rsquo;t different browsers out there: <a href="https://lynx.browser.org/">lynx</a>, for example,
is a lightweight, text-based browser that works from your command
line. At the heart of lynx lie the same exact principles that
you would find in any other &ldquo;mainstream&rdquo; browser: a user enters
a web address (URL), the browser fetches the document and renders
it &mdash; the only difference being the fact that lynx does not use
a visual rendering engine but rather a text-based interface,
which makes websites like Google look like this:</p>

<p><img class="center" src="/images/wasec/lynx.png"></p>

<p>We broadly understand what a browser does, but let&rsquo;s take a closer
look at the steps these ingenious applications do for us.</p>

<h2>What does a browser do?</h2>

<p>Long story short, a browser&rsquo;s job mainly consists of:</p>

<ul>
<li>DNS resolution</li>
<li>HTTP exchange</li>
<li>rendering</li>
<li>rinse and repeat</li>
</ul>


<p><strong>DNS resolution</strong> makes sure that once the user enters a URL,
the browser knows to which server it has to connect to:
the browser contacts a DNS server to find that <code>google.ae</code>
translates to <code>216.58.207.110</code>, an IP address the browser
can connect to.</p>

<p>Once the browser has identified which server is going to
serve our request, it will initiate a TCP connection with it
and begin the <strong>HTTP exchange</strong>: this is nothing but a way for
the browser to communicate to the server what he wants, and
for the server to reply back. HTTP is simply the name of the most popular
protocol for communicating on the web, and browsers mostly talk via HTTP when
communicating with servers. An HTTP exchange involves the client (our browser)
sending a <strong>request</strong>, and the server replying back with a <strong>response</strong>.</p>

<p>For example, after the browser has successfully connected to
the server behind <code>google.com</code>, it will send a request that looks
like the following:</p>

<p><code>
GET / HTTP/1.1
Host: google.com
Accept: */*
</code></p>

<p>Let&rsquo;s break the request down, line by line:</p>

<ul>
<li><code>GET / HTTP/1.1</code>: with this first line, the browser aks the server to retrieve
the document at the location <code>/</code>, adding that the rest of the request will follow
the HTTP/1.1 protocol (it could also used <code>1.0</code> or <code>2</code>)</li>
<li><code>Host: google.com</code>: this is <strong>the only HTTP header mandatory in HTTP/1.1</strong>. Since
the server might serve multiple domains (<code>google.com</code>, <code>google.co.uk</code>, etc) the
client here mentions that the request was for that specific host</li>
<li><code>Accept: */*</code>: an optional header, where the browser is telling the server that
it will accept any kind of response back. The server could have a resource that
available in JSON, XML or HTML formats, so it can pick whichever format it prefers</li>
</ul>


<p>In this example, the browser, which acts as a <strong>client</strong>, is done with its request;
now it&rsquo;s the turn of the server to reply back:</p>

<p>```
HTTP/1.1 200 OK
Cache-Control: private, max-age=0
Content-Type: text/html; charset=ISO-8859-1
Server: gws
X-XSS-Protection: 1; mode=block
X-Frame-Options: SAMEORIGIN
Set-Cookie: NID=1234; expires=Fri, 18-Jan-2019 18:25:04 GMT; path=/; domain=.google.com; HttpOnly</p>

<p>&lt;!doctype html>&lt;html">
&hellip;
&hellip;
</html>
```</p>

<p>Whoa, that&rsquo;s a lot of information to digest: the server lets us know that the
request was successful (<code>200 OK</code>) and adds a few headers to the <strong>response</strong>,
for example, it advertises what server processed our request
(<code>Server: gws</code>), what&rsquo;s the <code>X-XSS-Protection</code> policy of this response and so on and
so forth. You do not need to understand each and every single information, as
we will treat the HTTP protocol, its headers and so on later on in their dedicated
chapters. For now, all you need to understand is that the client and the server
are exchanging information, and that they do so via HTTP.</p>

<p>Last but not least, the <strong>rendering</strong> process: how good would a browser be if
the only thing it would show to the user is a list of funny characters?</p>

<p><code>
&lt;!doctype html&gt;&lt;html"&gt;
...
...
&lt;/html&gt;
</code></p>

<p>In the <strong>body</strong> of the response, the server includes the representation of the
response according to the <code>Content-Type</code> header: in our case, the content type
was set to <code>text/html</code>, so we are expecting HTML markup in the response &mdash;
which is exactly what we find in the body. This is where a browser truly shines:
it parses the HTML, loads additional resources included in
the markup (for example, there could be JavaScript files or CSS documents to fetch)
and presents them to the user as soon as possible.</p>

<p>Once more, the end result is something the average Joe can understand:</p>

<p><img class="center" src="/images/wasec/browser.png"></p>

<p>For a more detailed version of what really happens when we hit enter in the address
bar of a browser I would suggest to read &ldquo;<a href="https://github.com/alex/what-happens-when">What happens when&hellip;</a>&rdquo;,
a very elaborate attempt at explaining the mechanics behind the process.</p>

<p>Since this is a series focused on security, I am going to drop a hint on what we&rsquo;ve
just learned: <strong>attackers easily make a living out of vulnerabilities in
the HTTP exchange and rendering part</strong>. Vulnerabilities, and malicious users, lurk
elsewhere as well, but a better security approach on those levels already allows you
to make strides in improving your security posture.</p>

<h2>Vendors</h2>

<p>The 4 most popular browser out there belong to different vendors:</p>

<ul>
<li>Chrome by Google</li>
<li>Firefox by Mozilla</li>
<li>Safari by Apple</li>
<li>Edge by Microsoft</li>
</ul>


<p>Beside battling each other in order to increase their market penetration, vendors
also engage with each other in order to improve the <strong>web standards</strong>, which are
a sort of &ldquo;minimum requirements&rdquo; for browsers.</p>

<p>The <a href="https://www.w3.org/">W3C</a> is the body behind the development
of the standards, but it&rsquo;s not unusual for browsers to develop their own features
that eventually make it as web standards, and security is no exception to that.</p>

<p>Chrome 51, for example, <a href="https://www.chromestatus.com/feature/4672634709082112">introduced SameSite cookies</a>,
a feature that would allow web applications to get rid of a particular type of
vulnerability known as CSRF (more on this later). Other vendors decided
this was a good idea and followed suit, leading to SameSite being a web standard:
as of now, <a href="https://caniuse.com/#search=samesite">Safari is the only major browser without SameSite cookie support</a>.</p>

<p><img class="center" src="/images/wasec/samesite.png"></p>

<p>This tells us 2 things:</p>

<ul>
<li>Safari does not seem to care enough about their users' security (just kidding: SameSite cookies
will be available in Safari 12, which might have already been released by the time
you&rsquo;re reading this book)</li>
<li><strong>patching a vulnerability on one browser does not mean that all your users are safe</strong></li>
</ul>


<p>The first point is a shot at Safari (as I mentioned, just kidding!), while the
second information is really important: when developing web applications, we don&rsquo;t
just need to make sure that they look the same across various browsers, but
also that they ensure our users are protected in the same way across platforms.
<strong>Your strategy towards web security should vary according to what a browser&rsquo;s vendor
allows us to do</strong>: nowadays, most browsers support the same set
of features and rarely deviate from their common roadmap, but instances like
the one above still happen, and it&rsquo;s something we need to take into account
when defining our security strategy.</p>

<p>In our case, if we decide that we&rsquo;re going to mitigate CSRF attacks only through
SameSite cookies, we should be aware that we&rsquo;re putting our Safari users at risk.
And our users should know that too.</p>

<p>Last but not least, you should remember that you can decide whether to support a
browser version or not: supporting each and every browser version would be impractical
(think of Internet Explorer 6); making sure that the last few versions of the
major browser are supported, though, it&rsquo;s generally a
good decision. If you don&rsquo;t plan to offer protection on a particular platform,
though, it&rsquo;s generally advisable to let your users know.</p>

<blockquote><h2>Don&rsquo;t support outdated browsers</h2>

<p>You should never encourage your users to use outdated browsers, or actively
support them. Even though you might have took all the necessary precautions,
other web developer won&rsquo;t. Encourage users to use the latest supported version
of one of the major browsers.</p></blockquote>

<h2>Vendor or standard bug?</h2>

<p>The fact that the average user accesses our application through a 3rd party client
(the browser) adds another level of indirection towards a clear, secure browsing
experience: the browser itself might present a security vulnerability.</p>

<p>Vendors generally provide rewards (aka <em>bug bounties</em>) to security researchers
who can find a vulnerability on the browser itself &mdash; these bugs are not tied to
your implementation, but rather to how the browser handles security
on its own. The <a href="https://www.google.com/about/appsecurity/chrome-rewards/">Chrome reward program</a>,
for example, lets security engineers reach out to the Chrome security team to
report vulnerabilities they have found; if these vulnerabilities are confirmed,
a patch is issued, a security advisory notice is generally released to the public
and the researcher receives a (usually financial) reward from the program.</p>

<p>Companies like Google invest a relatively good amount of capital into their
Bug Bounty programs, as it allows them to attract researchers by promising a financial
benefit should they find any problem with the application.</p>

<p>In a Bug Bounty program, everyone wins: the vendor manages to improve the security of its software, and
researchers get paid for their findings. We will discuss these programs later on
in the book, as I believe Bug Bounty initiatives deserve their own chapter in
the security landscape.</p>

<blockquote><h2>I discovered a browser bug!</h2>

<p>Jake Archibald is a developer advocate at Google who recently discovered a
vulnerability impacting more than one browser: he documented his efforts, how
he approached different vendors and their reactions in an interesting <a href="https://jakearchibald.com/2018/i-discovered-a-browser-bug/">blog
post</a> that I&rsquo;d recommend you to read.</p></blockquote>

<h2>A browser for developers</h2>

<p>By now, we should have understood a very simple but rather important concept:
<strong>browsers are simply HTTP clients built for the average internet surfer</strong>.</p>

<p>They are definitely more powerful than a platform&rsquo;s bare HTTP client (think of
NodeJS&rsquo;s <code>require('http')</code>, for example), but at the end of the day, they&rsquo;re &ldquo;just&rdquo;
a natural evolution of simpler HTTP clients.</p>

<p>As developers, our HTTP client of choice is probably <a href="http://curl.haxx.se">cURL</a>
by Daniel Stenberg, one of the most popular software programs web developers use
on a daily basis: it allows us to do an HTTP exchange on-the-fly, by sending an
HTTP request from our command line:</p>

<p>```
$ curl -I localhost:8080</p>

<p>HTTP/1.1 200 OK
server: ecstatic-2.2.1
Content-Type: text/html
etag: &ldquo;23724049-4096-"2018-07-20T11:20:35.526Z&rdquo;&ldquo;
last-modified: Fri, 20 Jul 2018 11:20:35 GMT
cache-control: max-age=3600
Date: Fri, 20 Jul 2018 11:21:02 GMT
Connection: keep-alive
```</p>

<p>In the example above, we have requested the document at <code>localhost:8080/</code>, and a
local server replied successfully.</p>

<p>Rather than dumping the response&rsquo;s body to the command line, here we&rsquo;ve used the
<code>-I</code> flag which tells cURL we&rsquo;re only interested in the response headers. Taking
it one step forward, we can instruct cURL to dump a few more information, including
the actual request it performs, so that we can have a better look at this whole HTTP
exchange. The option we need to use is <code>-v</code> (verbose):</p>

<p>```
$ curl -I -v localhost:8080
* Rebuilt URL to: localhost:8080/
*   Trying 127.0.0.1&hellip;
* Connected to localhost (127.0.0.1) port 8080 (#0)</p>

<blockquote><p>HEAD / HTTP/1.1
Host: localhost:8080
User-Agent: curl/7.47.0
Accept: <em>/</em></p>

<p>&lt; HTTP/1.1 200 OK
HTTP/1.1 200 OK
&lt; server: ecstatic-2.2.1
server: ecstatic-2.2.1
&lt; Content-Type: text/html
Content-Type: text/html
&lt; etag: &ldquo;23724049-4096-"2018-07-20T11:20:35.526Z&rdquo;&ldquo;
etag: "23724049-4096-"2018-07-20T11:20:35.526Z&rdquo;&ldquo;
&lt; last-modified: Fri, 20 Jul 2018 11:20:35 GMT
last-modified: Fri, 20 Jul 2018 11:20:35 GMT
&lt; cache-control: max-age=3600
cache-control: max-age=3600
&lt; Date: Fri, 20 Jul 2018 11:25:55 GMT
Date: Fri, 20 Jul 2018 11:25:55 GMT
&lt; Connection: keep-alive
Connection: keep-alive</p></blockquote>

<p>&lt;
* Connection #0 to host localhost left intact
```</p>

<p>Just about the same information is available in mainstream browsers through their
DevTools: as we&rsquo;ve seen, browsers are nothing more than elaborate HTTP clients.
Sure, they add an enormous amount of features (think of credential management,
bookmarking, history, etc) but the truth is that they were born as HTTP clients
for humans. This is important, as in most cases you don&rsquo;t need a browser to test
your web application&rsquo;s security, as you can simply &ldquo;curl it&rdquo; and have a look at
the response.</p>

<p>One final thing I&rsquo;d like us to understand is that <strong>anything can be a browser</strong>: if
you have a mobile application that consumes APIs through the HTTP protocol, then the
app is your browser &mdash; it just happens to be a highly customized one you built
yourself, one that only understands a specific type of HTTP responses (from your own
API).</p>

<h2>Into the HTTP protocol</h2>

<p>As we mentioned, the <strong>HTTP exchange</strong> and <strong>rendering</strong> phases are the ones that we&rsquo;re
mostly going to cover, as they provide the largest number
of <strong>attack vectors</strong> for malicious users. In the next article, we&rsquo;re going to
take a deeper look at the HTTP protocol and try to understand what measures we
should take in order to secure HTTP exchanges.</p>

<p>



<div class="series_nav">
  
  
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Emit a Beeping Sound With JavaScript]]></title>
    <link href="https://odino.org/emit-a-beeping-sound-with-javascript/"/>
    <updated>2018-06-15T07:35:00+00:00</updated>
    <id>https://odino.org/emit-a-beeping-sound-with-javascript</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/cashier.png"></p>

<p>When you go to your favorite grocery store and the cashier processes your products,
he or she will most likely scan them through a barcode scanner which will emit a
sound &mdash; a sound that&rsquo;s only there to signal that the scan was successful, and
he or she can move onto the next product.</p>

<p>When you develop user interfaces for repetitive tasks, and especially when some sort
of scanning is required, it might make a lot of sense to think of giving your
users additional feedback so that they don&rsquo;t have to go back and look at the screen
every time they process an action &mdash; they can probably simply <em>hear</em> a confirmation
sound, or <em>feel</em> an alarming buzz.</p>

<p>Let&rsquo;s dig a bit deeper.</p>

<!-- more -->


<h2>Bzzzzzz</h2>

<p>If you&rsquo;re giving your users a mobile device, the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Vibration_API">vibration API</a>
is a low-hanging fruit: by just <code>navigator.vibrate(1000)</code> you&rsquo;ll have a device
that buzzes for a second. Want to create interesting patterns? Then do something
such as:</p>

<ul>
<li><code>navigator.vibrate(200)</code>, a short buzz indicating the action went fine</li>
<li><code>navigator.vibrate(2000)</code>, a long buzz indicating there was some sort of error</li>
<li><code>navigator.vibrate([300, 300, 300])</code>, 3 short buzzes indicating a task is completed</li>
</ul>


<p>&hellip;and so on and so forth: the vibration API is absurdly easy, so I&rsquo;m simply leaving
it for you to experiment with it.</p>

<h2>BEEP! BEEP! BEEP! BOOP!</h2>

<p>Something a tad better is a snippet I found today, which simplifies audio feedback
quite significantly:</p>

<p>``` js
a=new AudioContext() // browsers limit the number of concurrent audio contexts, so you better re-use'em</p>

<p>function beep(vol, freq, duration){
  v=a.createOscillator()
  u=a.createGain()
  v.connect(u)
  v.frequency.value=freq
  v.type=&ldquo;square&rdquo;
  u.connect(a.destination)
  u.gain.value=vol<em>0.01
  v.start(a.currentTime)
  v.stop(a.currentTime+duration</em>0.001)
}
```</p>

<script type="text/javascript">
a=new AudioContext()
function beep(vol, freq, duration){
  v=a.createOscillator()
  u=a.createGain()
  v.connect(u)
  v.frequency.value=freq
  v.type="square"
  u.connect(a.destination)
  u.gain.value=vol*0.01
  v.start(a.currentTime)
  v.stop(a.currentTime+duration*0.001)
}
</script>


<p>This snippet can be used to generate interesting sounds such as:</p>

<p><button style="width: 30%; height: 150px; font-size: 2em" onclick="beep(100, 520, 200)">Beep</button>
<button style="width: 30%; height: 150px; font-size: 2em" onclick="beep(999, 220, 300)">Boop</button>
<button style="width: 30%; height: 150px; font-size: 2em" onclick="beep(999, 210, 800); beep(999, 500, 800);">Cool noise</button></p>

<p>You can actually <a href="https://www.beepbox.co">create songs with this kind of stuff</a> (<a href="https://www.beepbox.co/#6n42s6k7l02e0zt9m0a7g0Dj9i1r1o323200T1d0c2AbF0B0V7Q2500Pd4c0E7171T1d1c0A2F1B7V1Q4000Pf700E8911T0w4f1d1c0h8v1T0w1f1d1c0h0v0T0w2f3d1c0h0v2T1d1c0A2F1B8V1Q4000Pa600E8901T1d1c0A3F0B8V1Q5310Pcda0E0631T1d1c0A1F0B0V1Q7300Pebc0E06b1T2w1d1v3T2w1d1v2T2w4d1v4T2w4d1v4b4x8i4w004xgB88smAa2g04q74x4i4N8j51ci4M844N0k4Ngk4xck4g830w430Al0kxdUxh8N4z4264kh8i4x8k5h8O438i4x820C8k9h8h40018h4N4h4N4j4h4hgR0i0g4g4g018y8i8y8x8x8y4w020h80404hp288kPUj7gM7bN74cyRCfeXJjJOe8VKlBVEqMQxYHaOI_fPYyTpTtGqWMTkQxLFF38QQxA6W2F31xBE6AdwraWWlevMgVop2Addmjgswd58mCOSUdBBA3tpnnjpmYlljARpdejjCddapAFHB4TpGStICGqWoAoRFH84idFIa9QKh8YBhpIp5O0rntuw0C5ctM96CC2GFFwkPQllkQRFFHHFFwtc_sgM71chN38JpzPKXlWD9UxwelBVMqMRxVE39zwhOFxQj_ifXyu9KOqsCD4fbwo233tpp0TSlRQSlwFBF0j7i7uelcbByOxMgWwQ1j2w2gt0i7NUGAdl8qp4dcA6UyTn1FLGJ3m3r3N0dC6j6i2VlEqraHgFxU2h1i2CzdKH2CdcVoK0aoCmm1G3i6CGEdgqgGpCi0rgS5Rj20ySMdllwqgRwi0gOGhFzUOGUdgqgJdlgqwQCk04NFwpho2Cyw58aqa0kwqqagkQk0F1jhg2A5d58aqa0kwFEE1i1jc0H3m6AK000">proof</a>).</p>

<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API">WebAudio API</a> is <a href="https://caniuse.com/#search=AudioContext">widely supported</a>, so you shouldn&rsquo;t have too many problems
rolling it out across platforms:</p>

<p><img class="center" src="/images/webaudio.png"></p>

<p>At <a href="https://www.namshi.com">Namshi</a>, we have provided our warehouse agents with devices to store, locate and
move inventory &mdash; needless to say, combining these 2 APIs (vibration + sound) allows
our efficiency to increase while working on more repetitive tasks.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Hope Is That IE Will Drown in 2 Years]]></title>
    <link href="https://odino.org/the-hope-is-that-ie-will-drown-in-2-years/"/>
    <updated>2012-08-03T18:27:00+00:00</updated>
    <id>https://odino.org/the-hope-is-that-ie-will-drown-in-2-years</id>
    <content type="html"><![CDATA[<p>More than a decade ago the first <a href="http://en.wikipedia.org/wiki/Browser_wars">browser war</a>
made his victim: it was Netscape, which
couldn&rsquo;t compete with Microsoft and its
IE: after long time, it&rsquo;s time for this
decadent winner to retreat.</p>

<!-- more -->


<p>Today I was spending a few minutes on
<a href="http://caniuse.com/">IcanUse</a>, a brilliant service which
gives you informations on features implemented
by modern web browsers: not surprisingly,
IE is a total disappointment.</p>

<p>So I decided to take a look at what the <strong>current</strong> browsers
are implementing, retrieving some nice
charts to compare them against each other:</p>

<p><img class="center <a" src="href="https://chart.googleapis.com/chart?cht=bvs&amp;chco=4D89F9,C6D9FD&amp;chd=t:31,83,94,75,65|100,100,100,100,100&amp;chxl=0:|IE|Firefox|Chrome|Safari|Opera&amp;chs=750x400&amp;chxt=x,y&amp;chbh=120&amp;chtt=Implementation%20of%20JS-related%20feature">https://chart.googleapis.com/chart?cht=bvs&amp;chco=4D89F9,C6D9FD&amp;chd=t:31,83,94,75,65|100,100,100,100,100&amp;chxl=0:|IE|Firefox|Chrome|Safari|Opera&amp;chs=750x400&amp;chxt=x,y&amp;chbh=120&amp;chtt=Implementation%20of%20JS-related%20feature</a>"></p>

<p><img class="center <a" src="href="https://chart.googleapis.com/chart?cht=bvs&amp;chco=4D89F9,C6D9FD&amp;chd=t:59,88,97,94,97|100,100,100,100,100&amp;chxl=0:|IE|Firefox|Chrome|Safari|Opera&amp;chs=750x400&amp;chxt=x,y&amp;chbh=120&amp;chtt=Implementation%20of%20SVG-related%20feature">https://chart.googleapis.com/chart?cht=bvs&amp;chco=4D89F9,C6D9FD&amp;chd=t:59,88,97,94,97|100,100,100,100,100&amp;chxl=0:|IE|Firefox|Chrome|Safari|Opera&amp;chs=750x400&amp;chxt=x,y&amp;chbh=120&amp;chtt=Implementation%20of%20SVG-related%20feature</a>"></p>

<p><img class="center <a" src="href="https://chart.googleapis.com/chart?cht=bvs&amp;chco=4D89F9,C6D9FD&amp;chd=t:63,82,89,88,73|100,100,100,100,100&amp;chxl=0:|IE|Firefox|Chrome|Safari|Opera&amp;chs=750x400&amp;chxt=x,y&amp;chbh=120&amp;chtt=Implementation%20of%20CSS-related%20feature">https://chart.googleapis.com/chart?cht=bvs&amp;chco=4D89F9,C6D9FD&amp;chd=t:63,82,89,88,73|100,100,100,100,100&amp;chxl=0:|IE|Firefox|Chrome|Safari|Opera&amp;chs=750x400&amp;chxt=x,y&amp;chbh=120&amp;chtt=Implementation%20of%20CSS-related%20feature</a>"></p>

<p><img class="center <a" src="href="https://chart.googleapis.com/chart?cht=bvs&amp;chco=4D89F9,C6D9FD&amp;chd=t:40,71,94,80,80|100,100,100,100,100&amp;chxl=0:|IE|Firefox|Chrome|Safari|Opera&amp;chs=750x400&amp;chxt=x,y&amp;chbh=120&amp;chtt=Implementation%20of%20HTML5-related%20feature">https://chart.googleapis.com/chart?cht=bvs&amp;chco=4D89F9,C6D9FD&amp;chd=t:40,71,94,80,80|100,100,100,100,100&amp;chxl=0:|IE|Firefox|Chrome|Safari|Opera&amp;chs=750x400&amp;chxt=x,y&amp;chbh=120&amp;chtt=Implementation%20of%20HTML5-related%20feature</a>"></p>

<p>It&rsquo;s not a surprise that IE9 is the worst browser out there,
but this made me think about how long it will be
a competitor in the market.</p>

<p>IE is slowly dying, <a href="http://upload.wikimedia.org/wikipedia/commons/8/86/Usage_share_of_web_browsers_%28Source_StatCounter%29.svg">we all know</a>:
just as netscape, it&rsquo;s not able to face competitors
pushing hard to deliver the best
web-browsing experience.</p>

<p>It will take a few months, maybe years, to see
IE leaving the market kicked out by the yougsters,
nontheless it will be a great day for the
internet: the day that who fights for the
innovation will definitely overwhelm who
sits on top of his past, glorious days.</p>
]]></content>
  </entry>
  
</feed>