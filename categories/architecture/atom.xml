<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Category: Architecture | Alessandro Nadalin]]></title>
  <link href="https://odino.org/categories/architecture/atom.xml" rel="self"/>
  <link href="https://odino.org/"/>
  <updated>2022-02-21T09:37:30+00:00</updated>
  <id>https://odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Book Review: Code Simplicity]]></title>
    <link href="https://odino.org/book-review-code-simplicity/"/>
    <updated>2017-09-23T22:08:00+00:00</updated>
    <id>https://odino.org/book-review-code-simplicity</id>
    <content type="html"><![CDATA[<p>People who work with me tend to realize, quite soon, how much I
strive towards trying to build simple software: simplicity keeps
code reusable, open and easy to maintain or evolve &mdash; the toll
abstractions take is generally a heavy one, and I try to avoid it
every time I can (been guilty of building complex, and some time complicated,
stuff too!): to me, <strong>simplicity is king</strong>.</p>

<p>Now, I was really excited to find out that the main dev behind
Bugzilla, the OS bug tracker, wrote a book about simplicity in software
as &ndash; I thought &ndash; he could give me a really good overview of keeping
things simple in such a huge (and dated) project.</p>

<!-- more -->


<p><img class="right <a" src="href="https://images-na.ssl-images-amazon.com/images/I/51c4Mbgv-pL._SX379_BO1,204,203,200_.jpg">https://images-na.ssl-images-amazon.com/images/I/51c4Mbgv-pL._SX379_BO1,204,203,200_.jpg</a>"></p>

<p>So I went ahead and bought myself a copy of &ldquo;<a href="https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848">Code simplicity</a>&rdquo; and,
to be honest, it was a fairly intriguing book: nothing groundbreaking
but, at the end of the day, it is a solid book that gives you some
inspiration.</p>

<p>Even though you might not agree with everything the author puts on the
table, you will find yourself going through some pearls on software design
and how to design good software, through simple &amp; coincise code:</p>

<p><blockquote><p>The difference between a bad programmer and a good programmer is understanding.</p></blockquote></p>

<p><blockquote><p>Programming, in essence, must become the act of reducing complexity to simplicity.</p></blockquote></p>

<p><blockquote><p>You must not design by committee.</p></blockquote></p>

<p><blockquote><p>The desirability of any change is directly proportional to the value of the change and inversely proportional to the effort involved in making the change.</p></blockquote></p>

<p><blockquote><p>nearly all decisions in software design reduce entirely to measuring the future value of a change versus its effort of maintenance.</p></blockquote></p>

<p><blockquote><p>It is more important to reduce the effort of maintenance than it is to reduce the effort of implementation.</p></blockquote></p>

<p><blockquote><p>there is a difference between designing in a way that allows for future change and attempting to predict the future.</p></blockquote></p>

<p><blockquote><p>Code should be designed based on what you know now, not on what you think will happen in the future.</p></blockquote></p>

<p><blockquote><p>the more you code, the more defects you will introduce.</p></blockquote></p>

<p><blockquote><p>Never “fix” anything unless it’s a problem, and you have evidence showing that the problem really exists.</p></blockquote></p>

<p><blockquote><p>The ease of maintenance of any piece of software is proportional to the simplicity of its individual pieces.</p></blockquote></p>

<p><blockquote><p>Names should be long enough to fully communicate what something is or does without being so long that they become hard to read.</p></blockquote></p>

<p><blockquote><p>Consistency is a big part of simplicity. If you do something one way in one place, do it that way in every place.</p></blockquote></p>

<p><blockquote><p>Some projects start out with such a complex set of requirements that they never get a first version out. If you’re in this situation, you should just trim features. Don’t shoot for the moon in your first release — get out something that works and make it work better over time.</p></blockquote></p>

<p><blockquote><p>Some of the best programming is done on paper, really. Putting it into the computer is just a minor detail.</p></blockquote></p>

<p><blockquote><p>Comments should explain why the code is doing something, not what it is doing.</p></blockquote></p>

<p><blockquote><p>When presented with complexity, ask, “What problem are you trying to solve?”</p></blockquote></p>

<p>As a &ldquo;secondary read&rdquo;<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup> I think this is a pretty solid book!</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>When I say &ldquo;secondary&rdquo; I mean one of those backup books you read throughout a long span of time, nothing that deserves your undivided attention while reading but is still valuable to you <a href='#fnref:1' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Book Review: Release It -- Design and Deploy Production-Ready Software]]></title>
    <link href="https://odino.org/book-review-release-it-design-and-deploy-production-ready-software/"/>
    <updated>2017-03-16T14:00:00+00:00</updated>
    <id>https://odino.org/book-review-release-it-design-and-deploy-production-ready-software</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been reading quite a bit over the past 2/3 months (thanks to &mdash; believe it
or not &mdash; my wife), and today I wanted to share my review of
<a href="https://www.amazon.com/Release-Production-Ready-Software-Pragmatic-Programmers/dp/0978739213">Release It! Design and Deploy Production-Ready Software</a>.</p>

<!-- more -->


<p><img class="right" src="/images/book-release-it.jpg"></p>

<p>The book is extremely interesting as it&rsquo;s a collection of patterns and practices
to build reliable and robust distributed systems, with a few advices on process
design as well: for example, I extremely liked, at the beginning of the book,
the notion that a lot of software architects are living in the &ldquo;<a href="http://www.lessonsoffailure.com/developers/avoid-asshole-architect/">ivory tower</a>&rdquo;,
meaning that they are distant from the real-world code that turns their ideas
into working software, and rely too much on the <em>happy-path</em> rather than
recognizing that, more often that we&rsquo;d like, systems are going to fail.</p>

<p>Another trait of the book I really liked is the fact that the author brings his
own experience to the table: you&rsquo;ll read about weird situations where an e-commerce
portal used to be down every night at a specific time, how a &ldquo;dumb&rdquo; firewall can
kill all of your idle connections and so on; by the end of the book you&rsquo;ll surely
be hating on firewalls, connection pools and (missing) timeouts.</p>

<p>The only negative I can think of is that the book is a bit too <em>java-ish</em>, as
sometimes you might feel some ideas won&rsquo;t really apply to the platform you
generally work with &mdash; but, to be honest, that&rsquo;s no biggie.</p>

<p>Strongly, strongly recommended for software engineers that want to understand how
their systems should be modeled once they reach a certain scale and, inevitably,
need to deal with failure.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On Monoliths, Service-oriented Architectures and Microservices]]></title>
    <link href="https://odino.org/on-monoliths-service-oriented-architectures-and-microservices/"/>
    <updated>2015-02-20T19:48:00+00:00</updated>
    <id>https://odino.org/on-monoliths-service-oriented-architectures-and-microservices</id>
    <content type="html"><![CDATA[<p>In the last few years web architectures have
been evolving pretty fast, and the result is
that now we have a few approaches to pick
between when building your next software
architecture.</p>

<!-- more -->


<h2>Monoliths</h2>

<p><img class="right" src="/images/monolith.png"></p>

<p>Monolithic architectures are the ones
running on a single application layer
that tends to bundle together all the functionalities
needed by the architecture.</p>

<p>At the architectural level, this is the
simplest form of architecture simply
because it doesn&rsquo;t involve
as many actors as other architectural
styles.</p>

<p>If we, for example, want to build a web
architecture with a monolithic approach,
we would start developing the frontend of it and
make it access data directly rather than
giving it an abstraction layer such as an API.</p>

<p>Most setups, nowadays, run through a monolithic
approach as, for small/mid sized architectures,
it runs pretty well and keeps complexity quite
low: the <strong>problems tend to come when the
architecture needs to scale up feature-wise</strong>;
modules are extensively dependent to each other,
the code becomes hard to refactor as
it involves touching the whole monolith (think,
for example, of doing an extensive refactoring on
the <code>HttpRequest</code> class, which would impact
every single request to every single functionality
of the architecture).</p>

<p>I personally recommend monoliths for projects with
a <strong>very small and &ldquo;easy&rdquo; scope</strong>, where you don&rsquo;t
need too much abstraction and won&rsquo;t likely have
to maintain or evolve the codebase year after
year.</p>

<h2>Semi-monoliths</h2>

<p><img class="left" src="/images/semi-monoliths.png"></p>

<p>These are a bit tricky: I consider semi-monliths
decoupled architecture that actually really on
<strong>smaller, but still large, monoliths</strong>.</p>

<p>This actually means that you think of, for example
for performance reasons, decoupling your frontend
from your backend but end up building 2 (or maybe
even 3) large applications that turn into monoliths
on their own.</p>

<p>I find semi-monoliths <strong>quite harmful</strong> as they are,
in my opinion, <strong>a wrong step in the right direction</strong>:
you believe decoupling works well but do
just a bit of it, ending up with the same problems
you&rsquo;d have with monoliths, just on a bigger stage.</p>

<p>In complex architectures it&rsquo;s usually much easier
to keep each piece simple but small, whereas semi-monoliths
end up solving just the surface of a problem (ie. performance
bottlenecks) but then leave you with the complexity
of each mini-monolith.</p>

<p>I personally see very few scenarios in which
semi-monoliths are a very good choice: my rule of thumb
is that <strong>if the scope of the architecture is small
you can use a (small) app, else be wild and use
a service for each functionality</strong>, without limiting
yourself to the frontend vs backend thingy.</p>

<h2>SOA</h2>

<p><img class="right" src="/images/lego-soa.png"></p>

<p>SOAs (Service-Oriented Architectures) are a way
to &ldquo;properly&rdquo; evolve from semi-monoliths to a more
diversified architecture.</p>

<p>SOAs usually incorporate functions into small/mid-sized
applications (more on this later), <strong>a lot of them</strong>: you try to
keep the complexity of each app / functionality very low
and make them communicate over a set APIs (being them
HTTP APIs, asynchronous messaging and so on);
the services do multiple things all of which are
limited to the scope of a single functionality,
for example customer management.</p>

<p>I like to describe SOAs as<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>:</p>

<blockquote><p>A software design based on discrete software components,
&ldquo;services&rdquo;, that collectively provide the functionalities
of the larger software architecture</p></blockquote>

<p>A clear disadvantage of SOAs is that it might
be overkill: I still remember my first advice
about SOAs at the CakeFest in San Francisco 2
years ago, &ldquo;<a href="http://www.slideshare.net/odino/tips-and-tricks-for-your-service-oriented-architecture-cakefest-2013-in-san-francisco/50">avoid SOA</a>&rdquo;.</p>

<p>If you don&rsquo;t need to separate functionalities of
your architecture, simply don&rsquo;t do it: tipically
SOAs are reserved to complex products and systems
that cannot be summed up in a briefing; I clearly
remember, back at the time when I was working in
an agency, that none of our projects was really
suitable for full blown SOAs because the scope was
so limited that there would be no reason to introduce
complexity (at the architectural level).</p>

<p>On the other end, I&rsquo;d recommend to buy into several services
as soon as you realize that there is too much
complexity in the architecture: you will definitely
understand when this happens because you have clearly
defined boundaries between software components, you
start to realize that one piece of the architecture
shouldn&rsquo;t bring down the rest of it if a deployment
goes wrong and so on. In other terms, <strong>you&rsquo;ll feel it</strong>.</p>

<p>SOAs usually give you a good flexibility but, as said, come
at a cost: even though each piece has its own life,
evolves independently, doesn&rsquo;t impact the others
very much and it&rsquo;s simples, <strong>the architecture itself
becomes more complex</strong>.</p>

<p>One thing to clarify about SOAs is that, nowadays,
the term has lost its appeal due to the fact that
it <a href="http://martinfowler.com/bliki/ServiceOrientedAmbiguity.html">might mean too many things</a>:
SOA is a very general term and it&rsquo;s hard to pinpoint
what it actually represents, though, in recent years,
it seems that we all agreed that a very good way to
do SOA is through microservices.</p>

<h2>Microservices</h2>

<p><img class="right" src="/images/ants-microservices.png"></p>

<p>And here we are with <a href="http://martinfowler.com/articles/microservices.html">microservices</a>.
What do microservice-based architectures actually are?</p>

<p>I could say a lot of things but, to simplify, I will
pick my own definition:</p>

<blockquote><p>microservice-based architectures are the ones
that mimic SOAs with very small, <a href="http://en.wikipedia.org/wiki/Unix_philosophy">unix-inspired</a> services,
which do one thing and do it well</p></blockquote>

<p>What does that actually mean? Shrink those services,
make them as small and indipendent as possible and
create a hell lot of them; the only difference I see
between traditional SOAs and microservices is that
the latter clearly states that the size of a
service should be minimal, else it needs to be split
in multiple services. In other words, <strong>microservices
are an implementation of SOA</strong>.</p>

<p>As we&rsquo;ve seen with traditional SOAs, microservices bring
a lot of complexity at the architectural level as there
are even more, tiny actors involved, but the practical
advantage is that they are all isolated, indipendent
and only communicate through simple interfaces (any
kind of API).</p>

<p>This piece sums my thoughts up quite well:</p>

<p><blockquote><p>[microservices are] one form of SOA,<br/>perhaps service orientation done right</p><footer><strong>Martin Fowler on microservices <a href="http://martinfowler.com/articles/microservices.html">http://martinfowler.com/articles/microservices.html</a></strong></footer></blockquote></p>

<p>I am a fan of simplicity and good abstraction, which
means that you should have clear, neat boundaries and
APIs between your services but also should not forget
of avoiding bloating or shrinking them too much, else you end
up overengineering in both cases.</p>

<p>Using microservices also requires quite of a shift in terms
of mindset as there are a lot of things that change
in your development lifecycle: things need to be simple,
well documented, smooth and easy to run; imagine the next
guy coming to your team that, to fix a bug, has to learn
how to run 6 (micro)services together&hellip;hell! That is why
you need to figure a solution out to allow fast development
cycles and simplicity to run, deploy and evolve<sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup> those
small services.</p>

<p>So yes, microservices add complexity at the architectural
level (where you&rsquo;d likely be happy to have it) with the
advantage of outrageously <strong>simplifying each software
component</strong>, which makes it simple, for anyone, to get used
to the architecture day after day, feature after feature,
service after service.</p>

<h2>So what?</h2>

<p>I hope this clarifies some terminology and decisions
you might wanna take when building your next (big or
small) project; there will always be a lot of external
factors, like timeline or resources, to keep in
consideration but I believe it&rsquo;s very important to know
about your options.</p>

<p>Since we are talking about web architectures, I&rsquo;d like
to leave you with a pearl on <a href="http://www.aol.com/">AOL</a>
from <a href="http://highscalability.com/blog/2014/2/17/how-the-aolcom-architecture-evolved-to-99999-availability-8.html">highscalabilty</a>:</p>

<p><blockquote><p>The architecture for AOL.com is in it’s 5th generation.</p></p><p><p>It has essentially been rebuilt from scratch 5 times over two decades.</p></p><p><p>The current architecture was designed<br/>6 years ago. Pieces have been upgraded and new componentshave been added along the way, but the overall design remains largely intact.</p></p><p><p>The code, tools, development and deployment processes are highly tuned over 6 years of continual improvement, making the AOL.com architecture battle tested and very stable.</p><footer><strong>Dave Hagler</strong> <cite>Systems Architect at AOL</cite></footer></blockquote></p>

<p>Have fun with your next architecture folks!</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>I&rsquo;m not sure if this definition is purely mine or if I read it somewhere &mdash; pardon my lack of memory! <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>This last point, evolving, is taking care by the architectural style itself. Small, indipendent services are easy to evolve by definition, as they are not complex <a href='#fnref:2' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use a Custom HTTP Status Code for Your Apps' Healthchecks]]></title>
    <link href="https://odino.org/use-a-custom-http-status-code-for-your-apps-healthchecks/"/>
    <updated>2014-04-21T10:20:00+00:00</updated>
    <id>https://odino.org/use-a-custom-http-status-code-for-your-apps-healthchecks</id>
    <content type="html"><![CDATA[<p>To have systems up &amp; running is something, but to
have them healthy it&rsquo;s another story.</p>

<!-- more -->


<p>If you are looking to implement healthchecks in your
architecture beware of being a
bit too simplistic: you might configure, for example,
on of your frontend machines to check the status of the
backend ones every few seconds, so that
<a href="http://wiki.nginx.org/HttpHealthcheckModule">nginx</a> or
<a href="http://haproxy.1wt.eu/download/1.3/doc/haproxy-en.txt">haproxy</a>
can remove the backend if they find it unreliable / unhealthy.</p>

<p>Problem is, there might be tricky situations in which the
backend responds with a <code>200 Ok</code> even though it&rsquo;s not
working<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>.</p>

<p>There are a lot of ways to avoid this, but the simplest one,
that takes you 2 minutes and works quite well, is to use a
custom HTTP status code for your healthcheck page &ndash; we use
<code>211 Healthy</code>.</p>

<p>For example, in node, we would do:</p>

<p><code>javascript Serving response with a custom HTTP status code in NodeJS
res.writeHead(211);
res.write('OK');
res.end();
</code></p>

<p>and then we would need to tell our backend that the only status
code that has to be considered healthy is <code>211</code>.</p>

<p>No more, no less.</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>For example, the backend's nginx can just respond with nginx's default welcome page, if your host is misconfigured <a href='#fnref:1' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Refactoring Your Architecture Understanding SOA]]></title>
    <link href="https://odino.org/refactoring-your-architecture-go-for-soa/"/>
    <updated>2013-03-23T17:35:00+00:00</updated>
    <id>https://odino.org/refactoring-your-architecture-go-for-soa</id>
    <content type="html"><![CDATA[<p>It is no news that I work for <a href="http://en-ae.namshi.com">a company</a>
supported by <a href="http://www.rocket-internet.de">a mothership</a>
that helps most of his affiliates with know-how
and basic tools.</p>

<p>But to aim expansion, one needs to go beyond those
shared layers and start customizing his
products and services, and in terms of software development
nothing can help you more than
<a href="http://en.wikipedia.org/wiki/Service-oriented_architecture">service-oriented architectures</a>,
or <em>SOA</em>.</p>

<!-- more -->


<p>So, what&rsquo;s the goal of this post? Basically
providing our view on how we are going to
shift from our current architecture, which
is already a composite, to a more powerful
layer of services.</p>

<h2>Identifying the service</h2>

<p>One of the first steps in order to dig
into the implementation is to actually identity
a first bunch of functionalities that should be
incorporated as standalone services.</p>

<p>Usually, opportunities for new services pop up
when it&rsquo;s time to <strong>introduce a new functionality</strong>
or the cost of fixing / implementation of a
change request are too high: for example, if you
want to add the ability to send SMSes from your website,
a good service would be one which just deals with
the receiving an input event, assembling a message
and contacting the <em>real</em> SMS provider via webservice
in order to dispatch the message; another good example is
<strong>identity</strong>: if you are struggling with different userbases
that need to be in sync, a good solution would be to
centralize identities and provide a service which does,
at least, authentication.</p>

<h2>Data</h2>

<p>Another tipical question is how to manage and organize
data when you have a de-centralized architecture.</p>

<p>In SOA terms, usually data is shared among the
services but this doesnt mean that each service can&rsquo;t
have its own data-layer: it is often seen a very old
fashioned RDBMS shared across all the services and
some of them using a less traditional solution, like
a NoSQL DB; this is mainly done to achieve better
performances and different data-retrieval patterns</p>

<p>Think about legacy applications that have a model which can be
extensively customized by the end user, that usually
implement the <a href="http://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model">EAV pattern</a>,
getting stuck into <strong>performance bottlenecks</strong>, while
a document-db like MongoDB or CouchDB would
perfectly solve the issue.</p>

<p>If you are running, for example, an e-commerce system,
you may want to have transactions and identities in a
solid and robust system like MSSQL, while your
frontend can actually run with MongoDB: once the user
purchases a product, via webservice you store it into
MSSQL.</p>

<h2>Services need</h2>

<p>One typical aspect, in SOA terms, is seeking answers
to our questions (read getting <em>responses</em> for our <em>requests</em>),
a problem which we can overcame with a simple solution:
when a service <strong>needs</strong> another one, we talk about APIs.</p>

<p>For example, your frontend might offer authentication, while
the Identity manager is a service providing identities to
multiple layers of your architecture: when the frontend needs
to authenticate a user, it will directly rely on the
Identity service, asking him to authenticate the user with the
credentials he or she submitted to the frontend.</p>

<p>APIs can be traditionally categorized into <a href="http://nordsc.com/ext/classification_of_http_based_apis.html">a few types</a>:</p>

<ul>
<li>mess: &ldquo;messy&rdquo; API don&rsquo;t follow structured rules (it cab be <em>plain-old XML over HTTP</em>
or a replication of DB writes and reads in JSON format); they can
be <strong>very useful</strong> when you need to kickstart a new, small and simple
API</li>
<li>HTTP API: services that semantically expose their domain model
in terms of resources, embracing the HTTP specification</li>
<li><a href="/hypermedia-services-beyond-rest-architectures/">REST</a>: hypermedia services</li>
<li>SOAP: services using strict interfaces between clients and servers,
following the SOAP spec</li>
</ul>


<p>No matter what, you will always find yourself dealing with APIs
if you decided to go for SOA: it is the simplest way to
provide <strong>data-exchange mechanisms to layers that don&rsquo;t fully
know each other&rsquo;s domain</strong>.</p>

<h2>Services listen</h2>

<p>Another <strong>very common</strong> scenario, is when services &ldquo;listen&rdquo;,
waiting for notifications sent across by other components of
the architecture: you are probably already thinking about
messaging queues and message notifications, and you are right.</p>

<p>A event-driven process can be achieved when we have tools
such as <a href="http://www.rabbitmq.com/">RabbitMQ</a> helping in gathering
and dispatching notifications to various parts of the architecture:
with Rabbit, a service can dispatch a message to a queue
and another one (or <strong>ones</strong>), through a daemon, consumes the message.</p>

<p>Thinking about what I mentioned earlier, an SMS-dispatching mechanism
could fit in this context really well: think about SMSes that are sent
once the user completes certain actions on your frontend (by gaining credits,
placing an order on your e-commerce or so on); once the user
completes an action, a notification will be sent out and
whoever needs to listen to that message will catch
and process it.</p>

<h2>So far so good</h2>

<p>In our fast and new journey towards integrating services into
our architecture, we are finding ourselves pretty well: it is
no news that we are using RabbitMQ and <a href="http://symfony.com">Symfony2</a>
for our new, isolated services, and that we already identified
a few services that can run on their own, decoupled context.</p>

<p>Thinking in SOA terms, by the way, brings out a new set of problems, like
thinking in terms of architecture, and not of application: you
don&rsquo;t deploy a new version of your application, you <strong>update a part
of the architecture</strong>; your system is decoupled, from the code to the
processes you use to handle them. And what about the complications in the
development environments? And which monitoring tool should I use to
understand that all the components are working alltogether? And&hellip;</p>

<p>There&rsquo;s room for generic problems that everyone faced and that we will
face as well, and I think it will be very interesting to share our
approach and the vision we had in our own context.</p>
]]></content>
  </entry>
  
</feed>