<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Category: Golang | Alessandro Nadalin]]></title>
  <link href="https://odino.org/categories/golang/atom.xml" rel="self"/>
  <link href="https://odino.org/"/>
  <updated>2022-05-07T15:04:41+00:00</updated>
  <id>https://odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Book Review: Writing an Interpreter in Go]]></title>
    <link href="https://odino.org/book-review-writing-an-interpreter-in-go/"/>
    <updated>2019-01-11T11:12:00+00:00</updated>
    <id>https://odino.org/book-review-writing-an-interpreter-in-go</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/interpreter-cover.png"></p>

<p>Boy, what a book!</p>

<p>This goes right into the list of books I would
have wanted to read 10 years ago: a masterpiece
on programming languages, with the author showcasing
an excellent ability to write couple with
extremely exhaustive &mdash; but never boring &mdash;
content.</p>

<p>Long story short, <a href="https://interpreterbook.com/">the interpreter book</a> should
definitely be on your 2019 reading list unless
you&rsquo;ve already read it. If that&rsquo;s the case,
give the book another try, it&rsquo;s probably worth it.</p>

<!-- more -->


<p>First and foremost, I&rsquo;d like to start by saying that
picking <a href="https://golang.org/">Go</a> for such a topic was an excellent choice:
not everyone might be familiar with the language,
but its standard library and &ldquo;strictness&rdquo; make it
for a perfect choice for these kind of
tasks.</p>

<p>An epic feat is that the book manages to write an
entire interpreter using only the <a href="https://golang.org/pkg/">Go standard library</a>:
yes, no single dependency other than Go itself.</p>

<p>I&rsquo;m not sure how to put it into words, but the writing
style is also impeccable, as I started this book
and <em>had to</em> finish it within 4 hours &mdash; I simply
couldn&rsquo;t get over it.</p>

<p><img class="left" src="/images/compiler-cover.png"></p>

<p>Writing An Interpreter In Go will spoon-feed you
through the journey of writing &ldquo;your own programming language&rdquo;,
presenting topics such as writing a lexer and parser
in such a way that even the silliest of human beings
(<em>hey there, that&rsquo;s me!</em>) can understand them
easily. I dunno, to me this book is simply a masterpiece.</p>

<p>Worth to note that the author just recently doubled up
with a sequel to this book, <a href="https://compilerbook.com/">Writing A Compiler In Go</a>,
that takes the codebase you ended up with the interpreter
book and writes a compiler and VM for the language you&rsquo;ve
just built.</p>

<p>Go grab your copy!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Finding Where That IP Address Is From With Iploc]]></title>
    <link href="https://odino.org/finding-where-that-ip-address-is-from-with-iploc/"/>
    <updated>2018-07-07T16:45:00+00:00</updated>
    <id>https://odino.org/finding-where-that-ip-address-is-from-with-iploc</id>
    <content type="html"><![CDATA[<p>Today I spent some time building <a href="https://github.com/odino/iploc">iploc</a>, a small CLI utility that lets you retrieve
geographical information of an IP address.</p>

<!-- more -->


<p>First and foremost, I&rsquo;d like to clarify that this library is nothing but a CLI
wrapper for the <a href="http://ip-api.com/">ip-api.com</a>, which does the actual heavy-lifting
for us.</p>

<p>Long story short, <code>iploc</code> is a very small utility that let&rsquo;s you lookup geographical
information of an IP address directly from the CLI &mdash; you simply give it the address
you want to &ldquo;reverse geocode&rdquo; and it will print out a bunch of information:</p>

<p><code>
iploc 12.34.56.78
{"as":"AS7018 AT\u0026T Services, Inc.","city":"Columbus","country":"United States","countryCode":"US","isp":"AT\u0026T Services","lat":39.9653,"lon":-83.0235,"org":"AT\u0026T Services","query":"12.34.56.78","region":"OH","regionName":"Ohio","status":"success","timezone":"America/New_York","zip":"43215"}
</code></p>

<p>Indulging my passion for <a href="https://en.wikipedia.org/wiki/Seven_deadly_sins#Gluttony">gluttony</a>,
I&rsquo;ve added a <em>pretty-print</em> option for humans:</p>

<p>```
iploc 12.34.56.78 -p
{</p>

<pre><code>"as": "AS7018 AT\u0026T Services, Inc.",
"city": "Columbus",
"country": "United States",
"countryCode": "US",
"isp": "AT\u0026T Services",
"lat": 39.9653,
"lon": -83.0235,
"org": "AT\u0026T Services",
"query": "12.34.56.78",
"region": "OH",
"regionName": "Ohio",
"status": "success",
"timezone": "America/New_York",
"zip": "43215"
</code></pre>

<p>}
```</p>

<p>but you&rsquo;d really be better off with tools such as <a href="https://stedolan.github.io/jq/">jq</a>:</p>

<p><code>
iploc 12.34.56.78 | jq -r .city
Columbus
</code></p>

<p>Installing <code>iploc</code> is fairly straightforward, as you can simply grab the right binary
from the release page on GitHub:</p>

<p>```
/tmp ᐅ wget <a href="https://github.com/odino/iploc/releases/download/v1.0.0/iploc_linux_amd64_v1.0.0.tar.gz">https://github.com/odino/iploc/releases/download/v1.0.0/iploc_linux_amd64_v1.0.0.tar.gz</a>
&mdash;2018-07-07 16:35:12&mdash;  <a href="https://github.com/odino/iploc/releases/download/v1.0.0/iploc_linux_amd64_v1.0.0.tar.gz">https://github.com/odino/iploc/releases/download/v1.0.0/iploc_linux_amd64_v1.0.0.tar.gz</a>
Resolving github.com (github.com)&hellip; 192.30.253.113, 192.30.253.112
Connecting to github.com (github.com)|192.30.253.113|:443&hellip; connected.
HTTP request sent, awaiting response&hellip; 302 Found
Location: <a href="https://github-production-release-asset-2e65be.s3.amazonaws.com/140064185/ae86980c-81dd-11e8-86f7-510d153790f8?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20180707%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20180707T123513Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=32b345f28416ae597379622a361e9f01347cfac31984125353ba4801d147473e&amp;X-Amz-SignedHeaders=host&amp;actor_id=0&amp;response-content-disposition=attachment%3B%20filename%3Diploc_linux_amd64_v1.0.0.tar.gz&amp;response-content-type=application%2Foctet-stream">https://github-production-release-asset-2e65be.s3.amazonaws.com/140064185/ae86980c-81dd-11e8-86f7-510d153790f8?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20180707%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20180707T123513Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=32b345f28416ae597379622a361e9f01347cfac31984125353ba4801d147473e&amp;X-Amz-SignedHeaders=host&amp;actor_id=0&amp;response-content-disposition=attachment%3B%20filename%3Diploc_linux_amd64_v1.0.0.tar.gz&amp;response-content-type=application%2Foctet-stream</a> [following]
&mdash;2018-07-07 16:35:13&mdash;  <a href="https://github-production-release-asset-2e65be.s3.amazonaws.com/140064185/ae86980c-81dd-11e8-86f7-510d153790f8?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20180707%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20180707T123513Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=32b345f28416ae597379622a361e9f01347cfac31984125353ba4801d147473e&amp;X-Amz-SignedHeaders=host&amp;actor_id=0&amp;response-content-disposition=attachment%3B%20filename%3Diploc_linux_amd64_v1.0.0.tar.gz&amp;response-content-type=application%2Foctet-stream">https://github-production-release-asset-2e65be.s3.amazonaws.com/140064185/ae86980c-81dd-11e8-86f7-510d153790f8?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20180707%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20180707T123513Z&amp;X-Amz-Expires=300&amp;X-Amz-Signature=32b345f28416ae597379622a361e9f01347cfac31984125353ba4801d147473e&amp;X-Amz-SignedHeaders=host&amp;actor_id=0&amp;response-content-disposition=attachment%3B%20filename%3Diploc_linux_amd64_v1.0.0.tar.gz&amp;response-content-type=application%2Foctet-stream</a>
Resolving github-production-release-asset-2e65be.s3.amazonaws.com (github-production-release-asset-2e65be.s3.amazonaws.com)&hellip; 52.216.96.227
Connecting to github-production-release-asset-2e65be.s3.amazonaws.com (github-production-release-asset-2e65be.s3.amazonaws.com)|52.216.96.227|:443&hellip; connected.
HTTP request sent, awaiting response&hellip; 200 OK
Length: 2977802 (2.8M) [application/octet-stream]
Saving to: ‘iploc_linux_amd64_v1.0.0.tar.gz.1’</p>

<p>iploc_linux_amd64_v1.0.0.tar.gz.1                     100%[======================================================================================================================>]   2.84M   362KB/s    in 10s</p>

<p>2018-07-07 16:35:24 (287 KB/s) &ndash; ‘iploc_linux_amd64_v1.0.0.tar.gz.1’ saved [2977802/2977802]</p>

<p>/tmp ᐅ tar -xzf iploc_linux_amd64_v1.0.0.tar.gz                                                  <br/>
/tmp ᐅ ./iploc_linux_amd64_v1.0.0 12.34.56.78
{&ldquo;as&rdquo;:&ldquo;AS7018 AT\u0026T Services, Inc.&rdquo;,&ldquo;city&rdquo;:&ldquo;Columbus&rdquo;,&ldquo;country&rdquo;:&ldquo;United States&rdquo;,&ldquo;countryCode&rdquo;:&ldquo;US&rdquo;,&ldquo;isp&rdquo;:&ldquo;AT\u0026T Services&rdquo;,&ldquo;lat&rdquo;:39.9653,&ldquo;lon&rdquo;:-83.0235,&ldquo;org&rdquo;:&ldquo;AT\u0026T Services&rdquo;,&ldquo;query&rdquo;:&ldquo;12.34.56.78&rdquo;,&ldquo;region&rdquo;:&ldquo;OH&rdquo;,&ldquo;regionName&rdquo;:&ldquo;Ohio&rdquo;,&ldquo;status&rdquo;:&ldquo;success&rdquo;,&ldquo;timezone&rdquo;:&ldquo;America/New_York&rdquo;,&ldquo;zip&rdquo;:&ldquo;43215&rdquo;}
```</p>

<p>&hellip;that&rsquo;s it: there&rsquo;s nothing else the tool does (rightfully, I would say).</p>

<p><a href="/mssqldump-a-small-utility-to-dump-ms-sql-server-data/#a-couple-surprises">As opposed to last time</a>,
today I opted to use <a href="https://github.com/spf13/cobra">cobra</a> as I wanted to see what overhead
it would introduce in a tool this small: from my perspective, setting up the CLI app
with cobra was fairly quick and straightforward, even though the binaries are a bit
chubbier (the amd64 linux binary is 2.8mb vs 2.5mb, so nothing crazy to be honest).
Definitely recommended.</p>

<p>That&rsquo;s it for today!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Book Review: The Go Programming Language]]></title>
    <link href="https://odino.org/book-review-the-go-programmming-language/"/>
    <updated>2017-09-23T22:07:00+00:00</updated>
    <id>https://odino.org/book-review-the-go-programmming-language</id>
    <content type="html"><![CDATA[<p>Some books are so good you feel honored to be able
to read them, and &ldquo;<a href="https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440">The Go programming language</a>&rdquo;,
in my opinion, happens to make that list: it&rsquo;s a real gem.</p>

<!-- more -->


<p><img class="right <a" src="href="https://images-na.ssl-images-amazon.com/images/I/51kErZGgOZL._SX399_BO1,204,203,200_.jpg">https://images-na.ssl-images-amazon.com/images/I/51kErZGgOZL._SX399_BO1,204,203,200_.jpg</a>"></p>

<p>Now, I can&rsquo;t really tell if it&rsquo;s because I personally
like Golang a lot or because the author is some kind of
Stephen King of technical writers, but I must admit this
was one of the best books I&rsquo;ve ever read: the way it guides
you through the language, explain design decisions, common
pitfalls (and how to avoid them) and so on is simply beautiful.</p>

<p>To give you a perspective, the book is very practical, and each
chapter kind of adds a feature to the software you&rsquo;re building:</p>

<ul>
<li>first, familiarize with the language (ie. syntax)</li>
<li>then, write a small app, such as a crawler</li>
<li>then, make it perform faster through concurrency</li>
<li><em>then, make it concurrency-safe etc etc etc&hellip;</em></li>
</ul>


<p>To me, reading the book just feels like entering Rob Pike&rsquo;s brain
to understand the decisions and rationale behind Go&rsquo;s design,
standard library and so on.</p>

<p>(side note: Rob Pike actually reviewed the book. As soon as I found
out, I got quite excited!)</p>

<p>As someone who has been playing with the language for 2
years but didn&rsquo;t deploy more than 2 real-word Go apps in production,
it was definitely a good read, so I&rsquo;d encourage mid, novice
and aspiring Golang programmers to read the book.</p>

<p>Keeping in mind that I tend to be
excited about Golang in general, here&rsquo;s a bunch of significant
quotes from the book:</p>

<p><blockquote><p>creating one goroutine is cheap and creating a million is practical</p></blockquote></p>

<p><blockquote><p>go doc http.ListenAndServe</p></blockquote></p>

<p><blockquote><p>There is no limit on name length, but convention and style in Go programs lean toward short names, especially for local variables with small scopes; you are much more likely to see variables named i than theLoopIndex. Generally, the larger the scope of a name, the longer and more meaningful it should be.</p></blockquote></p>

<p><blockquote><p>normal practice in Go is to deal with the error in the if block and then return, so that the successful execution path is not indented</p></blockquote></p>

<p><blockquote><p>Get into the habit of considering errors after every function call, and when you deliberately ignore one, document your intention clearly.</p></blockquote></p>

<p><blockquote><p>the unit of encapsulation is the package, not the type as in many other languages.</p></blockquote></p>

<p><blockquote><p>The entire errors package is only four lines long</p></blockquote></p>

<p><blockquote><p>When designing a new package, novice Go programmers often start by creating a set of interfaces and only later define the concrete types that satisfy them. This approach results in many interfaces, each of which has only a single implementation. Don’t do that. Such interfaces are unnecessary abstractions; they also have a run-time cost. You can restrict which methods of a type or fields of a struct are visible outside a package using the export mechanism. Interfaces are only needed when there are two or more concrete types that must be dealt with in a uniform way.</p></blockquote></p>

<p><blockquote><p>A defer is marginally more expensive than an explicit call to Unlock, but not enough to justify less clear code. As always with concurrent programs, favor clarity and resist premature optimization. Where possible, use defer and let critical sections extend to the end of a function.</p></blockquote></p>

<p><blockquote><p>Be descriptive and unambiguous where possible. For example, don’t name a utility package util when a name such as imageutil or ioutil is specific yet still concise.</p></blockquote></p>

<p><blockquote><p>Good documentation need not be extensive, and documentation is no substitute for simplicity.</p></blockquote></p>

<p><blockquote><p>Go’s attitude to testing stands in stark contrast. It expects test authors to do most of this work themselves, defining functions to avoid repetition, just as they would for ordinary programs.</p></blockquote></p>

<p><blockquote><p>As the influential computer scientist Edsger Dijkstra put it, “Testing shows the presence, not the absence of bugs.”</p></blockquote></p>

<p><blockquote><p>Since other goroutines cannot access the variable directly, they must use a channel to send the confining goroutine a request to query or update the variable. This is what is meant by the Go mantra “Do not communicate by sharing memory; instead, share memory by communicating.”</p></blockquote></p>

<p>Go is really magical, the kind of magical that makes you productive and
leaves you speechless<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup> when writing code.</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>Note: not the PHP kind of speechless ;&ndash;)  <a href='#fnref:1' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why Did Google Create the Go Language?]]></title>
    <link href="https://odino.org/why-did-google-create-the-go-language/"/>
    <updated>2016-08-22T05:19:00+00:00</updated>
    <id>https://odino.org/why-did-google-create-the-go-language</id>
    <content type="html"><![CDATA[<p>A few days ago a very interesting digest popped up in my
inbox, straight away from <a href="https://www.quora.com/Why-did-Google-create-the-Go-language-Isnt-Python-good-enough/answer/Garry-Taylor-5?srid=pefr">Quora</a>:</p>

<p><blockquote><p>The key point here is our programmers are Googlers, they’re not researchers. They’re typically, fairly young, fresh out of school, probably learned Java, maybe learned C or C++, probably learned Python.</p></p><p><p>They’re not capable of understanding a brilliant language but we want to use them to build good software.</p></p><p><p>So, the language that we give them has to be easy for them to understand and easy to adopt.</p><footer><strong>Rob Pike <a href="https://en.wikipedia.org/wiki/Rob_Pike">https://en.wikipedia.org/wiki/Rob_Pike</a></strong></footer></blockquote></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XYZ Programming Language Sucks]]></title>
    <link href="https://odino.org/xyz-programming-language-sucks/"/>
    <updated>2016-07-12T15:05:00+00:00</updated>
    <id>https://odino.org/xyz-programming-language-sucks</id>
    <content type="html"><![CDATA[<p>I would have tweeted this, but it&rsquo;s a bit longer than
140 chars :)</p>

<!-- more -->


<p>I was recently  going through some articles about <a href="https://golang.org/">Go</a>&rsquo;s
limitations, and stumbled on this <a href="https://news.ycombinator.com/item?id=7660924">HN comment</a>:</p>

<p><blockquote><p>It&rsquo;s ironic that the &ldquo;better&rdquo; the language (for some hazy definition of &ldquo;better&rdquo;) the less actual work seems to get done with it.</p></p><p><p>So Go can be pretty annoying at times, and so can Java (I&rsquo;ve said before that I find the two almost identical, but that&rsquo;s beside the point now); and C is horrible and completely unsafe and downright dangerous.</p></p><p><p>Yet more useful working code has probably been written in Java and C than all other languages combined since the invention of the computer, and more useful code has been written in, what, 5 years of Go(?) than in 20(?) years of Haskell.</p></p><p><p>Here&rsquo;s the thing: I am willing to accept that Haskell is the best programming language ever created. People have been telling me this for over 15 years now. And yet it seems like the most complex code written in Haskell is the Haskell compiler itself (and maybe some tooling around it).<br/>If Haskell&rsquo;s clear advantages really make that much of a difference, maybe its (very vocal) supporters should start doing really impressive things with it rather than write compilers. I don&rsquo;t know, write a really safe operating system; a novel database; some crazy Watson-like machine; a never-failing hardware controller. Otherwise, all of this is just talk.</p><footer><strong>pron <a href="https://news.ycombinator.com/item?id=7661099">https://news.ycombinator.com/item?id=7661099</a></strong></footer></blockquote></p>

<p>Cheers!</p>
]]></content>
  </entry>
  
</feed>