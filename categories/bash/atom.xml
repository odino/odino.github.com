<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Category: Bash | Alessandro Nadalin]]></title>
  <link href="https://odino.org/categories/bash/atom.xml" rel="self"/>
  <link href="https://odino.org/"/>
  <updated>2021-07-18T10:30:41+00:00</updated>
  <id>https://odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Makefile 101]]></title>
    <link href="https://odino.org/makefile-101/"/>
    <updated>2018-06-15T09:53:00+00:00</updated>
    <id>https://odino.org/makefile-101</id>
    <content type="html"><![CDATA[<p>It seems like developers are afraid of using <code>make</code> as they link it to the painful
experience of compiling things from scratch &mdash; the dreaded <code>./configure &amp;&amp; make &amp;&amp; make install</code>.</p>

<p>Part of this fear is due to the description of what <a href="https://linux.die.net/man/1/make">make(1)</a>
does:</p>

<p><blockquote><p>The purpose of the make utility is to determine automatically which pieces of a large program need to be recompiled, and issue the commands to recompile them.</p><footer><strong>Free Software Foundation <a href="https://linux.die.net/man/1/make">https://linux.die.net/man/1/make</a> The Linux man pages</strong></footer></blockquote></p>

<p>Not everyone is aware that make can be easily
used to manage tasks in your projects, so I wanted to share a brief introduction
ad how <a href="https://github.com/odino/mssqldump/blob/master/Makefile">Makefiles help me automate some tasks</a>
in my day to day activities: this brief guide will focus on using make as an
automation tool for tasks rather than a tool for compiling code.</p>

<!-- more -->


<h2>Executing tasks&hellip;</h2>

<p>Let&rsquo;s start by simply creating a <code>Makefile</code>, and defining a task to run:</p>

<p><code>
task:
  date
</code></p>

<p>If you run <code>make task</code> you will bump into the following error:</p>

<p><code>
/tmp ᐅ make task
Makefile:2: *** missing separator.  Stop.
</code></p>

<p>and that&rsquo;s because Makefiles use tabs to indent code. Let&rsquo;s update our example by
using tabs rather than spaces and&hellip;   &hellip;voila:</p>

<p><code>
/tmp ᐅ make task
date
Fri Jun 15 08:34:15 +04 2018
</code></p>

<p>What kind of sorcery is this? Well, <code>make</code> understood you wanted to run the section
<code>task</code> of your makefile, and ran the code (<code>date</code>) within that section in a shell,
outputting both the command and its output. If you want skip outputting the command
that&rsquo;s being executed you can simply prefix it with an <code>@</code>:</p>

<p><code>
task:
  @date
</code></p>

<p><code>
/tmp ᐅ make task
Fri Jun 15 08:34:15 +04 2018
</code></p>

<p>The first task in a <code>Makefile</code> is the <em>default</em> one, meaning we can run <code>make</code>
without any argument:</p>

<p><code>
/tmp ᐅ make       
Fri Jun 15 08:37:11 +04 2018
</code></p>

<p>You can add additional tasks in your <code>Makefile</code> and call them with <code>make $TASK</code>:</p>

<p>```
task:</p>

<pre><code>@date
</code></pre>

<p>some:</p>

<pre><code>sleep 1
echo "Slept"
</code></pre>

<p>thing:</p>

<pre><code>cal
</code></pre>

<p>```</p>

<p>```
/tmp ᐅ make thing
cal</p>

<pre><code> June 2018        
</code></pre>

<p>Su Mo Tu We Th Fr Sa</p>

<pre><code>            1  2  
</code></pre>

<p> 3  4  5  6  7  8  9<br/>
10 11 12 13 14 15 16<br/>
17 18 19 20 21 22 23<br/>
24 25 26 27 28 29 30<br/>
```</p>

<h2>&hellip;in a specific order</h2>

<p>A lot of times you will want to execute a task before the current one &mdash; think of
it as <code>before</code> or <code>after</code> hooks in your automated tests. This can be done by specifying
a list of tasks right after your task&rsquo;s name:</p>

<p>```
task: thing some</p>

<pre><code>@date
</code></pre>

<p>&hellip;
```</p>

<p>```
/tmp ᐅ make task
cal</p>

<pre><code> June 2018        
</code></pre>

<p>Su Mo Tu We Th Fr Sa</p>

<pre><code>            1  2  
</code></pre>

<p> 3  4  5  6  7  8  9<br/>
10 11 12 13 14 15 16<br/>
17 18 19 20 21 22 23<br/>
24 25 26 27 28 29 30</p>

<p>sleep 1
echo &ldquo;Slept&rdquo;
Slept
Fri Jun 15 08:40:23 +04 2018
```</p>

<h2>Variables</h2>

<p>Defining and using variables is fairly straightforward:</p>

<p>```
VAR=123</p>

<p>print_var:</p>

<pre><code>    echo ${VAR}
</code></pre>

<p>&hellip;
```</p>

<p><code>
/tmp ᐅ make print_var    
echo 123
123
</code></p>

<p>but watch out as your shell variables won&rsquo;t work out of the box:</p>

<p>```
print_user:</p>

<pre><code>    echo $USER
</code></pre>

<p>```</p>

<p><code>
/tmp ᐅ make print_user   
echo SER
SER
</code></p>

<p>as you will need to escape them with either <code>${VAR}</code> or <code>$$VAR</code>.</p>

<p>Passing flags is also a bit different from what you might be used to &mdash; they&rsquo;re
positioned as flags but use the same syntax as environment variables:</p>

<p>```
print_foo:</p>

<pre><code>echo $$FOO
</code></pre>

<p>```</p>

<p>```
/tmp ᐅ make print_foo
echo $FOO</p>

<p>/tmp ᐅ make print_foo FOO=bar
echo $FOO
bar
```</p>

<h2>The shell</h2>

<p>```</p>

<h2>5.3.1 Choosing the Shell</h2>

<p>The program used as the shell is taken from the variable <code>SHELL'.  If
this variable is not set in your makefile, the program</code>/bin/sh' is
used as the shell.
```</p>

<p>Make will use <code>sh</code> to execute code in a task, meaning some stuff might not work
as you&rsquo;re probably using some syntax that&rsquo;s specific to bash &mdash; in order to switch
you can simply specify the <code>SHELL</code> variable (in our case
we would want to use <code>SHELL:=/bin/bash</code>).</p>

<p>As seen before, sometimes you will need to use a quirky, custom syntax to get a
regular shell command to work in <code>make</code> &mdash; just like variables need to be escaped
with a <code>$$</code> or <code>${...}</code>, you will need to use <code>shell</code> when using <a href="http://tldp.org/LDP/abs/html/commandsub.html">command substitution</a>:</p>

<p>```
subshell:</p>

<pre><code>echo $(shell echo ${USER})
</code></pre>

<p>```</p>

<p><code>
/tmp ᐅ make subshell
echo alex
alex
</code></p>

<p>Don&rsquo;t believe me? Try removing the <code>shell</code> instruction and here&rsquo;s what you&rsquo;re going
to get:</p>

<p>```
/tmp ᐅ make subshell
echo</p>

<p>```</p>

<h2>Conclusion</h2>

<p>There&rsquo;s so much more <code>make</code> can do, and so many more quirky things you might need
to find out to decrease the wps (<em>WTF per second</em>) when working with it :) that
doesn&rsquo;t erase the fact that <code>make</code> is an extremely helpful took that allows us
to automate workflows with ease, without having to setup very complicated pipelines,
by writing tab-separated lines with a bunch of shell commands instead.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Little Bit of Strace Doesn't Hurt]]></title>
    <link href="https://odino.org/a-little-bit-of-strace-doesnt-hurt/"/>
    <updated>2018-01-11T14:05:00+00:00</updated>
    <id>https://odino.org/a-little-bit-of-strace-doesnt-hurt</id>
    <content type="html"><![CDATA[<p><a href="https://linux.die.net/man/1/strace">strace(1)</a> is an amazing tool that you can use to debug processes that went south
when nothing else helps.</p>

<!-- more -->


<p>At it&rsquo;s core, strace simply runs a command and prints out all system calls
executed:</p>

<p>```
$ strace echo &ldquo;1&rdquo; > test.txt</p>

<p>execve(&ldquo;/bin/echo&rdquo;, [&ldquo;echo&rdquo;, &ldquo;1&rdquo;], [/<em> 79 vars </em>/]) = 0
brk(NULL)                               = 0xa99000
access(&ldquo;/etc/ld.so.nohwcap&rdquo;, F_OK)      = -1 ENOENT (No such file or directory)
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0fe9a58000
access(&ldquo;/etc/ld.so.preload&rdquo;, R_OK)      = -1 ENOENT (No such file or directory)
open(&ldquo;/etc/ld.so.cache&rdquo;, O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=105962, &hellip;}) = 0
mmap(NULL, 105962, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f0fe9a3e000
close(3)                                = 0
access(&ldquo;/etc/ld.so.nohwcap&rdquo;, F_OK)      = -1 ENOENT (No such file or directory)
open(&ldquo;/lib/x86_64-linux-gnu/libc.so.6&rdquo;, O_RDONLY|O_CLOEXEC) = 3
read(3, &ldquo;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0P\t\2\0\0\0\0\0&rdquo;&hellip;, 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=1868984, &hellip;}) = 0
mmap(NULL, 3971488, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f0fe946b000
mprotect(0x7f0fe962b000, 2097152, PROT_NONE) = 0
mmap(0x7f0fe982b000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c0000) = 0x7f0fe982b000
mmap(0x7f0fe9831000, 14752, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f0fe9831000
close(3)                                = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0fe9a3d000
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0fe9a3c000
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0fe9a3b000
arch_prctl(ARCH_SET_FS, 0x7f0fe9a3c700) = 0
mprotect(0x7f0fe982b000, 16384, PROT_READ) = 0
mprotect(0x606000, 4096, PROT_READ)     = 0
mprotect(0x7f0fe9a5a000, 4096, PROT_READ) = 0
munmap(0x7f0fe9a3e000, 105962)          = 0
brk(NULL)                               = 0xa99000
brk(0xaba000)                           = 0xaba000
open(&ldquo;/usr/lib/locale/locale-archive&rdquo;, O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=10305248, &hellip;}) = 0
mmap(NULL, 10305248, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f0fe8a97000
close(3)                                = 0
fstat(1, {st_mode=S_IFREG|0664, st_size=0, &hellip;}) = 0
write(1, &ldquo;1\n&rdquo;, 2)                      = 2
close(1)                                = 0
close(2)                                = 0
exit_group(0)                           = ?
+++ exited with 0 +++
```</p>

<p>Now, that&rsquo;s quite a bit of information: you will see each and every system call
that&rsquo;s been run in order to execute your command, with arguments (up to a certain
length) and the exit code.</p>

<p>How is this useful? Well, in order to debug a running process you can simply
<em>strace</em> it by its pid:</p>

<p>```
$ sleep 20 &amp;</p>

<p>[1] 15977</p>

<p>$ strace -p $!</p>

<p>strace: Process 15977 attached
restart_syscall(&lt;&hellip; resuming interrupted nanosleep &hellip;>) = 0
close(1)                                = 0
close(2)                                = 0
exit_group(0)                           = ?
+++ exited with 0 +++
[1]+  Done                    sleep 20
```</p>

<p>(note that <code>$!</code> is the pid of the previous process, it&rsquo;s just a magic shell variable)</p>

<p>Now we&rsquo;re talking! Remember that process that inexplicably hangs after running
for a couple minutes? Let&rsquo;s run it, then find its pid and strace it on the fly.</p>

<p>You can even trace child processes and even threads with the <code>-f</code> option, so
that you can literally follow anything your parent process triggers &mdash; just this
week this turned out handy for me since I needed to debug an android app running
on an emulated device, which can be easily done through something like:</p>

<p>```
$ adb shell</p>

<p>(in the emulated device)</p>

<p>$ ps -A | grep com.myapp</p>

<p>(get the pid)</p>

<p>$ strace -f -p $PID
```</p>

<p>Remember: when you think there&rsquo;s nothing left to try, strace(1) will always have
your back.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unix Goodies to the Rescue - Vol.2]]></title>
    <link href="https://odino.org/unix-goodies-to-the-rescue-vol-dot-2/"/>
    <updated>2017-12-08T19:20:00+00:00</updated>
    <id>https://odino.org/unix-goodies-to-the-rescue-vol-dot-2</id>
    <content type="html"><![CDATA[<p>A couple years ago I wrote a post presenting a few <a href="/4-unix-goodies-i-cannot-live-without/">unix commands that save me on
a daily basis</a>, and I thought it&rsquo;s probably
time to expand on that lists and add stuff I&rsquo;ve grown fond of over the past few years.</p>

<!-- more -->


<h2>Locating a binary</h2>

<p>I just downloaded an updated version of <a href="https://www.terraform.io/">terraform</a> and I want to replace the old one I
have in my system. The problem is&hellip;I can&rsquo;t remember where I placed it, and my
<code>$PATH</code> looks very confusing:</p>

<p><code>
~ ᐅ echo $PATH
/usr/local/heroku/bin:/home/alex/local/bin:/home/alex/bin:/home/alex/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/lib/go-1.9/bin:/bin:/home/alex/Downloads:/home/alex/Downloads/google-cloud-sdk/bin:/usr/local/sbin:/usr/local/bin:/home/alex/local/node/bin:/home/alex/projects/go/bin:/home/alex/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/alex/.rvm/gems/ruby-2.0.0-p195/bin:/home/alex/.rvm/gems/ruby-2.0.0-p195@global/bin:/home/alex/.rvm/rubies/ruby-2.0.0-p195/bin:/home/alex/.rvm/bin:/usr/lib/lightdm/lightdm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/alex/.rvm/bin:/home/alex/.rvm/bin:/home/alex/.rvm/bin:/home/alex/.rvm/bin
</code></p>

<p>Fear no more, as <code>which</code> can be used to instantly locate binaries:</p>

<p>```
~ ᐅ which terraform
/home/alex/bin/terraform</p>

<p>~ ᐅ mv ./new-terraform $(which terraform)
```</p>

<p>If your script is, for example, a bash script, you can even edit it by just <code>vi $(which $SCRIPT)</code>.</p>

<h2>awk</h2>

<p>Once an <em>awk-er</em>, always an awk-er.</p>

<p>I find myself using awk mostly when I need to run bash commands based on the input of
another command. For example, let&rsquo;s say I want to ping all hosts that are mapped to
<code>127.x.x.x</code> from my <code>/etc/host</code>:</p>

<p>```
~ ᐅ cat /etc/hosts
127.0.0.1   localhost
127.0.1.1   puma</p>

<h1>minikube</h1>

<p>192.168.99.100 kube.local</p>

<h1>The following lines are desirable for IPv6 capable hosts</h1>

<p>::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters</p>

<p>~ ᐅ cat /etc/hosts | grep 127 | awk &lsquo;{print &ldquo;ping -c 1 &rdquo; $2}&rsquo;
ping -c 1 localhost
ping -c 1 puma</p>

<p>~ ᐅ cat /etc/hosts | grep 127 | awk &lsquo;{print &ldquo;ping -c 1 &rdquo; $2}&rsquo; | bash
PING localhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.076 ms</p>

<p>&mdash;&ndash; localhost ping statistics &mdash;&ndash;
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.076/0.076/0.076/0.000 ms
PING puma (127.0.1.1) 56(84) bytes of data.
64 bytes from puma (127.0.1.1): icmp_seq=1 ttl=64 time=0.051 ms</p>

<p>&mdash;&ndash; puma ping statistics &mdash;&ndash;
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.051/0.051/0.051/0.000 ms
```</p>

<p>I was introduced to awk ~8 years ago, when SVN was still a thing &mdash; if I remember correctly,
SVN did not allow an &ldquo;add all&rdquo; like git (<code>git add .</code>), so you had to mark all files you
wanted to commit separately, and that&rsquo;s when awk started to become handy.</p>

<h2>Do I have to type it all over AGAIN?</h2>

<p>How many times have you found yourself in the middle of a long-ass command when you
realize you need to run something else before that? Are you going yo throw away all
you&rsquo;ve typed so far?</p>

<p>Well, add a comment to that command, press enter and re-run it later on:</p>

<p>```
~ ᐅ #cat /etc/hosts | grep 127 | awk &lsquo;{print &ldquo;ping -c 1 &rdquo; $2}&rsquo; | bash</p>

<p>~ ᐅ echo &ldquo;127.0.0.1 noplacelikehome.com&rdquo; >> /etc/hosts</p>

<p>~ ᐅ cat /etc/hosts | grep 127 | awk &lsquo;{print &ldquo;ping -c 1 &rdquo; $2}&rsquo; | bash
PING localhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.091 ms</p>

<p>&mdash;&ndash; localhost ping statistics &mdash;&ndash;
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.091/0.091/0.091/0.000 ms
PING puma (127.0.1.1) 56(84) bytes of data.
64 bytes from puma (127.0.1.1): icmp_seq=1 ttl=64 time=0.060 ms</p>

<p>&mdash;&ndash; puma ping statistics &mdash;&ndash;
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.060/0.060/0.060/0.000 ms
PING noplacelikehome.com (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.039 ms</p>

<p>&mdash;&ndash; noplacelikehome.com ping statistics &mdash;&ndash;
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.039/0.039/0.039/0.000 ms
```</p>

<p>Oversimplifying: when you hit enter in the terminal you end up running a bash one-liner,
so if you prepend <code>#</code> to the command, it will simply be executed as a comment &mdash; but will
still be saved in your history.</p>

<h2>Decoding base64 text</h2>

<p>If you, like me, end up dealing with base64 input (k8s' secrets anyone?) it could
be really handy to just decode it on the fly through a pipe:</p>

<p><code>
~ ᐅ echo MTIzNAo= | base64 -d
1234
</code></p>

<h2>Repeating a command</h2>

<p>This is a glorified version of a for loop, but <code>repeat</code> comes really handy sometimes:</p>

<p><code>
~ ᐅ repeat 1000 echo hello &amp;&amp; sleep 1
hello
hello
hello
^C%
</code></p>

<p>I generally use this as a poor man&rsquo;s benchmarking tool when I want to generate little
traffic on an endpoint (eg. a staging service) and compare pre/post some changes (It&rsquo;s
not a benchmarking tool but gives you a good idea early on without having to go through
<a href="https://github.com/tsenart/vegeta">vegeta</a> or similar stuff.</p>

<h2>Sleeping forever</h2>

<p>Sometimes you want to be able to halt a program indefinitely, or until a <code>ctrl+c</code> kicks
in.</p>

<p>You could use a while loop and a sleep or, on some systems, simply sleep forever:</p>

<p>```
~ ᐅ sleep infinity</p>

<p>(black hole here)
```</p>

<p>Worth to note that infinity is only available on a few linux systems (I think both ubuntu
and debian support it but, for example, alpine doesn&rsquo;t) so you might have to end up using
a while loop for portability.</p>

<h2>Waiting for background tasks</h2>

<p>This is something I&rsquo;ve been using in bash scripts, when I want to run things in
parallel and be able to do some other work once all of them are done (think, for example,
of backing up several mysql tables in parallel and then move them to s3 in one go) &mdash;  you can simply
move processes to the background and <code>wait</code> for them to finish:</p>

<p><code>
~ ᐅ echo "start"; sleep 1 &amp; sleep 2 &amp; sleep 3 &amp; echo "scheduled"; wait; echo "done"
start
[1] 5922
[2] 5923
[3] 5924
scheduled
[1]    5922 done       sleep 1
[2]  - 5923 done       sleep 2
[3]  + 5924 done       sleep 3
done
</code></p>
]]></content>
  </entry>
  
</feed>