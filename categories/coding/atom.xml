<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Category: Coding | Alessandro Nadalin]]></title>
  <link href="https://odino.org/categories/coding/atom.xml" rel="self"/>
  <link href="https://odino.org/"/>
  <updated>2022-02-21T09:37:30+00:00</updated>
  <id>https://odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Book Review: Code Simplicity]]></title>
    <link href="https://odino.org/book-review-code-simplicity/"/>
    <updated>2017-09-23T22:08:00+00:00</updated>
    <id>https://odino.org/book-review-code-simplicity</id>
    <content type="html"><![CDATA[<p>People who work with me tend to realize, quite soon, how much I
strive towards trying to build simple software: simplicity keeps
code reusable, open and easy to maintain or evolve &mdash; the toll
abstractions take is generally a heavy one, and I try to avoid it
every time I can (been guilty of building complex, and some time complicated,
stuff too!): to me, <strong>simplicity is king</strong>.</p>

<p>Now, I was really excited to find out that the main dev behind
Bugzilla, the OS bug tracker, wrote a book about simplicity in software
as &ndash; I thought &ndash; he could give me a really good overview of keeping
things simple in such a huge (and dated) project.</p>

<!-- more -->


<p><img class="right <a" src="href="https://images-na.ssl-images-amazon.com/images/I/51c4Mbgv-pL._SX379_BO1,204,203,200_.jpg">https://images-na.ssl-images-amazon.com/images/I/51c4Mbgv-pL._SX379_BO1,204,203,200_.jpg</a>"></p>

<p>So I went ahead and bought myself a copy of &ldquo;<a href="https://www.amazon.com/Code-Simplicity-Fundamentals-Max-Kanat-Alexander-ebook/dp/B007NZU848">Code simplicity</a>&rdquo; and,
to be honest, it was a fairly intriguing book: nothing groundbreaking
but, at the end of the day, it is a solid book that gives you some
inspiration.</p>

<p>Even though you might not agree with everything the author puts on the
table, you will find yourself going through some pearls on software design
and how to design good software, through simple &amp; coincise code:</p>

<p><blockquote><p>The difference between a bad programmer and a good programmer is understanding.</p></blockquote></p>

<p><blockquote><p>Programming, in essence, must become the act of reducing complexity to simplicity.</p></blockquote></p>

<p><blockquote><p>You must not design by committee.</p></blockquote></p>

<p><blockquote><p>The desirability of any change is directly proportional to the value of the change and inversely proportional to the effort involved in making the change.</p></blockquote></p>

<p><blockquote><p>nearly all decisions in software design reduce entirely to measuring the future value of a change versus its effort of maintenance.</p></blockquote></p>

<p><blockquote><p>It is more important to reduce the effort of maintenance than it is to reduce the effort of implementation.</p></blockquote></p>

<p><blockquote><p>there is a difference between designing in a way that allows for future change and attempting to predict the future.</p></blockquote></p>

<p><blockquote><p>Code should be designed based on what you know now, not on what you think will happen in the future.</p></blockquote></p>

<p><blockquote><p>the more you code, the more defects you will introduce.</p></blockquote></p>

<p><blockquote><p>Never “fix” anything unless it’s a problem, and you have evidence showing that the problem really exists.</p></blockquote></p>

<p><blockquote><p>The ease of maintenance of any piece of software is proportional to the simplicity of its individual pieces.</p></blockquote></p>

<p><blockquote><p>Names should be long enough to fully communicate what something is or does without being so long that they become hard to read.</p></blockquote></p>

<p><blockquote><p>Consistency is a big part of simplicity. If you do something one way in one place, do it that way in every place.</p></blockquote></p>

<p><blockquote><p>Some projects start out with such a complex set of requirements that they never get a first version out. If you’re in this situation, you should just trim features. Don’t shoot for the moon in your first release — get out something that works and make it work better over time.</p></blockquote></p>

<p><blockquote><p>Some of the best programming is done on paper, really. Putting it into the computer is just a minor detail.</p></blockquote></p>

<p><blockquote><p>Comments should explain why the code is doing something, not what it is doing.</p></blockquote></p>

<p><blockquote><p>When presented with complexity, ask, “What problem are you trying to solve?”</p></blockquote></p>

<p>As a &ldquo;secondary read&rdquo;<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup> I think this is a pretty solid book!</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>When I say &ldquo;secondary&rdquo; I mean one of those backup books you read throughout a long span of time, nothing that deserves your undivided attention while reading but is still valuable to you <a href='#fnref:1' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The 5 Golden Rules When Writing Open Source Software]]></title>
    <link href="https://odino.org/the-5-golden-rules-when-writing-open-source-software/"/>
    <updated>2014-07-05T21:29:00+00:00</updated>
    <id>https://odino.org/the-5-golden-rules-when-writing-open-source-software</id>
    <content type="html"><![CDATA[<p>There you are, you just opened your laptop
and got the inspiration to write a bunch of
code and release it open-source: sounds quite
simple and easy, but you should always keep
in mind a few rules that are going to boost
your &ldquo;creature&rdquo; before releasing it to the
public.</p>

<!-- more -->


<h2>Documentation</h2>

<blockquote><p>If it&rsquo;s not documented, it doesn&rsquo;t exist</p></blockquote>

<p>That&rsquo;s probably the biggest truth of OSS: if you don&rsquo;t
provide a good <a href="https://github.com/visionmedia/express">README</a>
or some <a href="http://pypy.readthedocs.org/en/improve-docs/index.html">more complete docs</a>
it&rsquo;s gonna be hard for people to be able to understand
the value of your software, or to even give it a try and
get straight to the point.</p>

<p><a href="https://readthedocs.org/">ReadTheDocs</a> is an awesome project
that lets you create beautiful documentation for your projects
for free but, if you want to keep things simple, github&rsquo;s
<a href="https://pages.github.com/">pages</a> or <a href="https://help.github.com/articles/about-github-wikis">wiki</a>
might be what you were looking for.</p>

<h2>Packaging</h2>

<p><img class="left" src="/images/npm-logo.png" title="" ></p>

<p>Do never forget about shipping it in a way that makes it easy,
for others, to install your software in a matter of seconds:
a great example, in this sense, is <a href="https://www.npmjs.org/">NPM</a>
for NodeJS, which lets you install modules with a simple <code>npm install moduleName</code>.</p>

<p>This is possible with basically any platform out there: PHP has
<a href="https://getcomposer.org/">Composer</a>, Ruby has <a href="https://rubygems.org/">Gems</a>
and Python uses, if I&rsquo;m not wrong, <a href="https://pypi.python.org/pypi/pip">pip</a>
(there are many other examples, like CocoaPods and so on, but the ones
i mentioned seem to be most mature and stable nowadays<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>).</p>

<h2>Visibility</h2>

<p><img class="right" src="/images/github-logo.png" title="" ></p>

<p>I don&rsquo;t know about you, but I always have a strange feeling
when I open a link to a project and it&rsquo;s hosted somewhere like,
let&rsquo;s say, <a href="https://code.google.com/">GoogleCode</a>: I wouldn&rsquo;t
say that your choices are limited, but whenever you&rsquo;re
gonna pick a hosting solution for your library it&rsquo;s though to look
anywhere but <a href="https://github.com/">Github</a>, as they have:</p>

<ul>
<li>great user experience</li>
<li>good platform for engagement (pull requests, comments)</li>
<li><a href="https://github.com/github">love for the OSS world</a></li>
<li>awesome <a href="https://github.com/blog">vision and communication</a></li>
<li><a href="https://www.flickr.com/photos/ginatrapani/5016915048/">tricks</a> to make your experience fabolous</li>
</ul>


<p>If you want to look for widespread alternatives, though, you might
find Atlassian&rsquo;s <a href="https://bitbucket.org/">BitBucket</a> the most
serious competitor of GitHub.</p>

<h2>Coding standards</h2>

<p>Follow the coding standards that are <em>en vogue</em> in your community:
for example, in PHP you got the <a href="http://www.php-fig.org/">PSR</a>s,
which are guidelines for writing your code, created by the
PHP community itself (or &ndash; at least &ndash; its most prominent members).</p>

<p>Writing code with your own standard will just make it
harder for the ones interested in your project: you want them
to be able to focus on what you&rsquo;re offering and to discuss it,
not to spend too much time reading commas and brackets in weird
positions.</p>

<h2>Tests</h2>

<p><img class="left" src="/images/travis-logo.png" title="" ></p>

<p>Automated tests are probably a must if you plan to have
people relying on your software, especially if what it does
is not contained in very few lines of code (and in any case,
even there tests are so much helpful).</p>

<p>Tests will also help you evaluating contributions from the
community: other devs will get interested in your software,
find a glitch, fix it, add a test and send you a pull
request. At that point you only have to check the code,
because the tests are gonna take care of the build on their own.</p>

<p>Nowadays you don&rsquo;t even have to boot your own machine to run
the tests: hook your library with <a href="https://travis-ci.org/">travis-ci</a>
and you&rsquo;re done!</p>

<h2>Recap</h2>

<p>Before announcing your latest project to the world, I would:</p>

<ul>
<li>put it on github or bitbucket</li>
<li>write a decent <code>README.md</code></li>
<li>create the package on the most suitable package manager</li>
<li>review the code to check everything makes sense</li>
<li>add tests and let them run on Travis</li>
</ul>


<p>I&rsquo;m sure I might have missed something&hellip;   &hellip;so you tell me,
what are <strong>your</strong> golden rules?</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>Besides, probably, apt :) <a href='#fnref:1' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>
]]></content>
  </entry>
  
</feed>