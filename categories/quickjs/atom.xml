<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Category: Quickjs | Alessandro Nadalin]]></title>
  <link href="https://odino.org/categories/quickjs/atom.xml" rel="self"/>
  <link href="https://odino.org/"/>
  <updated>2022-11-18T09:33:53+00:00</updated>
  <id>https://odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Playing With QuickJS]]></title>
    <link href="https://odino.org/playing-with-quickjs/"/>
    <updated>2019-07-23T12:14:00+00:00</updated>
    <id>https://odino.org/playing-with-quickjs</id>
    <content type="html"><![CDATA[<p>A few days ago <a href="https://bellard.org/">Fabrice Bellard</a> released
<a href="https://bellard.org/quickjs/">QuickJS</a>, a small JS engine that
targets embedded systems.</p>

<p>Curious to give it a try, I downloaded and set it up on my system
to try and understand this incredible piece of software.</p>

<!-- more -->


<h2>Installation</h2>

<p>Setting up QuickJS is <em>dead</em> simple:</p>

<ul>
<li>clone one of the Github mirrors with <code>git clone git@github.com:ldarren/QuickJS.git</code></li>
<li><code>cd QuickJS</code></li>
<li><code>make</code></li>
</ul>


<p>&hellip;and that&rsquo;s it: the installation will leave you with a few
interesting binaries, the most interesting one being <code>qjsc</code>,
the compiler you can use to create executables out of your JS
code.</p>

<h2>Trying it out</h2>

<p>Let&rsquo;s try to write a simple script that calculates powersets
for a given list:</p>

<p>``` js
function powerSet(str) {</p>

<pre><code>var obj = {}

for(var i = 0; i &lt; str.length; i++){
   obj[str[i]] = true;
}

var array = Object.keys(obj);
var result = [[]];

for(var i = 0; i &lt; array.length; i++){
   var len = result.length; 

   for(var x = 0; x &lt; len; x++){
     let set = result[x].concat(array[i])
     console.log(set)
     result.push(set)
   }
}

return result;
</code></pre>

<p>}</p>

<p>powerSet([1,2,3,4])
```</p>

<p>then we can compile it down to a binary:</p>

<p><code>
./qjsc -o powerset powerset.js
</code></p>

<p>and execute it:</p>

<p><code>
$ ./powerset
1
2
1,2
3
1,3
2,3
1,2,3
4
1,4
2,4
1,2,4
3,4
1,3,4
2,3,4
1,2,3,4
</code></p>

<p>That&rsquo;s it &mdash; quite of a breeze!</p>

<h2>Where&rsquo;s the catch?</h2>

<p>Well, QuickJS' standard library is fairly limited at the moment,
meaning you won&rsquo;t be able to use most NPM modules or the NodeJS standard
library since it&rsquo;s not really implemented: QuickJS simply implements
the ES2019 specification, which doesn&rsquo;t include any kind of standard
item you might be used to, like <code>require</code> or <code>process</code>.</p>

<p>The full <a href="https://bellard.org/quickjs/quickjs.html">documentation for QuickJS is available here</a>,
and you will notice that the only <a href="https://bellard.org/quickjs/quickjs.html#Standard-library">standard objects you can work with</a>
are <code>std</code> and <code>os</code> &mdash; very limited when compared to other, fully-bloated
engines but useful nevertheless (again, you have to think of QuickJS as an
engine to be embedded, and not something you can use to write your next
web app).</p>

<p>Still, quite an impressive piece of work!</p>
]]></content>
  </entry>
  
</feed>