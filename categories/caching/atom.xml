<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Category: Caching | Alessandro Nadalin]]></title>
  <link href="https://odino.org/categories/caching/atom.xml" rel="self"/>
  <link href="https://odino.org/"/>
  <updated>2022-11-18T09:33:53+00:00</updated>
  <id>https://odino.org/</id>
  <author>
    <name><![CDATA[Alessandro Nadalin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[HTTP Cache 101: Scaling the Web]]></title>
    <link href="https://odino.org/http-cache-101-scaling-the-web/"/>
    <updated>2017-06-18T22:05:00+00:00</updated>
    <id>https://odino.org/http-cache-101-scaling-the-web</id>
    <content type="html"><![CDATA[<p><img class="right nobo" src="/images/internetz.png"></p>

<p>I recently gave another read at my original post &ldquo;<a href="http://odino.org/rest-better-http-cache/">REST better: HTTP cache</a>&rdquo;
and I felt compelled to write a more in-depth dive into the subject, especially since it&rsquo;s
one of the most popular topics in this blog; at the same time, with the advent of
new technologies such as <a href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers">sevice workers</a>, people jumped into the bandwagon of
offline applications without, in my opinion, understanding that the HTTP cache
provides some basic but extremely interesting features for offline experiences
&mdash; thus, I want to shed some light on one of the most ingenious sections of the
HTTP protocol.</p>

<!-- more -->


<h2>What is the HTTP cache?</h2>

<p>First of all, let&rsquo;s start by dividing HTTP into 2 entities:</p>

<ul>
<li>the <a href="https://www.w3.org/Protocols/rfc2616/rfc2616.txt">spec</a><sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>, which highlights how messages can be exchanged between clients and servers</li>
<li>the implementation (for example, Google Chrome is an HTTP client, Nginx implements an HTTP server and so on)</li>
</ul>


<p>So, for example, with HTTP/2 we have seen a revamped <em>implementation</em>, one that
brings TSL by default, that turned plaintext messages (the way messages were exchanged
in HTTP/1) into binary, along with the introduction of <a href="https://en.wikipedia.org/wiki/Multiplexing">multiplexing</a>
(in short: one connection can channel multiple requests and responses) and the
likes &mdash; HTTP/2 was a massive upgrade to HTTP and is making the web a much
safer, faster place. At the same time, <strong>the spec itself didn&rsquo;t change as much</strong>, as
the semantics of the protocol have been widely unaffected by HTTP/2.</p>

<p>HTTP caching falls under the HTTP spec, as it&rsquo;s simply a chapter that defines how messages can be cached by both clients &amp; servers: the current
version of the HTTP caching spec is <a href="https://tools.ietf.org/html/rfc7234">RFC7234</a>,
so you can always head there and have a look by yourself.</p>

<p>The goal of the HTTP caching spec is, in short, to:</p>

<p><blockquote><p>[&hellip;] significantly improve performance by reusing a prior response message to satisfy a current request.</p><footer><strong>RFC7234 <a href="https://tools.ietf.org/html/rfc7234">https://tools.ietf.org/html/rfc7234</a></strong></footer></blockquote></p>

<p>or, as <a href="https://tomayko.com/">some smart guy</a> once said:</p>

<p><blockquote><p>[&hellip;] never generate the same response twice</p><footer><strong>Ryan Tomayko <a href="https://tomayko.com/blog/2008/rack-cache-announce">https://tomayko.com/blog/2008/rack-cache-announce</a> Introducing Rack Cache</strong></footer></blockquote></p>

<p>Surround your pullquote like this {" text to be quoted "}</p>

<h2>Expiration</h2>

<p>This is the sort of caching you&rsquo;re used to see every day, which allows you to specify TTLs
(<em>time to live</em>) for static assets like JS, CSS &amp; the likes: we know those assets
are cacheable for a long time, so we specify an expiration date on those resources.</p>

<p>As I mentioned, expiration is generally used for static assets, but can be used
for any kind of resource (ie. <code>GET /news/1</code>), so don&rsquo;t just think caching is for
content that never changes (such as a minified JS file).</p>

<p>How can we implement expiration though? Through 2 very simple HTTP headers.</p>

<h3>Expires</h3>

<p>The <code>Expires</code> HTTP header allows  us to specify a future date that defines until
when a resource should be cacheable:</p>

<p><img class="center nobo" src="/images/expires.png"></p>

<p>If the client needs to fetch the same resources later on, it will first figure out
if it has expired and, if not, use the local copy stored in the cache, without
hitting the origin server. An example implementation might look like:</p>

<p>``` js
cache = {}</p>

<p>server.on(&lsquo;request&rsquo;, (req, res) => {
  if (cache[req.url] &amp;&amp; cache[req.url].headers.expires > now) {</p>

<pre><code>return res.send(cache[req.url])
</code></pre>

<p>  }</p>

<p>  upstreamResponse = server.forward(req)</p>

<p>  if (upstreamResponse.headers.expires) {</p>

<pre><code>cache[req.url] = upstreamResponse;
</code></pre>

<p>  }</p>

<p>  res.send(upstreamResponse)
})
```</p>

<p>This is a very simplistic implementation, but should give you an idea of the
process an <em>HTTP intermediary</em> (a browser, a proxy, etc) goes through when
implementing basic HTTP cache through the <code>Expires</code> header.</p>

<h3>Cache-Control</h3>

<p>If we want to get a bit fancier, we can use the <code>Cache-Control</code> header, which allows
us more control over how a response should be cached; for example, here&rsquo;s an HTTP
response using <code>Cache-Control</code>:</p>

<p>``` bash
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: &hellip;
Cache-Control: public, max-age=3600, s-maxage=60, stale-if-error=600, no-transform</p>

<p>// &hellip;JS content here&hellip;
```</p>

<p>Wow, that&rsquo;s a lot of stuff to process, so let&rsquo;s break it down:</p>

<ul>
<li><code>Cache-Control</code> allows you to embed multiple caching directives into one header</li>
<li>directives are comma separated</li>
<li>in most cases, directives are parsed as key-value pairs (ie. <code>key=val</code>) &mdash; some of them, though, require no value (ie. <code>no-transform</code>)</li>
<li>they control different aspects of the cacheability of a resource</li>
</ul>


<p>Surround your pullquote like this {" text to be quoted "}</li>
</ul>


<h3>Stale-* directives</h3>

<p>An ingenious trick, the <code>stale-while-revalidate</code> and <code>stale-if-error</code> cache-control
directives are worth a mention on their own, as what they let you achieve is <a href="https://tools.ietf.org/html/rfc5861">pretty
interesting</a>:</p>

<ul>
<li><code>stale-if-error</code> tells the cache that it can serve a cached response if, by any chance, it encounters an error when fetching a fresh response from the origin server. In other words, this means that an HTTP cache can be smart enough to serve cached content when you server starts returning 500 errors &mdash; talk about fault tolerance!</li>
</ul>


<p><img class="center nobo" src="/images/stale-if-error.png"></p>

<ul>
<li><code>stale-while-revalidate</code> lets you serve cached content while refreshing the cache instead. This is fairly interesting as, if 100 clients are accessing your cache at <em>T0</em>, you can serve them a cached resource at <em>T1</em> (even if it&rsquo;s  stale), while revalidating the cache in background. If a client then requests the same resource at <em>T2</em>, he will receive the version that&rsquo;s been revalidated from the origin server</li>
</ul>


<p><img class="center nobo" src="/images/stale-while-revalidate.png"></p>

<p>Funny enough, <a href="https://www.mnot.net/blog/2014/06/01/chrome_and_stale-while-revalidate">Chrome has been considering implementing this directive</a> for quite
some time, and last I heard it was still just <a href="https://www.chromestatus.com/features/5050913014153216">under consideration</a>,
though it looks like <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=348877#c68">it might never going to make it to Chrome Stable</a>.</p>

<h3>Pragma: an obsolete header you&rsquo;ll still see around</h3>

<p><code>Cache-Control</code> was introduced in HTTP/1.1, meaning there had to be some way to
control caches in the olden HTTP/1.0 days &mdash; that would be
the <a href="https://tools.ietf.org/html/rfc7234#section-5.4">Pragma header</a>.</p>

<p><code>Pragma</code> doesn&rsquo;t let you do much, as you can just tell caches not to cache through
<code>Pragma: no-cache</code> &mdash; nothing too complicated here.</p>

<p>What&rsquo;s interesting, though, is that a few HTTP clients will still consider responses
cacheable if they don&rsquo;t see a <code>no-cache</code> in the <code>Pragma</code>, and so the best practice
to avoid caching has been to send both <code>Cache-Control</code> and <code>Pragma</code>:</p>

<p><code>
HTTP/1.1 200 Ok
Cache-Control: no-cache
Pragma: no-cache
</code></p>

<p>At the same time, a peculiar use of Pragma is by telling HTTP/1.0 caches not to
cache (via <code>Pragma</code>) while allowing HTTP/1.1 caches to do so (via <code>Cache-Control</code>):</p>

<p><code>
HTTP/1.1 200 Ok
Cache-Control: max-age=3600
Pragma: no-cache
</code></p>

<p><strong>Enough with expiration</strong>: it&rsquo;s now time to move on to validation, a more expensive
but granular way to implement HTTP caching.</p>

<h2>Validation</h2>

<p>Expiration provides a very interesting way to keep clients off the server, at the
cost of serving stale content more often than we&rsquo;d might like: in cases when that&rsquo;s
not an acceptable compromise you can use <strong>validation</strong>, as it ensures clients will
always be able to receive the latest, most fresh version of a resource.</p>

<p><img class="right nobo" src="/images/if-none.png"></p>

<p>At its core, validation works in a very simple manner: when you request a resource,
the server assigns a &ldquo;tag&rdquo; to it (let&rsquo;s say <code>v1</code>) and the next time you request the
same resource you include the tag in your request; the server, at this point, can
quickly check if the resource has changed: if so, it returns the new version, else
it tells you to use the cached version you should have with you.</p>

<p>In HTTP words this is how it basically works:</p>

<p>``` bash</p>

<h1>First request</h1>

<p>GET /news/1 HTTP/1.1</p>

<h1>Response</h1>

<p>HTTP/1.1 200 OK
Etag: 1234</p>

<p>The content of the resource</p>

<h1>Second request</h1>

<p>GET /news/1 HTTP/1.1
If-None-Match: 1234</p>

<h1>Response if the content has changed</h1>

<p>HTTP/1.1 200 OK
Etag: 9876</p>

<p>The NEW content of the resource</p>

<h1>Response if the content is the same</h1>

<p>HTTP/1.1 304 Not Modified
```</p>

<p>As you see, returning a <code>304 Not Modified</code> is cheaper as it doesn&rsquo;t contain as many
information as the &ldquo;real&rdquo; resource: less packets traveling through the network, thus
a faster response.</p>

<p>At the same time, calculating an <code>Etag</code> (the HTTP header used to tag resources) is
generally cheaper than rendering your resource again &mdash; let&rsquo;s look at some pseudo-code
to understand what we&rsquo;re talking about:</p>

<p>``` js
// GET /news/:id
server.on(&lsquo;request&rsquo;, (req, res) => {
  news = db.fetchNews(req.params.id)</p>

<p>  if (req.headers.etag === news.version) {</p>

<pre><code>return res.send(304)
</code></pre>

<p>  }</p>

<p>  res.render(&lsquo;news_template.html&rsquo;, {news})
})
```</p>

<p>We have saved the server some extra work by not rendering the news template all
over again: this might feel like a small saving, but put it in the context of
thousands of requests every day and you see where we&rsquo;re going.</p>

<p>Looking back at our second request:</p>

<p><code>bash
GET /news/1 HTTP/1.1
If-None-Match: 1234
</code></p>

<p>you might be wondering what&rsquo;s that <code>If-None-Match</code>, so let me break the whole
process down for you:</p>

<ul>
<li>client requests a resource</li>
<li>server returns it and tags it with the <code>Etag</code> header</li>
<li>client requests the same resource again, and tells the server to return it only if the resource&rsquo;s etag doesnt match the one we&rsquo;re sending (that&rsquo;s why the header is called <code>If-None-Match</code>)</li>
</ul>


<p>A request that contains the <code>If-None-Match</code> header is called a &ldquo;conditional request&rdquo;:
it&rsquo;s expected to fetch a resource only if the condition it is sending
won&rsquo;t be satisfied (the condition is that the client&rsquo;s etag matches the server&rsquo;s).</p>

<p>Conditional requests and validation can be implemented with etags as well as dates:
if you&rsquo;re more comfortable using the latter (think of an <code>updated_at</code> column in the DB)
you can replace <code>Etag</code> with <code>Last-Modified</code> and <code>If-None-Match</code> with <code>If-Modified-Since</code>:</p>

<p>``` bash</p>

<h1>First request</h1>

<p>GET /news/1 HTTP/1.1</p>

<h1>Response</h1>

<p>HTTP/1.1 200 OK
Last-Modified: Wed, 21 Oct 2020 06:00:00 GMT</p>

<p>The content of the resource</p>

<h1>Second request</h1>

<p>GET /news/1 HTTP/1.1
If-Modified-Since: Wed, 21 Oct 2020 06:00:00 GMT</p>

<h1>Response if the content was updated after that date</h1>

<p>HTTP/1.1 200 OK
Last-Modified: Wed, 30 Oct 2020 06:05:00 GMT</p>

<p>The NEW content of the resource</p>

<h1>Response if the content is the same</h1>

<p>HTTP/1.1 304 Not Modified
```</p>

<p>Again, the spec is very simple and doesn&rsquo;t get too fancy, yet it&rsquo;s powerful enough
to let you save so much time and data by returning <code>304</code> rather than &ldquo;full&rdquo; responses &mdash;
that&rsquo;s why I like the HTTP caching spec: it&rsquo;s so clever and simple!</p>

<h2>Who can cache my responses?</h2>

<p>HTTP is a layered protocol, meaning there can be countless intermediaries between
the client and the server &mdash; a picture is worth
a thousand words:</p>

<p><img class="center nobo" src="/images/types-caches.png"></p>

<p>So, who are all these guys that can cache resources all along the way?</p>

<ul>
<li>nothing to explain in terms of <strong>browsers</strong>, as we&rsquo;re all familiar with them.
Worth to note that, when you use <code>curl</code> from your command-line, that&rsquo;s your browser</li>
<li><strong>proxies</strong>, instead, are generally installed between the client and the internet,
and they provide a shield between the two. Proxies are shared caches as, for example,
you could install them at your company so that multiple browsers use the same proxy
&mdash; that way, if I request a cacheable resource and one of my co-workers requests the
same, he will be served the cached response I generated, by the proxy</li>
<li><strong>ISPs / the internet</strong>: well, that&rsquo;s the backbone of your internet connection, and
they could implement caching on their own</li>
<li>proxies installed on the server-side are called <strong>reverse proxies</strong> instead,
as their job is to shield multiple servers from requests. Reverse proxies are also
called &ldquo;HTTP accelerators&rdquo;, as their main job is to avoid requests from hitting
the origin servers. <a href="https://varnish-cache.org/">Varnish</a> is one of the most popular reverse proxies out there</li>
<li>last but not least you&rsquo;ve got your <strong>origin servers</strong>, where your applications
run. They can implement HTTP caching on their own, even though it&rsquo;s generally
preferred to have a dedicated reverse proxy to offload origins</li>
</ul>


<h2>Warning: when things don&rsquo;t go as planned&hellip;</h2>

<p>An interesting header is <code>Warning</code>, as it&rsquo;s used to signal that <em>something went wrong</em>
when fetching the response from the upstream, something that&rsquo;s hard to infer from the HTTP status code
alone: for example, when the cache knows that the response being served is stale, it
could include a <code>Warning: 110 - "Response is Stale"</code> to inform the client that the response
he&rsquo;s receiving isn&rsquo;t fresh at all &mdash; that, for example, could happen when <code>stale-while-revalidate</code>
or <code>stale-if-error</code> kick in:</p>

<p>```</p>

<h1>The HTTP status code says everything&rsquo;s good,</h1>

<h1>but the warning header tells the client the</h1>

<h1>response being served is not fresh</h1>

<p>HTTP/1.1 200 Ok
Warning: 110 &ndash; &ldquo;Response is Stale&rdquo;
```</p>

<h2>A note on Service Workers</h2>

<p>Surround your pullquote like this {" text to be quoted "}</p>

<p><img class="right nobo" src="/images/99-devs.png"></p>

<p>Service workers are great because they let us implement functionalities we traditionally
never had on the web (think of <a href="https://developers.google.com/web/fundamentals/getting-started/codelabs/push-notifications/">push notifications</a>, <a href="https://developers.google.com/web/fundamentals/engage-and-retain/app-install-banners/">add to homescreen</a>, <a href="https://developers.google.com/web/updates/2015/12/background-sync">background sync</a>
and the likes) but, for stuff that&rsquo;s been there, I
would advise to stick to the basics.</p>

<p>Let&rsquo;s have a look at an example code from a service worker that implements its own
caching &mdash; as you see not most straightforward code you&rsquo;ll bump
into:</p>

<p>``` js
this.addEventListener(&lsquo;fetch&rsquo;, function(event) {
  event.respondWith(</p>

<pre><code>caches.match(event.request).then(function(resp) {
  return resp || fetch(event.request).then(function(response) {
    caches.open('v1').then(function(cache) {
      cache.put(event.request, response.clone());
    });
    return response;
  });
}).catch(function() {
  return caches.match('/sw-test/gallery/myLittleVader.jpg');
})
</code></pre>

<p>  );
});
```</p>

<p>As Jake Archibald, developer advocate at Google,
puts it:</p>

<p><blockquote><p>You can hack around poor caching in your service worker, but you&rsquo;re way better off fixing the root of the problem. Getting your [HTTP] caching right makes things easier in service worker land, but also benefits browsers that don&rsquo;t support service worker (Safari, IE/Edge), and lets you get the most out of your CDN.</p><footer><strong>Jake Archibald <a href="https://jakearchibald.com/2016/caching-best-practices/">https://jakearchibald.com/2016/caching-best-practices/</a> Caching best practices</strong></footer></blockquote></p>

<p>Ditto.</p>

<h2>Conclusion</h2>

<p>Caching in HTTP has been here for almost 2 decades, it&rsquo;s a battle-tested
part of the protocol and allows you to efficiently trade freshness with scale
(emphasis on <em>efficiently</em>): there&rsquo;s no reason to implement our own application-level
caches when the protocol we use to exchange messages allows you to do the same,
for free, by just jamming a bunch of headers in your responses.</p>

<p>HTTP caching is truly the hidden gem of the protocol, and I wish more people would
be aware of the inner workings of the spec &mdash; to me it is a great example of
achieving great results without compromising on complexity, and this is the kind
of design we should aim towards when building software.</p>

<p>In short: <em>the HTTP cache is great. Be like the HTTP cache</em>.</p>

<h2>Further readings</h2>

<p>If you enjoyed this article I would suggest you to read further stuff on the HTTP
cache:</p>

<ul>
<li>the complete <a href="https://tools.ietf.org/html/rfc7234">HTTP caching spec</a></li>
<li>I have a <a href="/categories/cache/">few articles</a> on this very same blog</li>
<li><a href="https://www.mnot.net/blog/">Mark Nottingham&rsquo;s blog</a> (Mark is known for his contribution to the HTTP protocol, web caching and for being the &ldquo;chairman&rdquo; of HTTP/2)</li>
<li><a href="https://tomayko.com/blog/2008/rack-cache-announce">Ryan Tomayko</a> is a very smart guy who spoke about HTTP caching in the past. He turns whatever he touches into gold, so follow him ;&ndash;)</li>
<li><a href="https://www.subbu.org/">Subbu Allamaraju</a> is a well-known member of the REST community and <a href="https://www.subbu.org/blog/2005/01/http-caching">has written about HTTP caching</a> in the past</li>
</ul>


<p>See you next time!</p>

<p><div class="footnotes">
<span>
Notes
</span>
	<ol>
		<li id='fn:1'>Worth to note that RFC2616 has been superseded by a few updates (RFCs 7230, 7231, 7232, 7233, 7234, 7235, which update part of the original spec) <a href='#fnref:1' rev='footnote'>↩</a></li>
	</ol>
</div>
</p>

<!--

BALSAMIQ

{"mockup":{"controls":{"control":[{"ID":"3","measuredH":"128","measuredW":"128","properties":{"icon":{"ID":"server","size":"xxlarge"}},"typeID":"Icon","x":"871","y":"251","zOrder":"2"},{"ID":"5","measuredH":"128","measuredW":"128","properties":{"icon":{"ID":"laptop","size":"xxlarge"}},"typeID":"Icon","x":"246","y":"261","zOrder":"3"},{"ID":"10","h":"50","measuredH":"126","measuredW":"100","properties":{"hasHeader":"false","icons":{"icons":[{"size":null}]},"rowHeight":"39","size":"17","text":"GET /static/app.js","verticalScrollbar":"false"},"typeID":"List","w":"190","x":"517","y":"220","zOrder":"4"},{"ID":"14","h":"55","measuredH":"54","measuredW":"439","properties":{"curvature":"1","direction":"top","leftArrow":"false","p0":{"x":0,"y":44},"p1":{"x":0.4808345264880343,"y":0.10920433626508488},"p2":{"x":439,"y":54},"rightArrow":"true","shape":"bezier","text":""},"typeID":"Arrow","w":"440","x":"401","y":"232","zOrder":"1"},{"ID":"16","h":"30","measuredH":"54","measuredW":"439","properties":{"curvature":"-1","direction":"top","leftArrow":"true","p0":{"x":0,"y":0},"p1":{"x":0.48416925542342376,"y":-0.055030313088304694},"p2":{"x":439,"y":10},"rightArrow":"false","shape":"bezier","text":""},"typeID":"Arrow","w":"440","x":"401","y":"378","zOrder":"0"},{"ID":"17","h":"120","measuredH":"140","measuredW":"200","properties":{"size":"18","text":"HTTP/1.1 200 Ok\nContent-Type: application/javascript\nContent-Length: 1234\n*Expires: Wed, 21 Oct 2020 07:00:00*"},"typeID":"TextArea","w":"332","x":"455","y":"351","zOrder":"5"}]},"measuredH":"471","measuredW":"999","mockupH":"251","mockupW":"753","version":"1.0"}}
 -->

]]></content>
  </entry>
  
</feed>